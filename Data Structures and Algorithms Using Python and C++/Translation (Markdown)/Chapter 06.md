# 递归

目标

* 理解递归作为解决技术问题的一个方法的基本原理。

* 能够编写格式良好的递归函数。

* 能够分析简单的递归函数的行为，并且能够分析它的运行时效率。

* 能够分析递归相对于迭代的优缺点，并了解应该分别在什么时候使用它们。

## 介绍

你现在肯定已经知道了，在设计程序的时候会用到的最好的技术之一是：将问题分解成为更小的子问题。
在某些情况下，你最终可能会遇到相同问题的较小版本。
比如，回想一下用于在有序列表里查找元素的基本二分搜索算法，我们在1.3.2小节里就介绍过了它。
为了方便你的记忆，这是我们开发的代码：

```Python
def search(items, target):
    low = 0
    high = len(items) - 1
    while low <= high:          # There is still a range to search
        mid = (low + high) // 2 # position of middle item
        item = items[mid]
        if target == item :     # Found it! Return the index
            return mid
        elif target < item:     # x is in lower half of range
            high = mid - 1      # move top marker down
        else:                   # x is in upper half
            low = mid + 1       # move bottom marker up
    return -1                   # no range left to search,
                                # x is not there
```

我们已经知道了这个算法的时间复杂度为$Θ(\lg n)$，其中$n$是列表的大小。
这是因为，通过主循环的每次迭代，都会将需要考虑的元素数减少一半。
如果你已经忘记了这个重要的算法，现在就回去再理解一次它吧。

二分搜索使用了所谓的“分而治之”的方法，这个方法通常会得到非常高效的算法。
这类算法也有一个有趣的特征，那就是：
原始问题被分解成的子问题，实际上是较小版本的原始问题。
在二分查找的情况下，第一步是查看列表的中间的元素；
如果它不是目标，我们将会继续*在列表的上半部分或下半部分执行二分搜索*。
基于这种思想，现在我们可以用稍微不同的形式来表达二分搜索算法：

```Python
Algorithm: binarySearch -- search for x in nums[low]...nums[high]

mid = (low + high) / 2
if low > high
    x is not in nums
elif x < nums[mid]
    perform binary search for x in nums[low]...nums[mid-1]
else
    perform binary search for x in nums[mid+1]...nums[high]
```

这个版本不像之前那个版本——在算法里使用循环；
二分搜索算法的这个定义看起来是让它指向了它自己。
这样做会发生什么呢？
我们真的可以这样来理解一件事情吗？

## 递归定义

描述引用自身的这种现象被称为*递归定义*（*recursive definition*）。
在我们的刚刚的描述里，二分搜索算法使用了它自己的描述。
换句话说就是：在二分搜索定义里，“递归”地“调用”了二分搜索——因此，被称为“递归定义”。

乍一看，你可能会觉得递归定义没什么意义。
相信你曾经有一位老师坚持让你不能在一个词的定义里使用这个词本身？
因为，这被称为循环定义，通常在考试中不会得分。

然而，在数学里，一直使用着某些递归定义。
只要我们在制定和使用递归定义时特别小心，就会发现它们非常的方便而且功能强大。
数学中的一个经典的递归例子是阶乘的定义。

阶乘函数通常用感叹号（$!$）来表示，于是$n$阶乘是这样计算的：

$$
n! = n(n − 1)(n − 2)...(1)
$$

因此，我们可以这样来计算：

$$
5! = 5(4)(3)(2)(1)
$$

利用这个定义，编写一个返回参数的阶乘的函数`fact(n)`就非常容易了。
你只需要一个`for`循环来累计从$2$到$n$的所有因子的乘积就行了。
我们将这个代码实现留给你来完成，因为这个实现并不是我们感兴趣的解决方案。

回过头来看看$5!$的计算，你会发现一些有趣的信息。
如果我们从方程的右侧前面移除掉$5$，剩下的是部分就是计算$4!$了。
一般来说，$n! = n(n-1)!$。
于是乎，这种关系为我们提供了另一种表达阶乘的通用方式。
这是一个用递归来定义的阶乘函数：

$$
n!=
\begin{cases}
    1        & \quad \text{当} \quad n = 0 \quad \text{时}\\
    n(n-1)!  & \quad \text{其他情况}
\end{cases}
$$

这个定义代表着，根据定义，$0$的阶乘是$1$，而任何其他数字的阶乘被定义为：
这个数字乘以比这个数字小$1$的阶乘。

即使这个定义是递归的，它也并不是一个循环。
而且，它提供了一种计算任何自然数的阶乘的非常简单的方法。
考虑$4!$的值。
根据定义，我们有：

$$
4! = 4(4 − 1)! = 4(3!)
$$

但是什么是$3!$呢？
为了找到这个答案，我们只能再次应用这个定义：

$$
4! = 4(3!) = 4[(3)(3 − 1)!] = 4(3)(2!)
$$

当然，接下来，我们就必须要去扩展$2!$了，它需要$1!$，而$1!$需要$0!$。
而$0!$的值是$1$，所以我们就不用继续扩展下去了：

$$
4! = 4(3!) = 4(3)(2!) = 4(3)(2)(1!) = 4(3)(2)(1)(0!) = 4(3)(2)(1)(1) = 24
$$

你可以看到递归定义并不是一个循环，这是因为程序的每个步都会让我们去请求更小一个数字的阶乘。
在最后，这个数字会变为$0$，而$0$，按照定义，就不需要再去执行另外一步了。
这种情况，被称为递归的*基本情况*（*base case*）。
当递归到了最底层的时候，我们就获得了一个可以被用于直接计算的闭合表达式。
所有的好的递归定义都应该具有下面这些关键特征：

1. 有一个或多个不需要递归的基本情况。

2. 递归所有的链，最终都必须达到基本情况。

要保证能够满足这两个条件的最简单方法是：
确保每个递归都始终发生在原始问题的*更小的*版本上。
可以在没有递归的情况下被解决的这个问题的非常小的版本，就是基本情况。
这也就是为什么阶乘的定义是可以得到结果的。

就像上面说的那样，也可以通过聚合和循环来计算阶乘。
这个实现和我们提出的对阶乘的定义是非常自然的相互对应的。
那么，我们可以实现一个遵循递归定义的阶乘函数的版本吗？

如果我们把阶乘写在一个函数里，于是乎递归定义可以直接被转换为代码：

```Python
# fact.py
def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)
```

你发现了引用自身的定义是怎么变成了一个引用自己的函数的吗？
这个函数被称为*递归函数*（*recursive function*）。
函数首先会去检查我们是否处于基本情况——$n == 0$：
如果是的话，则返回$1$；
如果不是基本情况的话，那么函数会返回$n$乘以$n-1$的阶乘的结果。
而后者，会通过递归调用`fact(n-1)`函数来计算。

这是递归定义的合理的代码翻译。
而且，真正酷的地方在于：这段代码是可以正常工作的！
我们真的可以使用这个递归函数来计算阶乘的值。

```Python
>>> from fact import fact
>>> fact(4)
24
>>> fact(10)
3628800
```

可能一些刚接触递归的程序员会对这样的结果感到十分的惊讶，但它非常自然地遵循了函数调用的标准语义。
要知道，每次调用一个函数都会全新的启动这个函数。
而由于有了运行时堆栈，函数的每次调用都会让它有一套自己的本地变量的值，这其中也包括了参数变量的值。
图6.1里展示了计算$5!$的递归调用的序列。
要特别注意的是，看看每个返回值，是怎样和每个函数调用所记住的自己的$n$的值进行相乘的。
$n$的值在递归的链路上会自动地存储在堆栈里，然后在返回路径里的函数调用`return`的时候，弹出这个值并且被使用。

图6.1：用递归来计算$5!$

## 简单的递归示例

对于许多问题，都存在着优雅并且高效的递归解决方案。
在本节里，我们将介绍一些简单的递归问题的解决方法。

### 示例：字符串反转

Python列表内置了一个可以被用来反转列表的方法。
假设你要处理字符串的反转。
一种比较高效的办法是，把字符串转换为字符列表，之后反转这个列表，再然后将列表转换回字符串。
然而，如果使用递归的话，我们就能够非常轻松地编写出一个直接处理字符串反向的函数，而且还不必通过列表来作为中间存储。

这样做的基本思想是：
把字符串当作一个递归对象。
一个大的字符串是由若干个较小的对象组成的，而且这些对象也是字符串。
实际上，一种能够把几乎所有序列都进行拆分的非常方便的方法是：
把它的第一个元素当作单独的存在，而这个元素的后面则恰好紧跟着另一个序列。
在字符串这个情况下，我们可以把它拆分成第一个字符和“所有其它的字符”。
这样，如果我们反转字符串里的其余部分，并且把第一个字符放在字符串的结尾处，我们就能够把整个字符串将反过来了。

让我们把这个算法编写成代码，看看会发生什么：

```Python
def reverse(s):
    return reverse(s[1:]) + s[0]
```

可以注意一下，这个方法的工作原理。
切片`s[1:]`会给出除字符串的第一个字符之外的所有其他字符。
然后我们反转这个切片（递归），并且把第一个字符（`s[0]`）连接到这个结果的末尾。
用一个具体的例子来进行思考可能会对你的理解更有帮助。
假设，`s`是字符串`"abc"`，那么`s[1:]`就是字符串`"bc"`。
反转它会产生`"cb"`，然后再在最后加上`s[0]`，就能够得到`"cba"`了。
这正好就是我们想要的答案。

然而，遗憾的是，这个功能并不能正常工作。
下面是我们尝试运行这段代码时会发生的输出：

```Python
>>> reverse("Hello")
Traceback (most recent call last):
    File "<stdin>", line 1, in ?
    File "<stdin>", line 2, in reverse
    File "<stdin>", line 2, in reverse
...
    File "<stdin>", line 2, in reverse
RuntimeError: maximum recursion depth exceeded
```

在这里，我们只显示了一部分输出。
整段输出实际上有1000行之多！
那么，是什么错误导致了这个问题呢？

回忆一下，我们提到过，为了构建一个正确的递归函数，我们需要有一个不需要继续递归的基本情况，不然的话递归就变成了无限循环。
我们在编写函数代码的时候太着急了，以至于我们忘了要包含一个基本情况。
因此，我们写的代码实际上是一个*无限递归*（*infinite recursion*）。
每次调用`reverse`方法都包含着另一个`reverse`方法的调用，因此它们会一直下去，根本不会返回。
当然，每当一个函数被调用的时候，它都会占用一些内存（将参数和局部变量存储在运行时堆栈里），因此这个过程并不能永远的持续下去。
Python在第1,000次的调用之后就终止了这个方法，因为1,000是默认的“最大递归深度”。

让我们回过头来找出一个合适的基本情况。
在对序列执行递归时，基本情况通常是空序列或者仅仅包含一个元素的序列。
对于我们的字符串反转问题，我们可以使用空字符串来作为基本情况，因为空字符串是它自己的反转。
当递归调用`reverse`方法的时候，总是会用一个比原始字符串还要短一个字符的字符串。
所以，最后我们总会得到一个空字符串。
这是`reverse`方法的正确版本：

```Python
# reverse.py
def reverse(s):
    if s == "":
        return s
    else:
        return reverse(s[1:]) + s[0]
```

这个版本和我们所期望的效果是一样的。

```Python
>>> reverse("Hello")
'olleH'
```

### 示例：字谜

字谜是通过重新排列单词的字母来构建的。
字谜通常被用在文字游戏里，构建一个新的字谜是产生序列的可能排列（重新排列）的特殊情况，这是一个在计算机和数学的许多领域中都频繁出现的一个问题。

让我们尝试编写这样一个函数，它能够生成一个字符串的所有可能的字谜列表。
就像前一个示例中使用的方法那样，我们将会通过对字符串的第一个字符进行切片，来实现我们的应用程序。
假设原始字符串是`"abc"`，那么字符串的尾部就是`"bc"`。
生成尾部所有可能的字符串的列表会让我们得到`["bc"，"cb"]`，因为对于两个字符来说，只有两种可能的排列。
接着，我们需要把第一个字符`"a"`添加回去，我们可以把它分别放在这两个字谜里的所有位置：`["abc"，"bac"，"bca"，"acb"，"cab"，"cba"]`。
前三个字谜来自于：在`"bc"`中的每个可能的位置放置`"a"`；
而后三个字谜来自于：把`"a"`插入到`"cb"`里的每个可能的位置。

和前面的例子一样，我们可以使用空字符串来作为递归的基本情况。
空字符串唯一可能的字符排列是空字符串本身。
这样，我们就完成了这个递归函数：

```Python
# anagrams.py
def anagrams(s):
    if s == "":
        return [s]
    else:
        ans = []
        for w in anagrams(s[1:]):
            for pos in range(len(w) + 1):
                ans.append(w[:pos] + s[0] + w[pos:])
        return ans
```

可以看到，在`else`里我们使用了一个列表来累积最终的结果。
在嵌套的`for`循环这部分，外循环遍历`s`尾部的每一个字谜；
内循环则遍历这个字谜里的每个位置，并通过把第一个字符插入到这个位置来创建一个新的字符串。
表达式`w[:pos] + s[0] + w[pos:]`看起来有点复杂，但是理解起来并不难。
`w[:pos]`会给出`w`的从第一个字符到`pos`处（但不包括）的部分；
`w[pos:]`则会产生从`pos`位置开始到结尾的所有东西。
之后，在这两部分之间加上`s[0]`，也就相当于在`w`的位置`pos`处进行插入。
内循环会持续到到`len(w) + 1`，这是为了让这个字符能够被被添加到字谜的最末端。

于是我们的方程执行结果是：

```Python
>>> anagrams("abc")
['abc', 'bac', 'bca', 'acb', 'cab', 'cba']
```

我们没有在这个例子中使用`"Hello"`的原因是，使用它作为参数的话，会产生比我们预想多得多的字谜被输出。
这是因为：单词的字谜数量是单词长度的阶乘。

### 示例：快速计算指数

另一个可以用递归来解决的非常好的例子是：计算一个数字的整数幂的聪明的算法。
计算整数$a*n$的最明了的方法就是：
简单地把$a$乘以$n$倍就行了：$a^n = a * a * a * ... * a$。
我们可以使用一个简单的循环来累计结果，从而轻松的实现这个算法：

```Python
# power.py
def loopPower(a, n):
    ans = 1
    for i in range(n):
        ans = ans * a
    return ans
```

但是，分而治之的策略提出了另一种处理这个计算的方法。
假设我们想要计算$2^8$。
根据指数定律，我们知道$2^8 = 2^4(2^4)$。
因此，如果我们先计算$2^4$的话，我们只需要再做一次乘法就能够得到$2^8$了。
而为了计算$2^4$，我们可以利用$2^4 = 2^2(2^2)$这个事实。
当然，$2^2 = 2(2)$。
于是，整个计算就变成了，我们先计算$2(2)= 4$，接着$4(4)= 16$，最后$16(16)= 256$。
我们只用了三次乘法，就计算出了$2^8$的值。
这个想法的基础在于，使用了这样一个关系$a^n = a^{n//2}(a^{n//2})$。

在这个例子里，指数是偶数。
为了能够把这个想法变成一个通用的算法，我们还必须处理$n$是奇数的情况。
其实，这可以通过多增加一次乘法来完成。
比如说，$2^9 = 2^4(2^4)(2)$。
下面就是这个通用关系：

$$
a^n =
\begin{cases}
    a^{n//2}(a^{n//2}     & \quad \text{当} n \text{是偶数的时候}\\
    a^{n//2}(a^{n//2}(a)  & \quad \text{当} n \text{是奇数的时候}
\end{cases}
$$

在这个公式里，我们利用了整数除法，因此，如果$n$是$9$的话，则$n // 2$是$4$。

我们可以利用这种关系作为递归函数的基础。
接下来，我们就只需要再找到一个合适的基本情况就行了。
可以看出来，计算$n$次幂需要计算两个较小的幂（$n // 2$）。
如果我们继续使用越来越小的$n$值，那么这个较小的幂最终会变为$0$（$1 // 2 = 0$）。
就像你在数学课里学到的那样，对于任意的$a$（$0$除外），都有$a^0 = 1$。
现在可以把这个当作我们的基本情况。

如果你已经理解了上面提到的数学运算的话，那么这个函数的实现就很简单了。

```Python
# power.py
def recPower(a, n):
    # raises a to the int power n
    if n == 0:
        return 1
    else:
        factor = recPower(a, n // 2)
        if n % 2 == 0:          # n is even
            return factor * factor
        else:                   # n is odd
            return factor * factor * a
```

需要注意的一点是，在代码里，为了让$a^{n//2}$只需要计算一次，我们使用了中间变量`factor`来缓存它。
这样就能够让我们的算法更加的高效。

### 示例：二分搜索

现在既然你已经知道了应该如何来实现递归函数，现在就可以回过头再去看看我们的二分搜索了。
回忆一下，这个算法的基本的思想是查看中间值，然后通过递归来搜索列表的下半部分或上半部分。

递归的基本情况是我们可以停止递归的条件，也就是：
当找到目标值的时候，或者是我们没有l 还能去的地方的时候。
递归调用每次都会将问题的大小减半。
因此，我们需要为每个递归调用都去指定一下列表中仍然需要被“执行”的位置的范围。
我们可以通过这样的方式来实现：把`low`（低索引）和`high`（高索引）作为参数与列表一起进行传递。
然后保证在每次调用的时候，都只在列表的低索引和高索引之间进行搜索。

下面是使用这个思想所实现的递归算法：

```Python
# bsearch.py
def recBinSearch(x, nums, low, high):
    if low > high:              # No place left to look, return -1
        return -1
    mid = (low + high) // 2
    item = nums[mid]
    if item == x:               # Found it! Return the index
    r   eturn mid
    elif x < item:              # Look in lower half
        return recBinSearch(x, nums, low, mid-1)
    else:                       # Look in upper half
        return recBinSearch(x, nums, mid+1, high)
```

然后，我们可以使用对递归二分搜索的适当调用来实现我们最初的搜索功能。
也就是告诉它，在一开始的时候，对列表的`0`和`len(nums) - 1`之间的元素进行搜索。

```Python
def search(items, target):
    return recBinSearch(target, items, 0, len(items) - 1)
```

当然，我们最初的循环版本可能会比这个递归版本要快一点，这是因为调用函数通常会比迭代循环要慢一些。
然而，递归版本的二分搜索算法，能够让它的分而治之的结构更加明显。
接下来，我们将会看到这样一个例子，对于一些循环不方便处理的问题，递归以及分而治之的解决方案为这些问题提供了非常有用的解决方案。

## 递归的分析

现在，你肯定已经发现了迭代（循环）和递归之间存在一些相似之处。
递归函数其实是一种通用的循环。
任何可以通过循环来完成的事情，就一定可以用简单的递归函数来完成。
因此，有些编程语言甚至只能使用递归。
而且，一些可以通过使用递归来非常简单地完成的事情，用循环来做的话就会非常的麻烦。

对于我们到目前为止所看到的各种问题来说，我们都可以同时有迭代和递归两种解决方案。
在阶乘和二分搜索这两个问题里，循环版本和递归版本基本上执行了相同的计算。
因此，它们将具有大致相同的效率。
而且，由于递归的函数调用会有额外的开销，所以，循环版本可能会更快一些。
对于现代编程语言来说，递归算法一般都能够足够快速的完成运算。

在求幂算法这个例子里，递归版本和循环版本就使用了两种非常不同的算法来实现。
`loopPower`函数里有一个循环了$n$次的简单的计数循环。
很明显，这是一个线性时间（$Θ(n)$）算法。
而在`recPower`函数里，“迭代”的数量是由递归的次数来决定的。
我们必须要先弄清楚嵌套函数调用的堆栈有多深。
由于每一次调用是在原来数字的一半大小的尺寸上进行的，因此只需要$\log_2 n$个递归调用就可以得到$0$了。
在每次函数调用里，最多会进行两次乘法运算，因此我们就有了一个对数时间（$Θ(\lg n)$）的算法。
这两个实现方法的差异类似于线性搜索和二分搜索之间的差异。
因此，递归算法很明显要更好些。
在下一节里，你还会了解到一种非常高效的递归排序算法。

就像你看到的那样，递归是一种非常有用的解决问题的技术，它可以被用来实现正确并且高效的算法。
但在使用的时候，你还是必须要格外小心，这是因为，它也可以编写一些效率非常低的递归算法。
一个非常经典的例子是：计算第$n$个斐波那契（Fibonacci）数。

斐波那契数列是由数字`1,1,2,3,5,8,...`组成的序列。
它由两个$1$作为开始，之后的每个数字都是前两个数字之和。
计算第$n$个斐波那契数的一个方法是，用一个循环来产生一个连续项的序列。

为了计算下一个斐波纳契数，我们总是需要知道前两个数。
我们可以使用两个变量`curr`和`prev`来跟踪这两个值。
然后我们还需要用一个循环，把这两个值加在一起从而达到下一个值。
之后，`curr`的旧值将变成`prev`的新值。
下面的代码是在Python里实现这个算法的一种方法：

```Python
# fib.py
def loopFib(n):
    # pre: n > 0
    # returns the nth Fibonacci number

    curr = 1
    prev = 1
    for i in range(n-2):
        curr, prev = curr + prev, curr
    return curr
```

在这段代码里，我们通过一行命令来同时计算了`curr`和`prev`的下一个值。
要注意的是，这个循环只会发生$n-2$次。
这是因为，序列里的前两个值已经被分配了，因此不再需要放在循环里。
很明显，这是一个$Θ(n)$的算法，其中$n$是输入的参数。

然而，斐波那契数列也有一个非常经典的递归定义：

$$
fib(n) =
\begin{cases}
    1                        & \quad \text{当} n < 3\\
    fib(n − 1) + fib(n − 2)  & \quad \text{其他情况}
\end{cases}
$$

我们可以把这个递归定义直接转换成一个递归函数：

```Python
# fib.py
def recFib(n):
    if n < 3:
        return 1
    else:
        return recFib(n-1) + recFib(n-2)
```

这个方法满足了我们之前制定的规则。
例如：递归总是到较小的值上，而且我们已经确定了一些非递归的基本情况。
因此，这个方法能够正常工作。
然而，事实证明，这是一种非常低效的算法。
我们的循环版本可以轻松地计算$n$值非常大的情况下的结果（在一台相对较新的微型计算机上执行命令`loopFib(50000)`，几乎能够瞬时返回结果）；
但是，递归版本只能在$n = 30$左右或者以下的时候时才能在合理的时间内返回结果。
高于$30$的之后，等待的时间将会非常的长。

斐波那契函数的这个递归公式的问题在于：它执行了大量的重复计算。
图6.2显示了为了计算`fib(6)`而执行的所有的计算。
从图里可以看到，`fib(4)`计算了两次，`fib(3)`）计算了三次，`fib(2)`计算了四次，等等。
如果从较大的数字作为开始的话，你可以看出这种冗余计算是怎样堆积起来的。
而且我们可以看见，在图的底部，每个递归链都会达到1这个最低点的位置。
那么，如果我们能够从$1$开始向上运行的话，你就需要开始调用函数来将这个$1$添加到最终结果里去。
就像图里展示的那样，使用这个算法来计算`fib(6)`的话，一共需要执行$fib(6)-1$个加法！
也就是说，为了计算计算`fib(n)`，这个算法需要$fib(n)-1$步操作。
这也意味着，它是一个$Θ(fib(n))$的算法。
你可以试一些数字，然后你就会发现这个方法需要的时间增长得非常快。
在我们常见的运行分析时，如果你好奇这个时间复杂度在这个结构里会处于什么位置的话，你可以先对斐波那契数列进行一些研究。
可以这么说，这个函数的运行时间是以$n$为幂的指数。

图6.2：为`fib(6)`执行的计算

所以，这告诉了我们什么呢？
递归只是你解决问题的一个工具。
有时候，递归解决方案是一个很好的解决方案，这是因为它比循环版本更优雅或者更高效。
在这种情况下，我们就应该使用递归。
通常来说，循环和递归版本非常相似。
在这种情况下，我们可能会更倾向于使用循环，这是因为循环会稍微快一些。
有时候，递归版本会非常低效。
在这种情况下，很明显，除非你无法找到一个迭代算法来完成，你应该避免去使用它。
就像你将在这一章的后面部分会看到的那样，有时候，有些问题就是没有一个有效的解决方案。

## 排序

在第3章，我们曾经讨论过能够把列表里的值按照顺序进行排列的选择排序算法。
回想一下，选择排序算法通过搜索列表来查找最小（或最大）元素，并且将其交换到列表的前面，从而让整个列表能够按照一定顺序来排列列表。
之后，我们搜索剩下的元素来找到下一个最小的元素，然后再把它交换到下一个合适的位置。
这个过程一直持续，直到每个元素都被放在了适当的位置。
作为复习，这是Python的选择排序的一个版本：

```Python
# selectionSort.py
def selectionSort(lst):
    n = len(lst)
    for i in range(n-1):
        min_pos = i
        for j in range(i+1,n):
            if lst[j] < lst[min_pos]:
                min_pos = j
        lst[i], lst[min_pos] = lst[min_pos], lst[i]
```

就像我们在之前提出这个算法时所讨论的那样，选择排序的操作执行次数是$Θ(n^2)$时间的，其中$n$是列表的大小。
对于小型列表来说，它还是很好用的，但对于大型集合来说，它的效率就不太好了。

### 递归设计：归并排序

就像前面说的那样，分而治之是一种通常能够开发出高效算法的技术。
假设你和一个朋友一起尝试把一副扑克牌按照顺序进行排序。
你可以通过将这副牌分成两半来分解问题，这样的话，每个人都将会对其中一半的扑克牌进行排序。
这样一来，你就只需要再去找出一个能够组合两个有序堆的方法。

将两个有序列表组合成单个有序结果的过程被称为*归并*（*merging*）。
因此，对于我们的分而治之的算法来说，它被称为*归并排序*（*mergesort*）。
这个算法如下所示：

```
Algorithm: mergeSort nums

split nums into two halves
sort the first half
sort the second half
merge the two sorted halves back into nums
```

算法的第一步非常简单，我们可以使用列表的切片方法来处理它。
算法的最后一步是将列表合并在一起。
如果你多考虑一会儿的话，你会发现合并并不困难。
让我们回到扑克牌堆的例子里，以得到更多的细节。
由于我们对两个堆都进行了排序，因此每个堆的最小值都在顶部。
哪一边的顶部的元素更小，那么它就是合并列表里的第一个元素。
删除这个更小的值之后，我们可以再次比较两个扑克牌堆的顶部的元素，这时，更小的顶部扑克牌将会是列表中的下一个元素。
我们一直持续这个过程，把两个顶部元素里较小的那一个放入到最终的大列表里，直至其中一个堆被用完了为止。
这个时候，我们用剩余堆里的扑克牌来完成最终的结果列表。

下面是一个归并过程的Python实现。
在这段代码里，`lst1`和`lst2`是两个小列表，`lst3`是放置结果的大列表。
为了使归并过程能够正常地工作，`lst3`的长度必须等于`lst1`和`lst2`的长度之和。
你应该可以通过研究代码里附带的注释来理解这段代码：

```Python
# mergeSort.py
def merge(lst1, lst2, lst3):    # merge sorted lists lst1 and lst2 into lst3

    i1, i2, i3 = 0, 0, 0        # track current position in each list
    n1, n2 = len(lst1), len(lst2)
        while i1 < n1 and i2 < n2: # while both lst1 and lst2 have more items
        if lst1[i1] < lst2[i2]: # top of lst1 is smaller
            lst3[i3] = lst1[i1] # copy it into current spot in lst3
            i1 = i1 + 1
        else:                   # top of lst2 is smaller
            lst3[i3] = lst2[i2] # copy it into current spot in lst3
            i2 = i2 + 1
            i3 = i3 + 1         # item added to lst3, update position

    while i1 < n1:      # Copy remaining items (if any) from lst1
        lst3[i3] = lst1[i1]
        i1 = i1 + 1
        i3 = i3 + 1

    while i2 < n2:      # Copy remaining items (if any) from lst2
        lst3[i3] = lst2[i2]
        i2 = i2 + 1
        i3 = i3 + 1
```

很好，现在我们既可以把列表切成两个小列表。然后，如果这两个列表已经有序了，我们也知道了应该如何把它们合并回一个列表。
那么，我们应该怎么对小列表进行排序呢？
嗯，让我们考虑一下。
我们正在尝试对列表进行排序，我们的算法要求我们对两个小列表进行排序。
这听起来，就像是一个很好的能够使用递归来完成的问题。
也许我们可以就使用`mergeSort`（归并排序）本身，就能够对两个列表都进行排序。
让我们回到我们的递归指南来开发一个合适的递归算法。

为了让递归能够正确工作，我们需要找到至少一个不需要递归调用的基本情况。
而且，我们还必须要确保递归调用总是在更小版本的原始问题上进行。
我们的`mergeSort`里的递归，将会始终出现在大约是原始列表的一半的列表上，因此后面这个属性就自动的满足了。
最终，我们的列表将会非常小——只包含一个元素。
更好的是，只有一个元素的列表是已经有序了的！
这样，我们就有了一个基本情况：
当列表的长度小于2的时候，我们什么都不需要去做，保持列表不变就行了。

根据我们的分析，我们可以这样修改`mergeSort`算法，来让它能够正确的递归。

```Python
if len(nums) > 1:
    split nums into two halves
    mergeSort the first half
    mergeSort the second half
    merge the two sorted halves back into nums
```

同样的，我们可以把这个算法直接转换为Python代码。

```Python
# mergeSort.py
def mergeSort(nums):
    # Put items of nums in ascending order
    n = len(nums)
    # Do nothing if nums contains 0 or 1 items
    if n > 1:
        # split into two sublists
        m = n // 2
        nums1, nums2 = nums[:m], nums[m:]
        # recursively sort each piece
        mergeSort(nums1)
        mergeSort(nums2)
        # merge the sorted pieces back into original list
        merge(nums1, nums2, nums)
```

你可以尝试使用一个小列表（比如说，有八个元素的列表）来跟踪这个算法，这样就可以向自己证明这个算法是有效的。
但是，一般来说，对递归算法进行追踪可能会非常的无聊，而且往往不是很有趣。

递归和数学归纳法是密切相关的，因此，需要不断的练习递归，才能让你很熟练地使用它。
只要你遵循了规则，并且确保每个递归调用链最终都会达到基本情况，你的算法*就能够*正常工作。
你不用太在意里面的具体细节，而只需要相信这个算法就行了。
让Python为你超心那些繁琐的细节吧！

### 分析归并排序

了解归并排序算法的一个好方法是：
用一个小列表来运行这段代码，并且输出一些中间结果。
这样你就可以看到代码是怎样运行的了。
图6.3显示了调用`mergeSort`来处理有七个元素的列表的过程。
递归调用将会不断的把列表分成两半，直到每个子列表都只包含一个元素为止。
就像上面提到过的，只包含一个元素的列表是有序的。
当递归调用了返回之后，就会去调用`merge`函数来把两个子列表合并在一起。
当所有递归调用都返回之后，我们就有了一个有序的包含七个元素的列表。

图6.3：归并排序的图形表示

`merge`函数的运行时间是$Θ(n)$，其中$n$是`lst3`的长度。
函数里的这三个循环的目的是：
把每个元素从大小为$n // 2$的两个子列表移动到大小为$n$的列表中的正确位置。
每次查看最多两个（每个子列表中有一个）元素来判断需要将哪个元素放入新列表中。
要计算`mergeSort`函数完成的工作量，我们就需要知道要达到基本情况所需要的步骤数。
我们之前已经在使用二分搜索算法的时候，看到了这种算法模式。
由于我们每次都会把列表分成两半，因此有$\log_2 n$步就可以达到基本情况了。
在每一层里，完成的所有工作的总和是$Θ(n)$，其中$n$是原始列表的长度。
在第一次拆分之后，我们合并了两个长度为$n / 2$的列表。
在第二次拆分之后，我们需要对两个长度为$n / 4$的子列表进行合并。
你可以通过查看那个图来验证这一点：
对于每一层，最多必须复制$n$个元素。
因此，已知我们有$\log_2 n$个层级，每个级别需要$Θ(n)$工作，那么整个算法的运行时间就应该是$Θ(n \lg n)$。
因此，这是一种比选择排序更高效的算法；所以，归并排序是一种非常好的算法。
实际上，对于没有依赖于元素相互进行比较的算法，是可以证明一定能够在小于$Θ(n \lg n)$的时间上对列表进行排序的。
然而，这并不代表着，归并排序是最好的排序算法。

归并排序的一个缺点是它需要的内存量。
如果仔细检查我们的Python实现，你可能会发现一些不太好的地方。
比如我们不断的去创建单独的子列表，而不是仅仅跟踪两个子列表的索引，而且，创建这些子列表需要$Θ(n)$工作量和同样大小的内存。
归并排序算法必须要把列表/数组分成子列表，这些列表/数组还会在合并步骤中被使用到。
而且，合并部分的代码还不能够交换元素。
因此，它必须有一个单独的列表/数组来放置这些元素，而不是使用子列表的内存。
不论我们是通过跟踪列表的起始和结束索引来拆分列表，然后使用单独的列表进行合并步骤；
或者说，我们创建单独的子列表来拆分原始列表，然后在合并步骤中使用原始列表来进行合并。
这些都不重要，因为不论在任何一种情况下，归并排序需要的内存都会是原始列表/数组的两倍；
同时，它还需要在算法运行期间的某个时刻进行$Θ(n)$的额外工作。
但是，这并不会改变我们的分析，因为总共的执行步骤还是$Θ(\lg n)$次。
然而，还有其他的递归算法可以在$Θ(n \lg n)$的时间内进行排序，并且它们还可以就地进行排序。
不止这样，由于它们不需要额外的复制步骤，所以$θ$表示法会隐藏的常量就会更小。
而且，这个算法通常来说会比归并排序更快且占用更少的内存。
一种具有这样特性的算法被称为`quicksort`（快速排序），我们将会在第15.2.2小节里讨论它。

## 一个“难”题：汉诺塔

通过使用我们的分而治之的方法，我们能够为搜索，排序以及取幂这样的问题设计出有效的算法。
分而治之以及递归是算法设计里的非常强大的技术。
但是，并不是所有问题都有很高效的解决方案。
一个可以被递归非常优雅地解决的应用问题是，通常被称为：
汉诺塔（或河内塔，梵天寺之塔）的数学难题。
这个难题通常被认为是法国数学家Édouard Lucas（爱德华·卢卡斯)发明的，他在1883年发表了一篇关于这个问题的文章。
这个问题是从下面这个传说中产生的：

传说，在世界偏远地区的某个地方，有一个非常虔诚的遵守宗教秩序的修道院。
在这个修道院里，僧侣们被赋予了一个神圣的任务：为宇宙计时。
一开始的时候，僧侣有一个上面有三个垂直银棒的桌子。
其中一个银棒上串着64个同心的金盘。
每个金盘都具有不同的半径，并且它们以漂亮的金字塔形状堆叠在一起。
僧侣们被告知，需要把金盘从第一个银棒移动到第三个银棒。
当僧侣完成这个任务的时候，所有的世间万物都会分崩离析，世界就会灭亡。

当然，如果问题就是这样的话，那么宇宙很久以前就已经结束了。
为了维持神圣的秩序，僧侣必须遵守这样一些规则。

1. 一次只能移动一个金盘。
2. 金盘不能被“放在一边”。
它只能堆叠在三个银棒中的一个上。
3. 大金盘永远不能放在小金盘之上。

基于这个难题的各个版本一度非常流行，在今天，你仍然可以在玩具或者拼图商店里找到以这个主题而产生的变体游戏。
图6.4描述了一个包含8个金盘的小版本。
游戏的目标是使用中心银棒作为临时存放点，来将整个塔从第一个银棒移动到第三个银棒上。
当然，你必须遵循上面给出的三个神圣规则。

图6.4：具有八个金盘的汉诺塔难题

我们想为这个难题开发一个算法来解决它。
你可以把我们的算法视为僧侣需要执行的一组操作，或者是用来生成一组指令的程序。
例如，假设我们标记三个银棒为A，B和C，那么这些指令可能会像这样来开始：

```
Move disk from A to C.
Move disk from A to B.
Move disk from C to B.
...
```

对于大多数人来说，这都是一个非常难以解决的难题。
当然，因为大多数人都没有接受过算法设计方面的培训，所以这并不奇怪。
但是，*一旦*你了解了递归，找到解决方案的过程实际上非常简单。

让我们首先考虑一些非常简单的案例。
假设我们有一个只有一个金盘的难题版本。
移动只有一个金盘所构成的塔就很简单了，我们只需要从银棒A中移除它，然后把它放在银棒C上，问题就解决了。
很好，那么接下来，如果有两个金盘该怎么办？
在这个情况下，我们需要将两个金盘中较大的那个金盘先放到银棒C上，较小的那一个在之后，放在它的上面。
解决方案是，先把小的那个金盘移开就行了，我们可以通过把它动到银棒B上来实现。
现在银棒A上的大金盘就没有阻挡了，我们可以把它移动到银棒C上，然后再把小金盘从银棒B移到银棒C就行了。

接下来，让我们考虑一下有三个金盘的塔的情况。
为了将最大的金盘移动到银棒C上，我们首先必须将两个较小的金盘移开。
而这两个较小的金盘就形成了一个2号塔。
使用上面描述过的过程，我们可以将这个有两个金盘的塔移动到银棒B上。
这样，我们就能够移动最大的金盘了，所以，可以把最大的金盘移动到银棒C上。
然后，我们只需要再把两个金盘的塔从银棒B移到银棒C上就行了。
解决三个金盘的情况可以被总结为三个步骤：

1. 将包含两个金盘的塔从A移到B。

2. 将一个金盘从A移动到C。

3. 将包含两个金盘的塔从B移到C。

第一步和第三步涉及到了应该如何移动包含两个金盘的塔。
好在我们已经找到了应该如何做到这一点。
就像在解决两个金盘的难题的时候一样，我们使用银棒C作为临时安置的位置将塔从银棒A移动到银棒B，然后使用银棒A作为临时位置将塔从银棒B到银棒C移动。

于是，我们刚刚开发出了一个简单的递归算法的概述，这个算法是一个可以被用来将任意大小的塔从一个柱子移动到另一个柱子的通用过程。

```
Algorithm: move n-disk tower from source to destination via resting place

move n-1 disk tower from source to resting place
move 1 disk tower from source to destination
move n-1 disk tower from resting place to destination
```

所以，这个递归过程的基本情况是什么？
可以看到，移动$n$个金盘会导致两次$n - 1$个金盘的递归移动。
由于我们每次都对$n$减`1`，因此塔的最终尺寸就是$1$。
只需要移动一个金盘就可直接移动包含一个元素的塔。
这个情况下，我们不需要任何的递归调用来移走它上面的金盘。

修复我们的通用算法，让它包含一个基本情况。
于是，我们就可以得到一个可以工作的`moveTower`算法。
那么，我们使用Python来编写它。
我们的`moveTower`函数将需要一个用来表示塔的大小的参数：`n`；
初始的银棒：`source`；
需要到的银棒：`dest`；
以及临时存放的银棒：`temp`。
我们可以使用数字（`int`）来代表`n`，使用字符串`"A"`，`"B"`和`"C"`来表示银棒。
这就是`moveTower`的代码：

```Python
# hanoi.py
def moveTower(n, source, dest, temp):
    if n == 1:
        print "Move disk from", source, "to", dest + "."
    else:
        moveTower(n - 1, source, temp, dest)
        moveTower(1, source, dest, temp)
        moveTower(n - 1, temp, dest, source)
```

看看这段代码有多简单！
有时候，使用递归可以把一些无比困难的问题变得几乎轻而易举。

为了让程序开始，我们只需要为这四个参数提供一个合适的值就行了。
让我们编写一个能够将大小为n的塔从银棒A移动到银棒C的所有指令都打印出来的小方法：

```Python
# hanoi.py
def hanoi(n):
    moveTower(n, "A", "C", "B")
```

现在我们可以来尝试一下了。
下面的输出是包含三个和包含四个金盘的难题的解决方案。
你可能希望通过这些解决方案来确认自己的算法是否有效。

```
>>> hanoi(3)
Move disk from A to C.
Move disk from A to B.
Move disk from C to B.
Move disk from A to C.
Move disk from B to A.
Move disk from B to C.
Move disk from A to C.

>>> hanoi(4)
Move disk from A to B.
Move disk from A to C.
Move disk from B to C.
Move disk from A to B.
Move disk from C to A.
Move disk from C to B.
Move disk from A to B.
Move disk from A to C.
Move disk from B to C.
Move disk from B to A.
Move disk from C to A.
Move disk from B to C.
Move disk from A to B.
Move disk from A to C.
Move disk from B to C.
```

所以，我们对汉诺塔的解决方案是一个“举重若轻”的算法，它只需要九行代码。
那么，为什么我们要在标题里，把这个问题定义为“一个难题”呢？
要回答这个问题，我们必须要先去看看这个解决方案的效率。
对于我们的算法来说，问题的难度取决于塔里的金盘数量。
因此，我们首先需要回答的问题是：
*移动一个大小为$n$的塔需要多少步骤*？

只要看一下我们算法的结构，你就可以看出移动一个大小为$n$的塔需要我们移动一个大小为$n - 1$的塔两次：
一次是将它从最大的金盘上移开，第二次是把它放回到最大的金盘的上面。
如果我们再添加另外一个金盘到塔里的话，我们解决它所需要的步骤数基本上将会增加一倍。
如果你尝试过了不断增加难题大小的程序的话，这种关系就会更加清晰。

| 金盘数量 | 解决方案的步骤 |
| :--: | :--: |
| 1 | 1 |
| 2 | 3 |
| 3 | 7 |
| 4 | 15 |
| 5 | 31 |

所以，一般来讲，解决大小为$n$的难题需要$2^n - 1$步。

这很明显是一个$Θ(2^n)$算法，这就意味着它需要*指数时间*（*exponential time*）来完成任务。
这是因为问题大小的度量$n$出现在了这个公式的指数里。
指数算法增长得非常迅速，实际生活中，即使在最快的计算机上，也只有相对较小的问题尺寸才能够被解决。
为了说明这一点，如果我们的僧侣们真的有一个包含64个金盘的塔，在不犯错的情况下，每一天的24小时里的每一秒钟都去移动一个金盘的话。
他们仍然需要超过5800*亿*年来完成他们的任务。
考虑到宇宙现在大约只有150亿年的历史，我们根本不用担心变成灰尘了。

尽管汉诺塔的算法很容易被写出来，但它属于一类被称为*难解型*（*intractable*）问题。
对于这类问题，除了最简单的情况下，通常在实践中会需要过于多的计算能力（不论是时间还是内存）。
从这个意义上来说，我们的玩具店确实给了我们一个难题。

## 章节总结

这一章向你介绍了算法设计中的一些重要概念。
以下是关于这些的重要思想：

* 二分搜索是算法开发里的分而治之方法的一个例子。
分而治之通常会得到高效的解决方案。

* 如果一个定义或函数引用了它自身，则它是递归的。
要建立良好的递归方法，递归的定义必须要能够满足两个属性：

    1. 必须有一个或多个不需要递归的基本情况。

    2. 递归所有的链，最终都必须达到基本情况。

    保证这些条件的一个简单方法是：
    始终在更小版本的问题上进行递归调用。
    基本情况是可以被直接解决的简单版本。

* 序列可以被认为是由第一个元素以及它后面跟着的一个序列组合起来的递归结构。
可以按照这种方法来编写递归函数。

* 归并排序是一种递归的分而治之算法，它可以在$n \lg n$的时间内对集合进行排序。

* 递归一般来说会比迭代更通用。
选择递归或者循环，涉及到了对代码效率和代码简洁的考虑。

* 理论上可以解决但实际上不能够被解决的问题被称为“难解型”问题。
著名的汉诺塔的解决方案可以被写为一个简单的递归算法，但这个算法仍然是“难解型”的。

## 练习

**判断题**

1. 任何引用自身的定义都是循环引用，因此是没有用处的。

2. 递归是一种比循环更通用的迭代形式。

3. 所有正确的递归函数必须只有一个基本情况。

4. Python中的无限递归会让计算机死机。

5. 序列可以被视为一个递归的数据集合。

6. 长度为$n$的字符串有$n!$个字谜。

7. 归并排序是一个$Θ(n^2)$算法的例子。

8. 算法的循环版本实现通常比递归版本快一点。

9. 递归算法在实践中往往很慢。

10. 汉诺塔是一个“难解型”问题的例子。

**选择题**

1. 递归函数的非递归部分被称为

    a) 底部情况。

    b) 终止情况。

    c) 结束情况。

    d) 基本情况。

2. 一种将问题分解为较小版本的原始问题的算法设计技术叫做

    a) 自上而下设计。

    b) 测试驱动开发。

    c) 分而治之。

    d) 搜索与销毁。

3. 以下哪一项是用于反转字符串的递归表达式的正确编码？

    a) `reverse(s[1:]) + s[0]`

    b) `s[0] + reverse(s[1:])`

    c) `s[-1] + reverse(s[:-1])`

    d) a和c都正确

4. 有四个字母的单词有多少个字谜？

    a) 4

    b) 8

    c) 16

    d) 24

5. 本章里的`loopPower`方法的时间分析是什么？

    a) $Θ(\lg n)$

    b) $Θ(n \lg n)$

    c) $Θ(n)$

    d) $Θ(2^n)$

6. 本章里的`recPower`方法的时间分析是什么？

    a) $Θ(\lg n)$

    b) $Θ(n \lg n)$

    c) $Θ(n)$

    d) $Θ(2^n)$

7. 归并排序的时间分析是什么？

    a) $Θ(\lg n)$

    b) $Θ(n \lg n)$

    c) $Θ(n)$

    d) $Θ(2^n)$

8. 汉诺塔算法的时间分析是什么？

    a) $Θ(\lg n)$

    b) $Θ(n \lg n)$

    c) $Θ(n)$

    d) $Θ(2^n)$

9. 无限递归将导致

    a) 一个不再响应的程序。

    b) 一台损坏了的计算机。

    c) 重启。

    d) 运行时异常。

10. 递归的斐波那契函数的效率非常低下，是因为

    a) 与迭代相比，递归本质上是低效的。

    b) 计算斐波那契数是一个难解型问题。

    c) 它执行了许多的重复计算。

    d) 以上所有内容

**简答题**

1. 一个正确的递归函数必须总是有某种决策结构吗？
请解释你的答案。

2. 用你自己的话，来解释一个正确的递归定义所必须要遵守的两个规则。

3. `anagram("foo")`返回的列表是什么？

4. 跟踪`recPower(3, 6)`的执行过程，得到它总共执行了多少次乘法操作。

5. 为`loopPower`和`recPower`编写先验条件和后置条件。

**编程练习**

1. 修改本章里给出的递归斐波那契程序，从而让它能够打印出相应的跟踪信息。
具体来说，就是让函数在调用时和返回时各打印出一条消息。
比如，输出可以包含下面这些内容：

    ```Python
    Computing fib(4)
    ...
    Leaving fib(4) returning 3
    ```

    使用修改之后的`fib`函数来计算`fib(10)`，并查看在这个过程中计算`fib(3)`的次数。

2. 这个练习是“检测”递归的斐波纳契程序的另一种变体，从而能够让你更好地理解它的行为。
编写这样一个程序，它可以统计出在计算`fib(n)`的时候，调用`fib`函数的次数，其中`n`是用户输入。

    提示：
    要解决这个问题，你需要一个变量来进行累加，而且这个值要能够在`fib`的不同调用之间进行“保持”。
    你可以通过实现一个计数的对象的实例变量来完成这项操作。
    创建一个包含下列方法的`FibCounter`类：

    `__init__(self)`：创建一个新的`FibCounter`，将它的计数实例变量设置为`0`。

    `getCount(self)`：返回计数的值。

    `fib(self，n)`：计算第$n$个斐波那契数的递归函数。
    它的每次调用，都会递增计数实例变量。

    `resetCount(self)`：将计数重新设置为`0`。

3. 编写一个递归的斐波那契函数，这个函数应该和计算第$n$个斐波那契数的循环版本具有相同的算法实现。
提示：在把`for`循环改成递归的时候，你需要把循环期间会被更改值的所有变量都作为参数传递给递归函数。

4. 从前面这个问题，我们知道了递归版本也可以像循环版本一样高效地计算第$n$个斐波那契数。
如果再凭借一点点聪明才智的话，我们甚至可以做得更好。
找到第$n$个斐波纳契数的另一种方法是通过矩阵运算。
为了计算出斐波那契序列，我们必须要去跟踪计算得到的最后两个值（`curr`和`prev`）。
这两个值的下一个“状态”其实是可以通过简单的矩阵乘法来计算出的：

    $$
    \begin{bmatrix}
        1 & 1  \\
        1 & 0
    \end{bmatrix}
    \begin{bmatrix}
        curr  \\
        prev
    \end{bmatrix}
    =
    \begin{bmatrix}
        curr + prev  \\
        curr
    \end{bmatrix}
    $$


    因此，我们也可以通过利用矩阵求幂来构建整个迭代序列。
    通常，斐波那契程序中的循环可以用这个计算来替换掉：

    $$
    \begin{bmatrix}
        1 & 1  \\
        1 & 0
    \end{bmatrix}
    ^{n-2}
    \begin{bmatrix}
        1  \\
        1
    \end{bmatrix}
    =
    \begin{bmatrix}
        fib(n)  \\
        fib(n - 1)
    \end{bmatrix}
    $$

    创建一个矩阵数据类型，通过运算符重载，让这个矩阵类型可以像数字一样进行乘法。
    然后在计算第$n$个斐波那契数的程序里使用本章介绍的快速求幂算法。
    代码能成功执行之后，对这个程序进行时间分析。

5. 编写一个用来检测字符串是否是回文的递归函数。
基本思想是：检查字符串的第一个和最后一个字母是否是相同的字母；
如果它们相同，那么如果这两个字母之间的所有内容也都是回文的话，就代表着整个字符串是回文的。
有几个特殊情况需要特别注意。
如果字符串的第一个或者最后一个字符不是字母，你可以检查移除了这个字符之后的字符串的其余部分是否是回文。
除此之外，当你比较字母的时候，请确保以不区分大小写的方式执行此操作。

    在程序中拿到用户输入的短语，然后使用你的函数来判断它是否是回文。
    这里有一个经典的回文测试：`"A man, a plan, a canal, Panama!"`。

6. 编写并测试这样一个递归函数`max`，它可以被用来查找列表中的最大数字。
最大值是第一个元素和所有其他元素中的最大元素的更大的那个元素。

7. 计算机科学家们和数学家们经常使用除了基数为10之外的编号系统。
编写一个允许用户输入数字和基数的程序，然后按照新基数来打印出这个数字。
使用递归函数`printDigits(num, base)`来打印这个数字。

    提示：先考虑基数为`10`的情况。
    要获得基数为10的情况下最右边的数字，只需在除以10之后查看余数就行了。
    例如，`153 % 10`的结果是`3`。
    要获得剩下的其他数字，可以继续在，这只是153/10得到的15上重复这个过程。
    这个过程适用于任何基数的情况。
    唯一的问题是我们会得到一个以相反的顺序（从右到左）得到这个数字。

    编写一个递归函数，首先打印出`num / base`的数字，然后再打印出`num * base`，也就是最后一个数字。
    你应该在连续的数字之间放置一个空格，这是因为大于10的基数将会打印出多字符数字。
    比如说，`printDigits(245, 16)`打印出来的应该是`15 5`。

8. 编写一个打印出英文数字的递归函数。
比如说，如果数字为`153`，则输出应为“One Five Three”（一五三）。
你可以通过参考上一个问题里的提示，来获得有关如何执行这项操作的帮助。

9. 在数学中，$C_n^k$表示可以从$n$个不同选择中选择$k$件事物的不同方式的数量。
例如，如果你在六种甜点中进行选择，你只被允许选择其中的两种，那么可以选择的不同的组合数量为$C_6^2$。
下面这是用来计算这个值的公式：

    $$
    C_n^k = \frac{n!}{k!(n-k)!}
    $$

    这个值还可以被一种有趣的递归来表示：

    $$
    C_n^k = C_{n-1}^{k-1} + C_{n-1}^k
    $$

    分别编写迭代函数和递归函数来计算组合的数量，并且比较这两种解决方案的效率。
    提示：当$k = 1$的时候，$C_n^k = n$；当$n < k$的时候，$C_n^k = 0$。

10. 可以通过递归来描述一些有趣的几何曲线。
其中一个著名的例子是科赫（Koch）曲线。
它是一条在有限空间内可以无限长的曲线。
它还可以被用来生成漂亮的图片。

    科赫曲线用“等级”或“度”来描述。
    `0`度的科赫曲线是一条直线段。
    通过在线段的中间放置一个“凸起”来形成一度曲线（参见图6.5）。
    原始线段被分为四个部分，每个线段是原始线段的三分之一长。
    凸起升高的角度是60度，因此它形成了等边三角形的两条边。
    要获得二度曲线，请在第一度曲线的每个线段中再放置一个凸点就行了。
    之后的曲线也都是通过在前一个曲线的每个部分上放置一个凸起来构造的。

    图6.5：0到2度的科赫曲线

    你可以通过“科赫化”多边形的边来绘制有趣的图片。
    图6.6显示了将四度曲线应用于等边三角形边的结果。
    这个图形通常被称为“科赫雪花”。
    你需要编写一个程序来绘制一片雪花。

    图6.6：科赫雪花

    提示：把绘制科赫曲线，考虑成你好像正在给乌龟指示一样。
    乌龟总是知道它当前所处的位置以及它面向的方向。
    要绘制给定长度和度数的科赫曲线，你可以用下面这个算法：

    ```
    Algorithm Koch(Turtle, length, degree):
        if degree == 0:
            Tell the turtle to draw length steps in the current direction
        else:
            length1 = length/3
            degree1 = degree-1
            Koch(Turtle, length1, degree1)
            Tell the turtle to turn left 60 degrees
            Koch(Turtle, length1, degree1)
            Tell the turtle to turn right 120 degrees
            Koch(Turtle, length1, degree1)
            Tell the turtle to turn left 60 degrees
            Koch(Turtle, length1, degree1)
    ```

    使用合适的图形包来实现这个算法。
    你可以使用Python标准库中的乌龟（`Turtle`）模块，或者在另一个图形包中实现你自己的乌龟。
    编写一个程序，允许用户输入所需的雪花的度数，然后去绘制它。

11. 另一个有趣的递归曲线（见前一个问题）是莱维C形曲线。
除了不是像科赫曲线那样将一个线段分成四段，并且每段长度为$length/3$；
和科赫曲线类似的，莱维C形曲线用两段长度为$length/√2$去替换原始线段里的每段线段，并且形成一个$90$度的拐弯。
图6.7显示了12度的莱维C形曲线。

    图6.7：12度的莱维C形曲线

    使用类似于上一个练习的方法，编写一个绘制莱维C形曲线的程序。
    提示：你的乌龟将执行下面这个操作：

    ```
    turn left 45 degrees
    draw a c-curve of size length/sqrt(2)
    turn right 90 degrees
    draw a c-curve of size length/sqrt(2)
    turn left 45 degrees
    ```

12. 编写一个用来解决单词混乱问题的程序。
首先，你需要一个包含英文单词的大文件。
如果你用的是Unix或Linux系统，那么你可以在系统目录中找到拼写字典（例如，在`/usr/dict`或`/usr/share/dict`）。
不然的话，在互联网上简单搜索一下，应该也会发现一些有用的东西。
这个程序通过让用户输入一个被打散的单词来进行。
它会生成这个单词的所有字谜，然后去在字典中查看哪些（如果有的话）字谜是存在的。
出现在字典中的字谜将会被打印出来，作为这个问题的解决方案。

13. 编写一个迷宫的解决方案。
找到一个路径来通过迷宫的这个问题可以被转换为一个递归搜索过程。
假设使用`(x，y)`坐标来代表二维迷宫中的位置。
下面这是一个查找和标记从任意起点到出口的路径的算法。
如果它能够找到一条通往出口的路径，则返回`True`，否则返回`False`。

    ```
    algorithm pathToExit((x,y)):

        if (x,y) is an exit:
            return True
        if (x,y) is not an open unvisited cell:
            return False

        Mark (x,y) as visited

        # Try 4 possible directions from (x,y)
        if pathToExit((x+1,y)):
            return True
        if pathToExit((x,y+1)):
            return True
        if pathToExit((x-1,y)):
            return True
        if pathToExit((x,y-1)):
            return True

        # Cannot reach an exit from this cell
        unMark (x,y) # it’s not on a path to the exit
        return False
    ```

    在这里，你将需要为迷宫设计一个合适的存储方式。
    一种简单的方法是使用ASCII文本来表示矩形迷宫。
    例如，你可以使用“`*`”来表示墙以及用“`.`”来表示一个开放区域。
    字母`S`和`E`可以被用来表示开始和出口。
    这里有一个简单的例子：

    ```
    S **......
    ..*...***.
    *.***.*.*.
    ........*.
    .********.
    .***....*.
    .**..**...
    .**...****
    ..**.**...
    *..*....*E
    ```

    即使你想构建的是一个非常漂亮的图形迷宫程序，这样一个简单的基于文本的存储方式对于定制迷宫来说非常的方便，因为这样的迷宫可以使用基本的文本编辑器就能够创建了。

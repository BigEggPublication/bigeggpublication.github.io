# 抽象与分析

目标

* 了解“小作坊”式的编程和“大型”编程的区别。

* 了解为什么要有先验条件与后置条件，以及它们的用法。

* 掌握设计和分解问题的能力。

* 了解算法效率的重要性，并且从一个简单算法中学习如何分析算法的运行时间。

## 引言

不论你信不信，计算机编程的第一门课里就已经涵盖了解决任何可以用计算机处理的问题所需要的所有工具了。
著名的计算机科学家——艾伦·图灵（Alan Mathison Turing）曾经提出过一个现在已被人们普遍接受的猜想：
任何可以用计算机解决的问题都只需要用到所有计算机编程语言都包含的基本语句。
这些基本语句也就是：
条件语句（例如`if`）、循环语句（例如`for`和`while`）以及存储和检索数据的能力。
可能你已经知道了这些，你也还会想知道有什么其他的可以学习。
这是个好问题，让我在下面的内容里去回答它。

### 大型编程

如果将计算机编程看成与造房子类似的过程，那么掌握了编程知识就相当于是知道了如何使用锤子、螺丝刀、锯子和钻头等这些工具。
这些工具虽然可以说是建造所有的房屋都需要用到的基本工具，但会用它们并不意味着你可以精确高效地建造一个适合居住的房屋，更不用说建造一个满足现代建筑规范且有一定规模的房屋了。
这不是说你不能用这些工具做一些有用的事情，如做一个长凳或鸟笼，只是你还没有准备好应对大型项目所带来的挑战。

编程就像建造房子一样，在处理大型项目的时候是需要更多额外的知识、技术和技能的。
这本书能让你学习到这些额外知识和技能，并且打下一个坚实基础，让你在未来的学习和整个职业生涯中可以不断提高。
在你学习本书的过程中，你将会完成从“小作坊”编程慢慢转型到“大型”编程的过渡。

不同的软件项目在很多方面都有各自的特点。
就规模而言，它们可以从非常小（例如将温度从摄氏度转换到华氏度）到非常大（例如计算机操作系统）。
同样，软件项目在开发系统的关键任务方面也存在很大差异。
一个日记网站并不需要设计得像网上银行那样遵守严格规范，也不用像控制生命维持医疗设备的程序那样精益求精。

没有任何一个单独的属性可以决定项目的“大小”或“难度”。
但一般而言，有许多特征可以将现实世界里的编程和你迄今为止看到过的简单的课堂练习题区分开来。
这些特征如下。

* **程序大小**
到目前为止，你可能写过包含几百（或者几千）行代码的程序。
但是，在实际生活中的应用程序拥有数十万或数百万行代码并不罕见。
例如，Linux操作系统内核包含大约600万行代码。

* **单个程序员 vs. 开发团队**
到目前为止，你编写的大多数程序可能都是你自己的项目。
但是，现实生活中的大多数软件都是由若干个开发团队共同完成的。
没有哪个程序员能够完全了解一个系统的各个方面。

* **从头做起 vs. 已有代码**
可能你编写大部分程序都是从头开始的。
而在实际项目中，程序设计经常会建立在已有程序之上。
老系统可以和新软件一起进行扩展、被引用、被取代以及使用。

* **系统生命周期**
当刚开始学习编程的时候，你可能会编写很多仅仅被用在作业里的程序。
一旦这些程序被打了分，你可能永远都不会再看它一眼了。
大多数真正的软件项目都有很长的生命周期。
在它们被使用的整个时间段中，它们将会持续获得优化、改进以及更新。

* **环境的复杂性**
一个小项目，只用单一的编程语言和一小套标准库就能完成编写；
而大型项目，则更倾向于使用多种不同的编程语言和大量支持开发的工具和软件库来协同开发。

### 前方的道路

“大型”编程的基本问题其实就是管理相关事务的复杂性。
遗憾的是，人们更擅长同时只跟踪少量的几件事情。
因此，为了处理复杂的软件系统，我们需要一个可以在任何给定的时间节点上都能限制需要考虑的细节数量的方法。
例如忽略一些细节的同时，更专注于与手头问题相关的细节。
这一过程我们称之为**抽象**。
高效的软件开发，就是构建合适的抽象。
因此，本书中经常会用到抽象的概念。

处理复杂性的另一个重要技术是会重用之前已有的解决方案。
作为程序员，你将需要学习如何通过各种**应用程序编程接口**（Application Programming Interface，API），来调用你将要使用的工具或库。
API是代码库提供的类和方法，以及它们的使用说明（也就是参数和返回类型是什么，以及它们分别代表什么含义）的集合。
你可能已经学习过一些简单的API，如Python数学模块（**`math`**）中提供的函数以及各种内置数据结构［如列表（**`list`**）和字典（**`dictionary`**）］的方法。
还有一个常见的API的示例就是图形用户界面（Graphical User Interface，GUI）工具包。

大多数编程语言都提供可用于完成许多常见任务的API。
当然API也会因语言和操作系统的不同而产生差异。
因此这本书不能够涵盖你将会在职业生涯里遇到和使用的所有API，与之相比只是一小部分。
但是，通过学习一些API，抑或更重要的是，通过学习开发自己的API，你能够获得使你将来能轻松掌握新的API的实用技能。

另一个和重用API 已有的代码同样重要的能力是：能够利用现有的良好设计原则的*知识*。
多年来，计算机科学家们已经开发出了用于解决常见问题（例如搜索和排序）的各种算法，以及构建出了在大多数程序中都可以用作基本模块的各类数据集合。
在这本书里，你将会学习这些算法和数据结构，以便你之后可以编写更大、更复杂、精心设计和因为使用了这些被广泛理解的模块而易于维护的程序。
同时，学习这些现有的算法和数据结构还将帮助你了解如何为将来可能会面临的特殊问题创建属于自己的新算法和数据结构。

计算机科学家还发明了用来分析和分类各种算法和数据结构的效率的技巧。
利用这些技巧，你就可以预测一个程序是否能够在合理的时间和有限的内存等条件下成功解决问题。
当然，你还需要学习算法分析的技巧，从而能够分析你新发明的算法的效率。

不论出于什么原因，拥有多种编程语言的经验是非常重要的。
因此，本书将会介绍两种不同编程语言的抽象和数据结构。
了解不同编程语言之间的差异，可以让你了解到开发人员可以使用不同的工具来应对不同的任务。
拥有大量的工具，能够让你更轻松地解决各种各样的问题。
然而，更重要的一个优点是：
你还能够看到抽象、重用和分析这些基本原则是如何应用于两种不同的编程语言之中的。
只有了解了这些不同的实现，你才能真正理解什么是基本原则，而不仅仅是知道了特定编程语言的细节。
无论你将来使用何种语言或环境，这些基本原则都将非常有用。

说到编程语言，在本书即将出版的时候，Python 发布了新的版本（Python 3.0）。
新版本中包含了大量的重新设计，并且不会向下兼容2.x版本的Python编写的程序。
虽然，本书中的代码是用Python 2.x风格编写的，但是我们将尽可能地尝试使用与Python 3.0兼容的规范和功能。
同时，将代码转换为3.0版本也非常简单，要使代码能够在Python 3.0中运行，你需要记住以下不同。

* `print`成为函数。
你必须要在需要输出的表达式序列左右加上括号。

* `input`函数的使用方法将会类似于之前的`raw_input`。
如果你需要检查用户输入，就必须显式地调用（`eval(input("Enter a number:"))`）来获取用户输入。

* `range`函数将不再输出列表。
你仍然可以像以前那样在`for`循环中使用它（例如`for i in range(10):`)，但是你需要通过`nums = list(range(10))`这样的代码以显式的方式生成列表。

* 单斜杠运算符——`/`将始终输出浮点结果。
想要输出整数的话，你可以使用双斜杠运算——`//`（Python 2.x中也同样支持）。

本书的在线资源中，提供了所有代码的Python 2.x和Python 3.0版本。
因此，不论你用哪个版本的Python，都能够很方便地学习本书。

## 功能的抽象

为了能解决大型软件项目，必须要将其拆分成更小的部分。
其中一种可以将问题拆分成较小部分的方法是：将其分解为一组可以相互协作的功能。
这一方法被称为**功能抽象**（functional abstraction），或者叫作**过程抽象**（procedural abstraction）。

### 契约式设计

让我们通过一个简单的例子来理解编写函数其实是一个抽象的实例。
假设你要写一个需要计算某个值的平方根的程序，你知道应该怎么做吗？
你是否知道求平方根的具体算法并不重要，因为Python 数学模块（**`math`**）中提供了平方根函数。

```Python
import math
...
answer = math.sqrt(x)
```

你可以很有信心地使用`sqrt`函数来求平方根，因为你知道它会**做什么**，即使你可能并不知道它是**如何完成**计算的。
在这里，你只关注了`sqrt`函数的某些方面（**做什么**），而忽略了另一些细节（**如何完成**）。
这就是抽象。

分离一个组件的能够做什么和它会怎么去完成这一任务的关系，是一种特别强大的抽象形式。
如果我们将一个函数想象成一个服务，那么使用这个函数的程序就可以被称为服务的**客户端**（client），并且这个函数被实际执行的代码就可以被称为服务的**实现**（implement）。
在客户端工作的程序员只需要知道这个函数的功能即可，他或她并不需要知道该函数工作的任何过程细节。
因此对于客户端使用者来说，这个函数就像一个能执行所需操作的神奇的黑盒子。
类似地，这个函数的实现者也不需要关心应该如何使用该函数，他或她可以自由地专注于这个函数应该如何完成其任务的各种细节，而不用在意实际调用函数的位置和原因。

为了实现这种清晰的分离，客户端使用者和实现者必须对要完成的功能达成一致，也就是说，他们必须对客户端代码和具体实现之间的**接口**有共同的理解。
这个接口就像是一种将函数的两个不同角度的视图分开的抽象屏障。
图1.1所示为用图形化的方式呈现Python字符串分割方法（或字符串模块中的等效的分割函数）。
图里显示了这个方法/函数需要一个字符串作为必需参数，以及另一个字符串作为可选参数，最后返回一个字符串。
使用这个`split`方法/函数的客户端使用者并不需要关心它的工作方式（也就是框内的内容），只需要知道应该如何使用它。
因此，我们需要的是仔细描述函数将做什么，而不必描述函数将会如何完成它的工作。
这种描述被称为**规范**（specification）。

>     用于分割的字符串
>
>                      ===> 分割函数/方法 ===> 字符串列表
>
>     可选的分隔符字符串（默认为空格）

图1.1 `split`功能的黑箱接口示意图

很明显，描述函数的调用方式是规范的一个重要部分。
也就是说，我们需要知道函数的名称、需要什么参数以及函数返回的内容。
这些信息也可以被称为函数的**签名**（signature）。
除了签名，规范还需要精确描述函数的功能。
我们需要知道调用函数所提供的参数与结果是如何相关的。
这种关联信息，很多时候是以非正式的格式完成。
例如，假设你正在编写Python数学模块（**`math`**）中的平方根函数。
让我们来看看下面这个函数的规范。

```Python
def sqrt(x):
    """Computes the square root of x"""
```

这并不是一个很好的函数规范。
这种非正式格式描述的问题在于它们往往并不完整，且含糊不清。
要知道，一个良好的规范应当可以使客户端使用者和函数实现者（即使他们是同一个人）**仅仅**依靠函数的规范，就能够完成各自的任务。
这也是抽象过程如此有用的原因。
如果这个函数**计算**了`x`的平方根，但没有返回结果怎么办？
纯理论上来说，这也是符合规范的；
但这样的话，这个方法对客户端使用者来说没有任何用处。
同样，`sqrt(16)`可以返回`-4`吗？
如果函数的实现只适用于浮点数，但客户端使用了整数作为参数调用该函数，应该怎么办？
如果导致了程序崩溃，那是谁的错？
如客户端使用负数作为参数调用此函数会发生什么？
它会返回一个负数，还是会直接崩溃？
如果客户端使用字符串作为参数调用此函数会发生什么？
可见，这种简单、非正式格式的描述，并没有告诉我们如何理解这个函数。

这可能听起来像是挑刺。
因为通常每个人都“理解”平方根功能该做些什么。
所以，如果我们有任何疑问，都可以通过查看该函数的源代码或通过实际使用来证明我们的假设（例如尝试计算`sqrt(-1)`并查看会发生什么）。
但是，做这些事情就会打破客户端使用者和实现者之间的抽象隔离。
而强制客户端程序员去理解函数的细节实现，也就意味着他或她必须去厘清这些代码的所有细节并进行斗争，从而失去抽象的优势。
另一方面，如果客户端程序员只是依赖于代码实际执行的结果（通过尝试它），他或她就有可能做出一些实现者无法预期的假设。
例如，实现者发现了计算平方根的更好方法，因此修改了代码实现，那么客户端使用者对某些“边缘”行为的假设可能就不再正确。
但如果保持抽象隔离，客户端代码和实现代码都可以随意修改，因为抽象隔离能够确保程序将继续正常运行。
这种理想的情况被称为**实现独立性**（implementation independence）。

希望下面这个令人刻骨铭心的反例，可以让你深刻地认识到在大型编程时，组件的精确规范是多么重要。
美国航空航天局1999年的火星气候轨道飞行任务，由于假设与实现不匹配而造成了1.25亿美元的损失。
原因很简单，只是因为一个模块需要使用英制单位来获得信息，但被假设为可以用公制单位。
在大多数情况下，仔细定义的规范是绝对必要的。
因为只要规范没有被明确地说明或者被严格地遵守，意想不到的灾难就会出现。

所以很显然，我们需要一种比非正式描述更好的东西来更好地表述规范。
函数规范通常包含先验条件和后置条件。
先验条件是关于调用函数时计算状态的假设。
后置条件则是关于函数完成后的真实情况的陈述。
下面就是`sqrt`函数包含先验条件和后置条件的示例规范：

```Python
def sqrt(x):
    """Computes the square root of x.

    pre: x is an int or a float and x >= 0
    post: returns the non-negative square root of x"""
```

先验条件用来陈述实现中所做的任意假设，尤其是关于函数参数的假设。
为了完整地描述，它一般会使用这个参数的正式名称（在这个例子里是`x`）来描述参数。
后置条件就需要描述函数实现代码中使用输入参数完成了什么。
前后条件加在一起，对函数的描述就成为客户端与实现之间的一种契约。
如果客户端使用者保证在调用函数时满足先验条件，那么实现者就保证在函数结束时也将满足后置条件。
因此，这种使用先验条件和后置条件来描述系统中的模块的方式也被称为**契约式设计**。

先验条件和后置条件是程序**断言**（assertion）的一种特定的文档类型。
断言，是一段关于计算状态的声明，并且在程序中的特定点处，这个计算状态为真。
在函数执行之前，先验条件必须为真，并且后置条件也必须为真。
稍后，我们将会看到程序在其他地方非常有价值的文档化断言。

如果你读得足够仔细，你可能会觉得上面`sqrt`函数的示例中的后置条件有点不对劲，因为它描述了这个函数应该做什么。
严格来说，断言不应该说明函数的作用，而是应该去说明程序中给定的点，现在什么是真的。
因此，将后置条件表示为`post：RETVAL ==√x`可能更加正确，其中`RETVAL`用来表示函数的返回值。
尽管严格来说，这样描述不太准确，但大多数程序员都倾向于像我们这个例子中一样，提供不太正式的后置条件。
鉴于这种非正式风格更受欢迎，而且信息量也没有变少，我们在后面将继续使用这种：“返回这个、那个和其他”形式来表述后置条件。
当然，如果你坚持应该严格使用完美的断言的话，可以做一些必要的改变。

如果你读得足够仔细，你可能会觉得上面`sqrt`函数的示例中的后置条件有点不对劲，因为它描述了这个函数应该做什么。
严格来说，断言不应该说明函数的作用，而是应该说明程序中给定的点，现在什么是真的。
因此，将后置条件表示为`post：RETVAL ==√x`可能更加正确，其中`RETVAL`用来表示函数的返回值。
尽管严格来说，这样描述不太准确，但大多数程序员都倾向于像我们这个例子中一样，提供不太正式的后置条件。
鉴于这种非正式风格更受欢迎，而且信息量也没有变少，我们在后面将继续使用这种“返回这个、那个和其他”的形式来表述后置条件。
当然，如果你坚持应该严格使用完美的断言的话，可以做一些必要的改变。

现在，我们可以发现一个关于规范中先验条件和后置条件的重要观点：
规范的重点在于它提供了对函数或其他组件的简洁和精确的描述。
如果规范都模糊不清，或者比实际中实现的代码更长、更复杂的话，我们什么都得不到。
数学符号往往是简洁而精确的，所以它们通常在规范中非常有用。
实际上，一些软件工程方法采用完全正式的数学符号来描述所有系统组件，即**形式化方法**（formal method），这样可以允许用数学的方式陈述和证明程序的属性，提高了开发过程的精确性。
在最好的情况下，这样也可以证明程序的正确性，也就是程序的代码忠实地实现了它的规范。
然而，使用这种方法需要相当强大的数学功底，既然它还没有在整个行业中通用，那么我们目前将继续使用这种不太正式的规范，只在需要、合适且有用的时候使用众所周知的数学和编程符号。

另一个重要的观点就是：在代码中放置规范。
在Python里，开发人员有两种方法可以将注释放入代码中：
常规注释（用前导的`#`符号表示）和文档字符串（模块顶部、紧跟在函数名或类名之后的字符串表达式）。
文档字符串将和它们附着的各种对象一起被打包，从而方便之后在运行时随时查看。
正是由于文档字符串也被同时用于实现Python内部帮助文档，以及被PyDoc标准文档模块用来自动创建API文档，因此它可以成为一个特别好的媒介来定义规范。
一般来说，对客户端程序员有用的信息，应当包含在文档字符串中；
而仅供函数实现者使用的信息，应该使用内部注释。

### 验证先验条件

契约式设计的基本思想是：
如果在调用函数时满足函数的先验条件，则在函数结尾的后置条件也必须满足。
如果不能够满足先验条件，则万事皆休。
这就产生了一个有趣的问题：当不能满足先验条件时，这个方法应该做些什么？
从规范的角度来看，在这种情况下这个方法做什么都无所谓，可以说是“松了一口气”。
但如果你是实现者，你可能会想忽略掉不满足的先验条件。
这样做的话，有可能会意味着执行这个函数会导致程序立即崩溃；
也有可能代码虽然能够继续运行，但会产生一些无意义的结果。
不论是哪一种结果，其实都不太好。

一个更好的应对方法是：采用防御性编程实践。
因为有未满足的先验条件，说明程序里存在着错误，所以你应该能够检测到这种错误并处理它，而不是无动于衷地忽略这种情况。
但是这个应对方法应该怎么实现呢？
例如，我们可以让它输出错误信息。
因此在`sqrt`函数里就可能会有下面这样的代码：

```Python
def sqrt(x):
    ...
    if x < 0:
        print "Error: can't take the square root of a negative"
    else:
        ...
```

输出错误消息的弊端是调用程序无法知道出现了什么问题。
例如，这个错误消息可能只会出现在程序生成的报告里，甚至可能会被忽视掉。
在实际项目中，很可能会在图形程序里调用通用库，如`sqrt`函数，在这样的情况下，这个错误消息就根本不会出现在任何地方。

在大多数的情况下，方法被设计成向外输出消息的形式并不太合适（除非这个函数的规范里定义了需要输出某些东西）。
更理想的状况是：
函数能以某种方式表示发生了错误，并且能够让客户端程序决定如何处理这个问题。
对于某些程序，遇到错误的正确响应可能会终止程序并输出错误消息；
而在其他情况下，程序也许能够从错误中恢复并继续运行。
这样的选择结果应该只能由客户端做出。

一个方法可以通过多种方式发出错误信号，如返回一个超出范围的结果。
下面就是这样的一个例子：

```Python
def sqrt(x):
    ...
    if x < 0:
        return -1
    ...
```

既然`sqrt`函数的规范明确表示返回值不能为负，那么值`-1`就可以用来指示错误。
客户端代码可以凭借它返回的结果来确定是否正常。
另一种方法是，使用一个**全局**（global，程序的所有部分都能访问）变量来记录错误。
客户端代码在每次操作后，都会去检查这个全局变量的值，来确认是否存在错误。

当然，用这种特殊的检测方法来“检查错误”有一个问题：
客户端程序可能由于决策结构而不断地去检查错误以致变得混乱。
例如客户端的代码逻辑可能会变成下面这样：

```Python
x = someOperation()
if x is not OK:
    fix x
y = anotherOperation(x)
if y is not OK:
    abort
z = yetAnotherOperation(y)
if z is not OK:
    z = SOME_DEFAULT_VALUE
```

可以看出，每次操作之后的错误检查，已经多到模糊了原始算法的意图的地步。

大多数现代编程语言都包含**异常处理**（exception handling）机制，它为程序运行过程中出现的错误提供了一种优雅的处理方法。
异常处理背后的基本思想是程序错误不会直接导致“崩溃”，而是将程序的控制权转移到一个被称为**异常处理程序**（exception handler）的特殊部分。
这个异常处理程序特别有用的是：
让客户端程序不必显式地去检查是否发生了错误。
实际上，客户端只需要说：“如果出现任何错误，这里是我想要执行的代码。”
然后，在运行时系统会确保在发生错误时调用适当的异常处理程序。

在Python里，运行时的错误会生成**异常对象**（exception object）。
程序使用`try`语句来捕获和处理这些错误。
例如，取负数的平方根会导致Python生成`ValueError`（值错误异常）——这是一个Python的通用`Exception`（异常）类的子类。
如果客户端程序没有处理此异常，程序将会终止。
下面就是交互时发生的情况：

```Python
>>> sqrt(-1)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ValueError: math domain error
>>>
```

当然，程序里也可以“捕获”`try`语句中引起的异常：

```Python
>>> try:
...     sqrt(-1)
... except ValueError:
...     print "Ooops, sorry."
...
Ooops, sorry.
>>>
```

当执行到`try`下方缩进的这条语句的时候，如果发生错误，Python会查看错误是否与任一`except`子句中列出的类型匹配。
如果有，就执行第一个匹配的`except`语句块。
但是，如果没有匹配到任何一个`except`子句，则程序将停止并显示错误消息。

要利用异常处理来验证先验条件，我们只需要在判断决策中验证先验条件，并且生成适当的异常对象。
这称为**引发异常**（raising an exception），由Python里的`raise`语句完成。
`raise`语句非常简单：`raise <expr>`。
其中`<expr>`是生成包含有关错误信息的异常对象的表达式。
当执行`raise`语句时，它会让Python解释器中断当前操作并将控制权转移到异常处理程序。
如果找不到合适的处理程序，则程序终止。

Python库中的`sqrt`函数会通过这样的检查来确保其参数为非负数，并且参数具有正确的类型（`int`或`float`）。
因此，`sqrt`函数的代码可以包含下面这些检查语句：

```Python
def sqrt(x):
    if x < 0:
        raise ValueError('math domain error')
    if type(x) not in (type(1), type(1L), type(1.0)):
        raise TypeError('number expected')

    # compute square root here
```

请注意，用这些条件检查是不需要`else语句的。
因为当`raise`语句执行时，它有效地终止了该函数，所以只有满足先验条件时才会执行“计算平方根”的部分。

通常情况下，检测到先验条件违规时引发何种类型的异常并不重要。
重要的是，错误应该被尽可能早地诊断出来。
Python提供了一个将断言直接嵌入代码的语句——`assert`（断言）。
它输入一个布尔表达式（Boolean expression），当表达式计算结果不为`True`时，就会引发`AssertionError`异常。
使用`assert`语句使得强制执行先验条件变得特别容易。

```Python
def sqrt(x):
    assert x >= 0 and type(x) in (type(1), type(1l), type(1.0))
    ....
```

正如你所见，`assert`语句是一种将断言直接插入代码的非常简便的方法。
它非常有效地将先验条件（和其他断言）的文档转换为额外的测试，有助于确保程序依照规范正常运行。

这种防御性编程有个潜在的缺点：它增加了程序执行的额外开销。
因为每次调用函数的时候，都会额外消耗几个CPU周期来检查先验条件。
然而，鉴于现代处理器的速度不断提高以及错误程序的潜在危险不断增加，这通常是值得付出的代价。
另外，`assert`语句还有一个好处：可以在需要的时候关闭断言检查。
在命令行执行Python的时候，加上`-O`开关就可以让解释器跳过所有断言的检查。
也就是说，我们可以在程序测试时使用断言，然后在认为系统能够正常工作并投入到生产环境的时候将其关闭。

当然，在测试过程中检查断言，而在生产系统中将其关闭，就好像在有安全网的时候距离地面大约3米的地方练习一个特技，然后在刮风的日子里、没有安全网的情况下在离地面大约30米的地方表演这个特技。
在测试期间捕获错误非常重要，但在系统使用时继续捕获它们更为重要。
因此，我们的建议是随时随地地使用断言并随时保持打开断言检查。

### 自上而下的设计

你可能已经学会了一种非常流行的程序设计方法——**自上而下的设计**（top-down design）。
自上而下的设计本质上是通过功能抽象来将应用程序的大问题分解为更小、更易于管理的组件。
例如，假设你正在开发一个帮助你老师进行评分的程序。
你的老师希望这个程序能够输入一组考试成绩，并且输出一份总结学生表现的报告。
具体而言，程序输出的报告里应该包含以下有关的统计信息。

* **高分** 这是数据集中的最大数字。
* **低分** 这是数据集中的最小数字。
* **平均值** 这是数据集的“平均”分数。
它通常被表示为$\bar{x}$，并且由下面这个公式计算得到：

    $$
    \bar{x} = \frac{\sum x_i}{n}
    $$

    即所有的得分（$x_i$表示第$i$个得分）之和除以统计的分数个数（$n$）。
* **标准差** 这是衡量分数分布情况的指标。
标准偏差$s$可以由下面这个公式算出：

    $$
    s = \sqrt{\frac{\sum (\bar{x} - x_i)^2}{n-1}}
    $$

    在这个公式中，$\bar{x}$是平均值，$x_i$表示第$i$个数据值，$n$是数据值的数量。
    这个公式看起来很复杂，但计算起来并不难。
    表达式$(\bar{x} - x_i)^2$是单个元素与平均值的“偏差”的平方。
    分数的分子也就是所有数据值的偏差（平方之后）的和。

在刚开始编写这个程序的时候，你可以开发一个包含以下功能的简单算法：

```
Get scores from the user
Calculate the minimum score
Calculate the maximum score
Calculate the average (mean) score
Calculate the standard deviation
```

假设你正在与朋友合作开发此程序，你可以将这个算法划分为多个部分，并且每个部分都能够与程序里的其他部分协作。
然而，在开始真正的工作之前，你需要一个更完整的设计来确保每个人开发的部件都能够组合在一起，并且解决整个问题。
通过自上而下的设计，你可以把算法中的每一行当作一个单独的函数来编写。
这个设计也将会包含每个方法的规范。

一个显而易见的解决方案是：
把考试成绩存储在列表中，然后把这个列表作为参数，传递到各个方法里去。
使用这种解决方案的话，可以参考下面的设计示例：

```Python
# stats.py
def get_scores():
    """Get scores interactively from the user

    post: returns a list of numbers obtained from user"""

def min_value(nums):
    """ find the minimum

    pre: nums is a list of numbers and len(nums) > 0
    post: returns smallest number in nums"""

def max_value(nums):
    """ find the maximum

    pre: nums is a list of numbers and len(nums) > 0
    post: returns largest number in nums"""

def average(nums):
    """ calculate the mean

    pre: nums is a list of numbers and len(nums) > 0
    post: returns the mean (a float) of the values in nums"""

def std_deviation(nums):
    """calculate the standard deviation

    pre: nums is a list of numbers and len(nums) > 1
    post: returns the standard deviation (a float) of the values
          in nums"""
```

有了这些方法的规范，你和你的朋友就应该能够轻松地分配这些方法并且很快地完成这个程序。
让我们实现其中一个方法，看看它应该是什么样的。
如`std_deviation`方法的实现示例：

```Python
def std_deviation(nums):

    xbar = average(nums)
    sum = 0.0
    for num in nums:
        sum += (xbar - num)**2
    return math.sqrt(sum / (len(nums) - 1))
```

可以看到，这段代码的运行依赖于`average`函数。
由于我们已经定义了这个方法，因此可以放心地在这里直接使用它，从而避免了重复工作。
这里还使用了简化了的`+=`（加法赋值）运算符；
这是求和的简写方式。
也就是说`x += y`语句和`x = x + y`语句会产生相同的结果。

程序的其余部分将留给你来完成。
如你所见，在这个程序里自上而下的设计和方法的规范齐头并进。
所以，在设计确定了必要的功能时，规范保证了正式且确定的设计。
因此，程序的各个部分可以被单独处理。
你肯定能轻而易举地完成这个程序。

### 记录副作用

为了使规范有效，规范必须同时说明客户端和实现者的期望。
任何在客户端可见的影响都应在后置条件中被描述出来。
例如，假设`std_deviation`函数是下面这样实现的：

```Python
def std_deviation(nums):
    # This is bad code. Don't use it.
    xbar = average(nums)
    n = len(nums)
    sum = 0.0
    while nums != []:
        num = nums.pop()
        sum += (xbar - num)**2
    return math.sqrt(sum / (n - 1))
```

这段代码中使用了Python列表的`pop`方法。
对`nums.pop()`的调用将会返回列表中的最后一个数字，并**从列表中删除该项**。
之后循环继续，直到处理完列表中的所有元素。
这个版本的`std_deviation`能够返回正确的值，因此它似乎符合先验条件和后置条件指定的契约。
但是，作为参数传递的列表对象`nums`是可变的，而且对列表的任何修改都将对客户端可见。
所以，这段代码的使用者会非常惊讶，因为他们会发现调用`std_deviation(examScores)`会导致`examScores`中的所有值被删除！

这类函数调用和程序其他部分之间的相互影响被称为**副作用**（side effects）。
在这个例子里，删除`examScores`中的元素是调用`std_deviation`函数的副作用。
一般来说，应当避免方法中的副作用，但完全不准修改又禁止得太严格了。
有些方法就是需要产生副作用，列表类中的`pop`方法就是一个很好的例子。
它被用来获取一个值，然后就像副作用一样，从列表中删除这个元素。
因此，有一个至关重要的事情需要注意，方法中的任何副作用都应在其后置条件中指出。
由于`std_deviation`的后置条件并没有包含会修改`nums`的任何内容，因此这个代码实现隐性地违反了契约。
方法的可见效果应该**只是**在后置条件中描述的那些。

顺便说一下，输出消息或将信息放在文件中也是副作用的例子。
正如上面提到的，方法通常不应该输出任何东西，除非这是它声明的功能中的一部分，这也是一个（可能）未注明副作用的特殊情况。

## 算法分析

当我们开始处理包含数据集合的程序时，除了需要知道它的先验条件和后置条件，通常还需要了解更多。
处理一个包含10个甚至100个考试分数的列表倒是没有任何问题的，但是线上商业的客户列表可能包含成千上万个元素；
处理生物学问题的程序员可能得处理含有数百万甚至数十亿个核苷酸的DNA序列；
搜索和索引网页的应用程序也需要处理类似数量级的数据集。
当数据集越来越大时，算法的效率就会和它的正确性同样重要。
如果一个算法能够提供正确答案但需要10年计算时间，就明显不太可能有实际用处。

通过**算法分析**，我们可以根据完成任务所需的时间和内存使用状况来评估算法。
在本节中，我们将首先通过搜索数据集来了解算法分析技术。

### 线性搜索

搜索是指在集合中查找特定值的这一过程。
比如：一个维护俱乐部成员列表的程序可能需要查找特定成员的相关信息。
这就涉及某种形式的搜索。
搜索对我们来说是一个很好的问题，因为有许多相对效率不同的搜索算法可以用于对比。

为了透过现象看本质，我们可以用在列表里查找特定数字这一问题来简化我们的搜索问题。
而且，在这里使用的原则将同样适用于更复杂的搜索问题，例如搜索客户列表以查找居住在爱荷华州的人。
这个简单搜索问题的规范如下所示：

```Python
def search(items, target):
    """Locate target in items

    pre: items is a list of numbers
    post: returns non-negative x where items[x] == target, if target in
          items; returns -1, otherwise"""
```

下面是一些可以说明其行为的交互式示例：

```Python
>>> search([3, 1, 4, 2, 5], 4)
2
>>> search([3, 1, 4, 2, 5], 7)
-1
```

在第一个例子里，函数会返回列表中元素`4`的索引。
而在第二个示例中，返回值`-1`表示`7`不在列表中。

利用Python内置的列表函数，我们可以轻松实现`search`功能：

```Python
# search1.py
def search(items, target):
    try:
        return items.index(target)
    except ValueError:
        return -1
```

`index`函数用于从列表中找出某个值第一个匹配项的索引位置。
如果`target`不在列表中，则`index`函数会抛出`ValueError`异常。
在这里，程序捕获这个异常并返回`-1`。
很明显，我们实现的这个函数符合定义的规范；
更有趣一个问题是：这种函数的效率怎么样？

一种用来确定算法效率的方法是进行实证检验。
我们可以简单地实现这个算法，并且用不同的数据集来验证它，以查看需要多长时间。
在Python里提供了计时相关的代码，可以简单地使用时间模块（**`time`**）中的`time`时间函数来实现，它会返回从1970年1月1日开始到现在所经过的秒数。
我们可以在相关代码执行之前和之后调用这个方法，再输出前后之间的差异。
当将搜索功能放在名为`search1.py`的模块中之后，我们可以用下面的代码直接验证它：

```Python
# time_search.py
import time
from search1 import search

items = range(1000000) # create a big list

start = time.time()
search(items, 999999) # look for the last item
stop = time.time()
print stop - start

start = time.time()
search(items, 499999) # look for the middle item
stop = time.time()
print stop - start

start = time.time()
search(items, 10) # look for an item near the front
stop = time.time()
print stop - start
```

你可以在你自己的计算机上跑一跑这段代码，并且记下搜索3个数字的时间。
根据这3个时间，你能知道`index`函数是如何工作的吗？
顺便说一下，Python库里还包含了一个名叫`timeit`的模块，它提供了更为精确和复杂的计时方式。
如果你需要进行大量的实证检验，那么值得深入研究一下这个模块。

让我们自己也像计算机一样来思考，尝试开发我们自己的搜索算法。
假设有满满一页没有特定顺序的数字，需要判断数字`13`是否在这个列表中，你会怎么来解决这个问题？
你可以像大多数人一样，简单地一个一个元素地扫描整个列表，并且把每个值与`13`进行比较。
然后当你找到`13`的时候，退出扫描并告诉我你找到了它。
而如果直到列表的最后都没有找到`13`的话，你会告诉我它不在这一页里。

这种策略被称为**线性搜索**（linear search）。
即逐个元素地搜索整个列表，直到找到目标值为止。
这个算法可以直接写成下面这样简单的代码：

```Python
# search2.py
def search(items, target):
    for i in range(len(items)):
        if items[i] == target:
            return i
    return -1
```

可以看到在代码里有一个简单的`for`循环遍历整个列表的有效索引（`range(len(items))`）。
程序会在每个位置都会判断这个元素是不是我们的目标（`target`）。
如果找到了目标，则立刻终止循环，并返回这个位置的索引。
而如果这个循环直到结束都没有找到目标元素，则该函数返回`-1`。

这样写函数有一个问题：`range`表达式会创建一个与要搜索的列表大小相同的索引列表。
而由于`int`通常需要4个字节（32位）的存储空间，所以当有一个百万级的数字列表的时候，代码中的索引列表需要4MB的内存。
除了内存使用情况，创建这样的第二个大列表也会浪费相当多的时间。
Python有另一个名为`xrange`的表达式可以替代`range`使用。
`xrange`只能被用在迭代里，而且它在运行的时候也不会创建一个新列表。
要注意，在新的Python代码中不再鼓励使用`xrange`。[^1]

> [^1] 在Python 3.0中，默认`range`表达式的行为类似于`xrange`，也并不会创建列表。

如果你的Python版本是2.3或更高版本，你也可以使用`enumerate`函数。
这种优雅的替代方案允许你遍历列表，并且在每次迭代的时候，你都能获得下一个元素和它的索引。
下面是使用`enumerate`进行搜索的方式：

```Python
# search3.py
def search(items, target):
    for i,item in enumerate(items):
        if item == target:
            return i
    return -1
```

还有一种方法是使用`while`循环来避免使用`range`/`xrange`/`enumerate`时产生的问题：

```Python
# search4.py
def search(items, target):
    i = 0
    while i < len(items):
        if items[i] == target:
            return i
        i += 1
    return -1
```

注意一下，所有这些搜索功能的实现都使用了相同的算法——线性搜索。
那么这个算法效率怎么样？
要想知道怎么评判，你可以先尝试使用它。
就像你已经记录过的3个使用列表`index`方法的时间一样。
你唯一需要更改的是导入前面实现的这些`search`功能，它们的参数和返回值是相同的。
正是因为我们定义了一个规范，所以拥有不同的函数实现，客户端代码也不需要改变。
这就是工作中常用到的实现的独立性。
很酷，对吧？

### 二分搜索

线性搜索算法并不难实现，并且它对中等大小的列表处理得很好。
对于无序列表来说，线性搜索算法和其他任何算法都一样好。
Python里的`in`和`index`操作都实现了线性搜索算法。

如果我们遇到的是一个非常大的数据集合，这种情况下可能会希望数据按照某种方式进行组织，这样我们就不用查看每个元素来判断目标值在这个列表中的位置，或者是不是存在于这个列表。
假设这个列表按顺序（从低到高）存储。
一旦程序遇到了一个大于目标值的值，就可以退出线性搜索了，而不需要继续查看列表的其余部分。
平均来说，这能够节约大概一半的工作量。
实际上，如果列表已经有序，我们甚至可以做得更好。

当列表已经有序的时候，你可能已经知道了一个更好的搜索策略。
还记得玩过的猜数游戏吗？
我选择一个`1`～`100`的数字，你试着猜它是什么。
每次你猜的时候，我都会告诉你你的猜测是正确、太高还是太低。
那么你的策略是什么呢？

如果你和一个年纪非常小的孩子一起玩这个游戏，他很可能会采用一种随机猜测数字的策略。
而稍微大一些的孩子可能会采用与线性搜索相对应的方法——猜测`1`、`2`、`3`、`4`等，直到找到那个值。

当然，几乎所有成年人都会先猜`50`。
如果被告知目标值要高一些，那么它可能的范围就是`50`～`100`。
下一步就可以猜`75`。
每次我们都猜测剩余数字的中间位置来尝试缩小可能的范围。
这种策略被称为**二分搜索**（binary search）。
所谓的“二分”，也就是在每一步都把剩下的数字分成两部分。

我们可以使用二分搜索策略来查看一个有序列表。
其本质上是使用两个变量来跟踪目标值可能在列表中的范围的两个端点。
最初情况下，目标值可以在列表中的任何位置，因此我们将变量`low`和`high`分别设置为列表的第一个和最后一个位置。

这个算法的核心是一个查看剩余范围中间元素与`x`进行比较的循环。
如果`x`小于中间项，那么我们移动`high`变量，以便搜索缩小到较小的那半个部分；
而如果`x`要大一些，那么我们移动`low`变量，将搜索范围缩小到较大的那半个部分。
当找到了`x`或不再有任何要检查的地方（即`low > high`）时，循环终止。
下面的代码在相同的搜索API里实现二分搜索：

```Python
# bsearch.py
def search(items, target):
    low = 0
    high = len(items) - 1
    while low <= high:          # There is still a range to search
        mid = (low + high) // 2 # position of middle item
        item = items[mid]
        if target == item :     # Found it! Return the index
            return mid
        elif target < item:     # x is in lower half of range
            high = mid - 1      # move top marker down
        else:                   # x is in upper half
            low = mid + 1       # move bottom marker up
    return -1                   # no range left to search,
                                # x is not there
```

该算法比简单的线性搜索要复杂一些。
你可能会希望通过几个示例搜索，来向自己证明它是对的。

### 非正式的算法比较

到目前为止，我们为简单的搜索问题开发了两种截然不同的算法。
哪一个更好，取决于我们究竟认为什么是更好。
例如，我们会觉得线性搜索算法更容易理解和实现；
同时，我们可以预期二分搜索更为有效，因为它不用去查看列表里的每个值。
从直觉上来说，我们可能会认为线性搜索是小型列表的更好选择，而二分搜索则是大型列表的更好选择。
我们应该怎样来证实这种直觉呢？

与之前一样，一种方法是进行实证检验。
我们可以简单地编写两种算法，通过在不同大小的列表上进行尝试，来查看搜索需要多长时间。
这些算法都不长，因此运行一些验证并不困难。
当我们用一台计算机（有点过时的笔记本电脑）进行此验证时，对于长度为`10`或更短的列表，线性搜索更快；
对于长度处于`10`到`1 000`的范围内的列表来说，两者没有太大的差异；
而随着列表长度的增加，二分搜索显然是赢家。
对于一个拥有100万个元素的列表，线性搜索平均要花2.5秒来找到一个随机值，而二分搜索平均仅用0.000 3秒。

实证分析证实了我们的直觉，但这是在特定情况下一台特定机器的结果（固定的内存总量、处理器速度、当前负载等）。
我们应该怎样保证这个特定的结果具有普适性呢？

还有一种方法是：抽象地分析各种算法来查看它们的效率。
在其他因素相同的情况下，我们期望具有最少“步骤”的算法更有效。
但是怎么计算步数呢？
对于任意一个算法来说，其主循环的执行次数都将取决于特定输入。
我们已经猜到了二分搜索的优势会随着列表长度的增加而增加。

为了解决这类问题计算机科学家会分析算法要解决的特定问题的大小或难度所需采取的
步骤。
搜索的难度取决于集合的大小。
显然，在一个有100万个元素的集合中找到一个数字，比在一个只有十个元素的集合中找到一个数字需要更多的步骤。
相关问题是在大小为$n$的列表里查找值需要多少步骤。
我们特别感兴趣的是当$n$变得非常大的时候会发生什么。

我们先来考虑线性搜索。
如果列表有`10`个元素，算法最多会查看每个元素，因此循环最多迭代`10`次。
假设列表有两倍大，那么算法需要查看两倍的元素。
如果列表是3倍大，则需要查看3倍，以此类推。
通常，所需的时间量与列表的大小$n$线性相关。
因此，计算机科学家称之为**线性时间**（linear time）算法。
现在，你知道了为什么这个算法被称为线性搜索。

那么二分搜索呢？
让我们从一个具体的例子来开始分析。
假设有一个列表包含`16`个元素。
每次循环后，剩余的范围减半。
一次循环执行之后，还有`8`个元素需要考虑。
下一次之后将还剩`4`个，然后剩下两个，最后只有`1`个。
循环迭代了多少次取决于在数据耗尽之前我们可以将范围减半的次数。
表1.1应该能帮助你解决这个问题。

<center>表1.1 列表和对分次数</center>

| 列表大小 | 对分次数 |
| :-----:| :--: |
| 1 | 0 |
| 2 | 1 |
| 4 | 2 |
| 8 | 3 |
| 16 | 4 |

你能发现表格里的规律吗？
每一次额外的循环迭代，都允许我们搜索两倍大的列表。
如果二分搜索循环$i$次，它可以在大小为$2^i$的列表中找到一个值。
每次循环时，它都会查看列表中的一个值（在中间位置）。
要知道在大小为$n$的列表中一共检查了多少个元素，我们需要解决这个关系：
对于$i$，有$n = 2^i$。
在这个公式中，$i$是一个基数为$2$的指数。
利用对数，可以得到关系式$i = \log_2 n$。
如果你不太喜欢对数，那就记住这个值是大小为$n$的集合可以减半的次数就可以了。

这些数学告诉了我们什么呢？
二分搜索是对数时间算法的一个示例。
解决给定问题所花费的时间随着问题大小的对数增长而增长。
在二分搜索的情况下，每次额外的迭代都会使我们可以解决的问题的大小增加一倍。

你可能不太理解二分搜索的有效性。
让我们试着把它放在这样一个例子里。
假设你有一本纽约市电话簿，其中按字母顺序列出了1 200万个名字。
你向走在街上的任何一个纽约人提出这样一个建议（假设已经知道他们的号码）：
“我会尝试猜测你的名字。
我每猜一个名字，请你告诉我你的名字是在我猜的名字按字母顺序排列的之前还是之后。”
你需要多少次猜测？

上面的分析显示，这个问题的答案是$\log_2 12 000 000$。
如果你没有计算器在手边，这里有一个快速估算的结果：
$2^{10} = 1 024$或者说大概等于`1 000`，以及`1 000 × 1 000 = 1 000 000`。
也就是说$2^{10} × 2^{10} = 2^{20} ≈ 1,000,000$。
$2^{20}$大概就是100万。
因此，搜索100万个名字只需要20次猜测。
然后呢，我们只需要21次就能猜200万个名字，22次猜400万个，23次猜800万个，24次猜测就能搜索1 600万个名字。
我们只需要用24次猜测就能成功猜出纽约市任何一个陌生人的名字！
相比之下，线性搜索需要（平均）600万次猜测。
因此，二分搜索是一个非常棒的算法！

我们之前说过，Python使用线性搜索算法来实现其内置搜索方法。
如果二分搜索更好的话，为什么Python不使用它呢？
原因是二分搜索不太通用，为了能够正常工作，进行二分搜索的列表必须有序。
如果要对无序列表使用二分搜索，首先要做的就是将这个列表按照顺序**排列**（sort）。
这是计算机科学中另一个已经经过充分研究的问题，我们将在稍后讨论它。

### 算法的正式分析

在比较线性搜索和二分搜索的时候，我们根据解决特定大小问题所需的抽象步骤的数量来评估两种算法。
我们发现线性搜索需要与列表大小成正比的步骤，而二分搜索则需要与列表大小的（基数为$2$）对数成比例的步骤。
利用这种表征的好处是，它能够告诉我们这些算法的一些信息，以及与这些信息**无关的任何特定实现**。
我们预期二分搜索在大问题集上能做得更好，是因为它本身就是一种更高效的算法。

在进行这种分析时，我们通常不用关心解决特定问题的算法所需指令的确切数量，因为这是非常难以确定的。
毕竟，不同的计算机机器语言、实现算法的不同语言以及就像我们在搜索算法中看到的那样，特定输入数据的细节的不同，都会导致指令数量的不同。
因此，我们需要抽象出不会影响算法确切运行时间的问题，也就可以忽略掉所有会影响算法在各种大小输入上的相对性能的细节。
要知道，我们的目标是确定算法在大数据量输入时的执行性能。
现在的计算机速度很快，对于小规模的问题，效率一般不太可能成为瓶颈。

总而言之，在进行算法分析时，我们通常可以进行下面这些简化。

* 忽略使用不同语言和不同机器来实现算法所造成的差异。
* 忽略各种操作的执行速度的差异（例如，我们不会关心浮点除法计算是否比整数除法更慢）。
假设所有的“基本操作”（赋值、比较、大多数数学运算等）花费相同的时间。
* 假设所有与输入大小无关的固定时间的操作都是等效的（就是说，我们都不关心它是否需要`10`次操作、`100`次操作、甚至`1 000`次操作，只要这些操作在任意大小的输入集里都需要执行才能解决问题，我们就忽略它们

很明显，这里的任何一个简化都会让比较的两个算法的结果和实际运行时间不同，甚至会忽略掉同一个算法的不同实现所产生的差异。
但这个结果仍然可以向我们显示我们所期望的作为**输入大小的函数值**。
因此，这个结果会告诉我们对于更大的问题的性能相对来说是什么样的。
计算机科学家们使用**大$O$符号**或者说**渐近符号**（asymptotic notation）来表示基于这些简化的算法的时间复杂度。

在深入大$O$符号的细节之前，让我们看几个简单的数学函数来获得一些直观感觉。
假设函数$f(n) = 3n^{2} + 100n + 50$。
你要在$n$很大的时候估计这个函数的值。
这时，你应该只考虑多项式的第一项。
虽然$n$比较小的时候，$100n$项能够占据主导地位，但$n$变大之后，第二项和第三项对最终结果的贡献是微不足道的。
例如，在$n = 1 000 000$时，只使用第一项得出的结果和函数的真实结果的差别在0.01%之内。

你只需要看看第一项和第二项的图形“形状”（如图1.2所示），就能够明白为什么第一项在$n$增加时能占主导地位了。
从图里可以看出，就算在`0`～`1`的范围内$x＞x^2$，但只要$x＞1$，$x^2$就一定会占据主导。
所以，当我们将$x$乘以某个常数（如100）时，虽然会改变那条直线的斜率，但因为函数$x^2$向上弯曲，它仍然会超过$100 × x$（在$x = 100$的时候）。
因此，无论我们将$x$乘以哪个常数，这两个图形的形状都表明，只要值足够大，$x^2$的曲线都将占主导地位。

图1.2 `0`～`1` 时$x^2$小于$x$，但对于更大的值来说$x^2$更大

大$O$符号可以用来表示这种只关注主导地位的函数。
例如，当算法被表示为$O(n^2)$时就表明存在某些常数$c$和$n_0$，当$n＞n_0$的时候，有$n＜cn^2$。
只要我们能找到这两个常数，就能够证明算法的时间复杂度是$O(n^2)$。
在多数情况下，它非常明显（像上面的例子里一样）。
那么，函数$3n^2 + 100n + 50$的常数是什么呢？
在这里我们并不需要一个**严格的**边界。当$n＞1 000 000$的时候，$3n^2 + 100n + 50 ＜ 1 000 000n^2$，我们就可以将两个常数都定义为$1 000 000$。
如果算法是$2n^3$，我们能找到两个常数来证明它是$O(n^3)$吗？
在实践中，我们通常不太关心去找到这些常数。
在大多数情况下，增长率就非常容易让我们相信了。
所以对于任何多项式，它的最重要的部分都是最大的项，因此任何$x$次多项式都是$O(n^x)$。

现在你已经从数学细节上了解了大$O$符号，让我们在看一些简短的例子，并确定它们的运行时间：

```Python
n = input('enter n: ')
for i in range(n):
    print i
```

这个代码片段的时间复杂度是$O(n)$，因为$n$的大小会决定有多少次操作——`print`语句将会被执行$n$次，而`input`语句就执行一次。
让我们仔细研究下`for`语句，`range`语句将会生成一个包含$n$个元素的列表，这个生成过程就至少需要$n$步。
每次迭代完`for`语句之后，变量`i`都会指向列表里的下一个元素，因此我们可以很容易地得出大约需要$2n + 1$个基本步骤来执行这个代码片段。
这也就足以表明，算法的时间复杂度是$O(n)$。
在这里，我们忽略了在Python里也需要时间来检测是否到达列表的末尾，因为在实际工作中，在得到代码片段的时间复杂度的时候，我们通常不需要深入了解所有的细节。

思考下面这个代码片段。
你能确定它运行的时间复杂度吗？

```Python
n = input('enter n: ')
for i in range(100):
    print i
```

晃眼一看，因为有一个`for`循环，你可能会认为这个代码的时间复杂度也是$O(n)$。
但是，在这种情况下，无论输入的值是什么，`for`循环都会且只会执行`100`次。
本质上来说，这和`100`个`print`语句没有任何区别，也就可以被理解为是`100`个常量时间的操作。
所以，无论输入任何数值，这段代码片段都能以相同的常量时间运行，在这里我们将所有常量操作都简单表达为$O(1)$。

下面是一个有两个循环的例子：

```Python
n = input('enter n: ')
for i in range(n):
    print i
for j in range(n):
    print j
```

这个例子里，两个循环按顺序一个接一个地执行，所以总共时间复杂度可以表达为$O(n + n)$。
你可以先把它看作$O(2n)$，而常数乘数不会影响大$O$符号，因此仍然是$O(n)$。
通常来说，当需要将算法的顺序执行部分的时间复杂度加在一起时，整个算法的大$O$就是各部分的大$O$的最大值。
这也就意味着，你只需要找到算法执行步骤最多的部分，然后分析它，就能得到整个算法的时间复杂度。

让我们再来看看另一个有两个循环的例子：

```Python
n = input('enter n: ')
for i in range(n):
    for j in range(n):
        print i, j
```

在这个片段中，循环是嵌套的。
而且，第二个循环对第一个循环的**每次迭代**都要迭代$n$次。
也就是说`print`语句总共要执行$n^2$次，所以代码的时间复杂度为$O(n^2)$。
一般来说，对于嵌套循环，时间复杂度是每个循环迭代次数的乘积。

接着来关注下面这个例子：

```Python
n = input('enter n: ')
total = 0
for i in range(n):
    for j in range(10):
        print i, j
        total = total + 1
```

这个例子里也有两个嵌套循环，你可能认为它的时间复杂度也是$O(n^2)$。
但要注意，无论$n$的值是多少，内层循环总是迭代`10`次。
我们仍然可以用“让每个循环迭代次数相乘”的这个规则，因此迭代次数是$10 × n$。
所以这个代码片段的时间复杂度是$O(n)$，在渐近分析中会忽略掉常数系数。

让我们尝试一个稍微麻烦一点的嵌套循环案例：

```Python
n = input('enter n: ')
for i in range(n):
    for j in range(i, n):
        print i, j
```

这段代码里还是有两个嵌套循环，但内层循环在外层循环的每次迭代中，都循环不同的次数。
在这种情况下，之前那个简单的乘法规则就不起作用了，但好在这种分析并不太难。
那么，我们想要知道当输入为$n$的时候，`print`语句一共执行了多少次，应该怎么做呢？
第一次迭代外层循环的时候，内层循环迭代了$n$次。
第二次的时候，内层循环迭代了$n − 1$次，依此类推。
直到最后，在外层循环的最后一次迭代中，内层循环只迭代`1`次。
那么内层循环的迭代的总次数，只需要将它们全部都加起来就能得出，即：$1 + 2 + … + n$。

你应该曾经在数学课里见到过这个公式。
当然，如果没有的话，下面是解决这个问题的一种方法。
先把这个公式与自身相加，然后把它写成下面这样：

$$
\begin{matrix}
  &   & (1 & + & 2     & + & 3     & + & ... & + & n) \\
  & + & (n & + & (n-1) & + & (n-2) & + & ... & + & 1)
\end{matrix}
$$

每一列的和都是$n + 1$，一共有$n$列。
所以，所有列的和就是$n(n + 1)$。
而这个和是原始公式的两倍，因此除以$2$就能得出公式：$n(n + 1) / 2$。
展开公式，就会有二次多项式，所以我们可以得出结论，这段代码片段的时间复杂度为$O(n × 2)$。

最后，这里有一个使用`while`循环的小例子：

```Python
n = input('enter n: ')
while n > 1:
    n = n // 2  # // is integer division
```

这段代码片段与之前的所有其他代码片段都不一样——有一个不会迭代$n$次的循环。
每次迭代的时候，$n$都会除以`2`。
所以，我们应该去确定$n$等于`1`所需要的循环次数。
这和我们之前提到的“猜数字游戏”里的二分搜索是同一个问题。
每次输入的大小翻倍的时候，迭代次数加`1`。
因此，输入为$n$时，算法的步数是等式$2^x = n$，其中$x$表示步数。
所以，答案是$x = \log_2 n$。
在许多算法里，输入都会被不断地被分成两半。
这种情况下，我们最终都可以得到$O(\log_2 n)$这样的时间复杂度。

让我们回到搜索函数，你现在有了能够正式分析代码的所有工具。
我们的线性搜索，使用了一个会迭代$n$次的`for`循环，所以它是$O(n)$。
这也是它被称为**线性搜索**的原因：
函数的运行时间是个线性函数（多项式最高次幂为`1`次）。
而且就像前面提到过的，排序列表的二分搜索算法时间复杂度是$O(\log_2 n)$。
因此循环（最多）迭代$\log_2 n$次就能够完成整个流程，而且每次循环体执行的操作数都是常量。

时间复杂度能够告诉我们，在面对大数据集的时候，我们的算法效率如何。
对于仅仅会执行一两次的代码，效率通常不是一个重要的问题。
然而，当你的程序需要两年的时间来解决一个问题的时候，效率就成了一个大问题。
大$O$符号可以让我们推断并确定程序在更大的数据集上需要运行多长时间。
如果我们想要知道这个程序在两倍大的输入集的情况下需要执行多长的时间，只需要在函数中插入$2n$来代替$n$。
比如说，一个算法的分析结果是$O(n^2)$，然后我们让输入集翻倍，我们可以预期它需要4倍的时间来执行，因为$(2n)^2$就是$4n^2$。
换句话说，如果我们的算法在大小为100万的输入集上需要执行1分钟，那么我们完全可以预期它会在200万的输入集上花4分钟。

### 大$O$符号与$Θ$符号

从理论上来说，大$O$符号只给出了算法效率的上限。
回顾一下大$O$符号的定义。
如果算法的时间复杂度是$O(n)$，那么它的复杂度也可以同样表示为$O(n^2)$、$O(n^3)$等。
通常来说，绝大多数算法都是$O(2^n)$，但是当我们想要比较两个特定算法的时候，这样说没有任何意义。
而且，当我们对算法进行大$O$分析时，我们总会试图去找到一个更“严格”的上界。
比如我们都**知道**的，当列表的大小翻倍时，线性搜索要发现一个数字不在列表之中，需要花费两倍的时间。
然而，这里提到的线性搜索的渐近增长率是$n$，但是如果可以知道确切的增长率，显然将会为我们提供更多的信息。

这里，我们引入$Θ$（Theta符号）来描述更严格的上（下）限。
要证明算法的时间复杂度是$Θ(f(n))$，必须证明有常数$c_1$、$c_2$和$n_0$，使得算法对于所有$n > n_0$，执行步数都会大于$c_1f(n)$且小于$c_2f(n)$。
通过将算法的时间复杂度限制在$f(n)$的两个倍数之间，我们可以明确执行步数将和$f(n)$以**相同速率**增长，因此算法的执行步数（对于较大$n$），基本上等于$f(n)$的某个倍数的值。
实际上，我们一般不会去找到这个常量的确切的值，除非分析的算法特别复杂。
有关函数边界的示例，如图1.3所示。

图1.3 $0.5x^2$介于$0.25x^2$和$0.75x^2$之间

在算法分析中，常见的一些函数的增长率如表1.2所示。
从这个表格里我们可以看见，算法的复杂度函数对于它能不能在合理的时间内解决问题非常重要。
指数级（例如$2^n$）增长的算法，并不能用于解决哪怕只是普通大小的问题。
如果计算机每秒可以执行10亿次操作，那么当输入的大小是`100`的时候，完成一个指数算法需要多长时间？
利用表1.2所示的信息，我们可以知道$2^100$大约是$10^30$（也就是`1`后面跟上`30`个零）。
这是一个非常大的数字。
将它除以每秒`10`亿次操作可以得出结论，在输入大小为`100`的时候，运行这个算法需要$10^21$ 秒，也就是超过$10^13$年。
而宇宙通常被认为是在100亿～200亿年前诞生的，所以这是一个比宇宙生命还要大上千倍的时间！

表1.2 常见函数的近似增长率

当我们已经知道解决特定大小的问题需要多长时间的时候，就可以使用$Θ$符号来估计解决与之相比更大尺寸的问题所需要的时间。
比如说，有一个$Θ(n^2)$的排序算法需要25秒才能对计算机上的100万个元素进行排序，由此就可以估计出在同样的计算机上使用相同的代码对200万个元素排序需要多长时间。
从上面的信息中可以得出方程$c(1 000 000)^2 = 25$秒。
有一点需要注意，$Θ$符号（和大$O$符号一样）不会表示出最大项前面的常数乘数。
但是，在列出等式的时候，需要包含这个常数乘数，这样可以求解$c$，$c = 2.5(10^{-11})$。
现在，我们就可以计算$2.5(10^{-11})(2,000,000)^2$，也就是100秒。

可能你已经发现，在这个情况下我们甚至都不需要去求解$c$。
因为我们已经知道算法的时间复杂度是$Θ(n^2)$，而现在我们想知道当输入大小翻倍时会发生什么。
我们可以把$2n$带入$n$并展开，得到：$(2n)^2 = 4n^2$。
也就是，在使用$Θ(n^2)$算法时，需要用4倍的时间来解决两倍的问题。
这和我们之前的答案一样（$25(4) = 100$）。

很明显，我们将尽可能地使用$Θ$符号来表明算法的性能。
对于一些复杂的算法，很难去证明一个严格的边界，在这种情况下我们可能只会去证明一个非严格的上界（大$O$符号）。
通常来说，我们也只会分析算法的最坏情况下的时间复杂度。
可能你会觉得平均情况下的时间复杂度更有用，但这个值一般并不太好得到。
对于线性搜索，我们可以知道最好的情况是$Θ(1)$，最坏的情况是$Θ(n)$，因此很容易得出平均情况也是$Θ(n)$。
因为，当我们在一个不重复的列表中搜索每一个元素的时候，这个元素可能会在第一、第二、第三……一直到最后一个位置上被找到。
所以，寻找的元素的总数是$n(n + 1) / 2$，对于平均情况来说，只需要除以搜索的次数$n$就好了，也就是$Θ(n)$。
而对于二分搜索，确定平均情况的时间复杂度将会更加困难。

## 章节总结

这一章里，我们介绍了编写大型软件系统至关重要的基本概念。

* “小作坊”式的编程和“大型”编程在不同维度上的不同。
设计和实施大型程序的根本问题是如何控制复杂度。

* 在编写程序的时候，抽象被用来简化和减少程序员需要理解的信息量。
一些特别有用的抽象类型（比如功能抽象）能够允许将“做什么”与“如何做”分开，并且通过契约来优化设计。

* 程序断言通过要求在给定执行点处必须为真来文档化程序。
先验条件与后置条件是特殊类型的断言，它们提供了一种表明函数或方法的行为的便捷方法。

* 自上而下的设计可以把更大的问题分解成若干个小问题。
对功能进行分解的规范，使得一个项目上可以有多个程序员一起工作。

* 对于比较大的数据集，算法的效率很重要。
我们通过用渐近分析来区分算法的效率。
大$O$符号被用来表示效率（时间复杂度）的上限，而$Θ$符号被用来表示更准确的时间复杂度增长率。

## 练习

**判断题**

1. 为了能够正确地使用库中定义的函数/类/方法，必须要了解它的API（即参数和返回值是什么）

2. 假设定义的先验条件、后置条件还有实现的代码都是对的，如果在执行代码之前已经满足了先验条件，则保证在执行代码后后置条件也一定为真。

3. 当函数检测到其先验条件被违反时，应该输出错误消息。

4. 函数的签名提供了其行为的完整规范。

5. 精心设计的功能/方法通常具有未注明的副作用。

6. 使用相同的计算机、编程语言和输入数据，执行$Θ(n)$的算法肯定比执行$Θ(n^2)$的算法快。

7. 使用代码行数多的函数可能比使用代码行数少的函数更快。

8. 当算法的预期输入大小很小时，$θ$符号是算法效率的有效度量。

9. 所有的$O(n^2)$算法时间复杂度都是$Θ(n^2)$的。

10. 所有的$Θ(n^2)$算法时间复杂度都是$O(n^2)$的。

**选择题**

1. 以下哪项不属于函数签名的一部分？

    a) 函数的名称

    b) 该函数如何工作

    c) 参数

    d) 返回值

2. 函数中的哪些操作会产生副作用？

    a) 将不可变参数设置为新对象

    b) 将可变参数设置为新对象

    c) 修改可变参数

    d) 返回一个值

3. 下面哪项表明满足了函数的先验条件？

    a) 该函数不会崩溃

    b) 该函数返回一个值

    c) 该函数抛出了异常

    d) 以上都不是

4. 一般来说，以下哪项对算法在大型数据集上执行的时间影响最大？

    a) 算法的效率

    b) 用于实现算法的计算机语言

    c) 算法中的代码行数

    d) 计算机上硬盘的速度

5. 具有两个循环的函数的渐近运行时间是

    a) $Θ(\log_2 n)$

    b) $Θ(n)$

    c) $Θ(n^2)$

    d) 没有足够的信息来确定

6. 如果$Θ(n^2)$的算法需要3秒才能处理有100万个元素的输入，那么大约需要多长时间才能处理200万个元素？

    a) 6秒

    b) 9秒

    c) 12秒

    d) 18秒

7. 如果$Θ(n^3)$的算法需要4秒才能处理有100万个元素的输入，那么大约需要多长时间才能处理200万个元素？

    a) 8秒

    b) 16秒

    c) 32秒

    d) 64秒

8. 如果$Θ(\log_2n)$的算法需要20秒才能处理有100万个元素的输入，那么大约需要多长时间才能处理200万个元素？

    a) 21秒

    b) 25秒

    c) 30秒

    d) 40秒

9. 如果$Θ(2^n)$算法需要10秒才能处理有10个元素的输入，那么大约需要多长时间才能处理20个元素？

    a) 20秒

    b) 100秒

    c) 1,000秒

    d) 10,000秒

10. 如果计算机每秒能够执行10亿次操作，那么一个需要执行$n^2$次操作的算法，面对200万个元素的输入，大约需要执行多长时间？

    a) 400秒

    b) 2,000秒

    c) 4,000秒

    d) 20,000秒

**简答题**

1. 函数/方法的副作用是什么？

2. 描述自上而下的设计的基本方法以及它与契约式设计之间的关系。

3. 如果需要重复地对一个有20个元素的随机列表进行搜索以查找用户输入的不同值，应该使用哪种搜索方法？
应不应该创建另一个包含相同元素但已经有序的列表来进行搜索？
为什么你这样认为？

4.  如果需要重复地对一个有2 000 000个元素的随机列表进行搜索以查找用户输入的不同值，应该使用哪种搜索方法？
应不应该创建另一个包含相同元素但已经有序的列表来进行搜索？
为什么你这样认为？

5. 对于上面的问题，Python的列表是存储数字最合适的数据类型吗？
如果不是的话，你会使用Python的哪一个数据类型？

6. 如果计算机每秒能够执行10亿次操作，那么一个需要执行$2^n$次操作的算法，面对$n = 100$个元素的输入，大约需要执行多长时间？

7. 如果计算机每秒能够执行10亿次操作，那么一个需要执行$n^2$次操作的算法，面对$n = 1 000 000$个元素的输入，大约需要执行多长时间？
如果算法需要执行$n^3$次操作呢？

8. 对以下代码片段的时间复杂度进行$θ$分析。

    a)
    ```Python
    n = input(’enter n: ’)
    for i in range(n):
        x = 2 * n
        while x > 1:
            x = x / 2
    ```
    b)
    ```Python
    n = input(’enter n: ’)
    total = 0
    for i in range(n):
        for j in range(10000):
            total += j
    print total
    ```
    c)
    ```Python
    total = 0
    n = input(’enter n: ’)
    for i in range(2 * n):
        for j in range(i, n):
            total += j
    for j in range(n):
        total += j
    print j
    ```

9. 书中第一个版本的线性搜索算法使用了Python的`index`方法，而没有用任何循环。
但是，我们也提到了线性搜索算法时间复杂度是$Θ(n)$。
通常来说，没有循环的算法的时间复杂度应该是$Θ(1)$。
请解释这一（明显的）差异。

**编程练习**

1. 创建一个包含0～999 999的拥有100万个整数的列表。
分别用`index`方法和`for`语句的线性搜索，以及二分搜索对最好和最坏情况进行计时（像这一章的例子中那样，使用`time.time`函数）。
在注释中列出你使用的计算机规格（CPU芯片和时钟速度、操作系统和Python版本）以及3个搜索在最好和最坏情况下的执行时间。

2. 创建元素为1～1 000万的整数，元素个数为`10 000`、`100 000`和`1 000 000`的随机列表。
使用内置的列表`sort`方法来对每个列表进行排序并计时。
在注释中列出你使用的计算机规格（CPU芯片和时钟速度、操作系统和Python版本）以及对每个列表进行排序所需的时间。
注释中里还应该包括`sort`方法的$Θ$时间复杂度。

3. 选择排序算法是这样来进行排序操作的：
在未排序的序列里找到最小元素，然后和列表的第`0`个位置的元素互换；
之后，再从列表里寻找第二小的元素，然后和列表的第`1`个位置的元素互换；
以此类推，找到第$n − 1$个最小的元素并将其置于$n − 2$的位置。
这时，最大的元素也就会处于位置$n − 1$上了。
在Python里实现这个算法，并注明算法的$Θ$时间复杂度。
同样，对上一个问题里创建的那3个列表进行排序，并计时。

4. 设计一个比较对不同大小的列表执行线性搜索和二分搜索的实验。
将结果输出成图，看看能不能找到线性搜索胜过二分搜索的那个“交叉”点。
由于小列表搜索速度非常快，因此你得发挥下聪明才智才能得到搜索时间的有效数据（提示：通过计算多次指定的搜索来得到更大的搜索时间总和）。
写一份完整的实验报告，解释你的实验设置、方法、数据以及分析。

5. 完成在1.2.3小节里的统计信息程序。
请务必在已知结果的数据集上彻底测试你的程序。

6. 在1.2.3小节的程序里添加一个函数，这个函数能够返回5个整数，分别是90分数段、80分数段、70分数段、60分数段和60以下分数段的分数的个数。
确保为新函数提供完整的规范，并且包括适当的先验条件与后置条件，以及相应的实现代码。

7. 每当需要一组数据的平均值的时候，通常也需要计算标准差。
这样一来，在1.2.3小节里的统计信息程序的现有API在某种程度上是低效的，这是因为在计算平均值和标准差的时候，会导致前者被计算了两次（为什么？）。
重新设计这个程序的API来避免这个问题。
你的新设计应该允许用户高效地单独计算平均值、单独计算标准差以及同时计算两个值。

8. 设计并实现一个问答程序。
这个程序能够从文件里读取问答信息。
例如，关于美国各个州的首府的问答程序将会在文件的每一行中找到州名和它的首府的名称（如俄亥俄州：哥伦布市）。
你的程序应该询问一定数量的问题并输出正确答案的数量。
在你的设计中至少要有3个独立的函数。

9. 编写一个函数的规范和实现，从有序列表中挤出（“squeezes”）重复项。例如：

    ```Python
    >>> x = [1, 1, 3, 3, 3, 4, 5, 5, 8, 9, 9, 9, 9, 10]
    >>> squeeze(x)
    >>> x
    [1, 3, 4, 5, 8, 9, 10]
    ```

    彻底地测试你的函数并分析其效率。

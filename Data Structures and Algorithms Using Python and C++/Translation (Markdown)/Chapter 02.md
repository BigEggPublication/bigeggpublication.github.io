# 数据的抽象

目标

* 了解抽象数据类型在软件设计中的使用方式。

* 回顾面向对象设计的基本原理和技术。

* 了解单元测试以及如何在Python里编写单元测试。

* 了解运算符重载以及如何在Python里重载运算符。

## 概要

算法是程序的基本构建模块中的一员。
在第1章里我们了解到了，将函数会做什么与其实现细节分开所带来的好处。
在本章，我们将介绍程序处理中的数据。
当我们考虑数据对象时，分离行为和实现的好处会更大。
在构建实用的软件系统的时候，这种*数据抽象*过程将会是一种必须掌握的基本概念。
计算机科学家们将数据抽象的概念，用*抽象数据类型*（*abstract data types*，ADT）来具象化。
我们也可以这样说，抽象数据类型是面向对象编程的基础，而面向对象编程是大型系统的主流开发方法。

我们首先要了解，抽象数据类型以及它们与面向对象编程之间的关系。
在这个过程中，我们将展示如何使用面向对象编程来扩展编程语言，使其具有新的数据类型，从而能更好地解决新领域之中的问题。
对于支持被称为*运算符重载*（*operator overloading*）这一能力的语言，新的数据类型将会看起来和语言自身的内置类型一样，以及具有类似的行为。

通过使用抽象数据类型和对象，程序设计就成了把一个问题分解为更小部分的过程：
一组互相协作对象将会提供程序的大部分功能。
随着这些较小的部件被一个一个的实现，它们都可以单独地进行测试，从而在将部件组合成更大的系统之前，让开发人员相信各个部件是具有正确性的。
学习如何进行有效的测试是软件开发难题的另一个重要部分。

## 抽象数据类型

任何存储在计算机中的数据都有一个重要属性：*数据类型*（*data type*）。
对象的数据类型决定了它可以拥有的值以及我们可以用它做什么（比如，它支持的操作类型有什么）。
例如，在32位计算机上，内置类型`int`可以存储从$-2^{31}$到$2^{31}-1$范围内的任意整数，并且可以被用于加法（`+`）、减法（`-`）、乘法（`*`）和除法（`/`）等等操作。
在了解了这些信息之后，你就能够在不关心这些数字是怎么存储在计算机上的情况下，也能编写使用`int`的程序。
用上一章中的术语来说，我们可以说这个操作`int`数值的程序是一个`int`数据类型的客户端。

当然，为了使一个数据类型方便好用，必须对这个类型进行一些必要的底层实现。
这些实现应该既包括一个可以在底层用来存储该类型的所有可能值的方式，也包括操作这个底层数据的一组函数。
让我们回到`int`数据类型。
在今天的计算机里，它通常用32位二进制来存储。
而加法和减法之类的操作算法是在底层的机器硬件里定义的，然后输入和输出`int`的方法则内置在大多数编程语言里。

### 从数据类型到抽象数据类型

利用抽象概念，我们可以将数据如何存储和它的使用方式区分开来。
也就是说，我们提供的数据类型的规范，可以和它的任何实际实现都不相关。
这样的规范也就描述了一个抽象数据类型。
精确而完整的规范描述，能够让客户端程序的编写无需关心抽象数据类型是如何在计算机中具体实现。
通过这种方式，数据抽象扩展了实现的独立性的优势。
这让我们可以在获得有关如何使用这个数据的足够信息之后，再决定在我们的程序中应该如何存储这个数据。
而且，我们也可以去修改数据类型的具体存储，抽象的边界可以确保程序的其它部分不会受到任何不好的影响。

对于程序中可能发生变化的部分，数据的抽象尤为重要。
重要的设计决策可以被封装在抽象数据类型里，之后抽象数据类型的具体实现可以根据需要来调整，而不会影响到程序的其余部分。
之后你会看到，在通常情况下，更改数据的存储方式会对相关操作的效率产生重大影响。
所以，在尝试调整程序的效率时，如果有修改存储方法的自由，对程序员来说是一个非常大的利好。

抽象数据类型的另一个优点是它可以促进重用。
一旦实现了相关的抽象，它就可以被许多不同的客户端程序使用。
这些客户端程序就能够不用再去重新“发明”这个数据类型，也就免除了许多麻烦。
所以，程序员们也就能够为其特定编程领域中有用的新数据创建数据类型，从而对编程语言实现扩展。
同样的，在对抽象数据类型进行了全面测试之后，它就能够在不用考虑具体的实现细节下，放心地使用。

### 定义抽象数据类型

你可以将抽象数据类型看作操纵底层存储的函数或者方法的集合。
存储的内容实际上只是一些数据集合。
我们只需要描述抽象数据类型所支持的操作，就能够像之前分辨函数一样，分辨不同的抽象数据类型。
唯一的区别是一个抽象数据类型由一*组*函数来描述的。

我们来看一个简单的例子。
假设我们正在编写一个关于纸牌游戏的程序，比如桥牌或德州扑克。
这里我们可以把一张扑克牌建模为一个简单的抽象数据类型。
下面是这个抽象数据类型的描述：

```Python
ADT Card:
    A simple playing card. A Card is characterized by two components:
    rank: an integer value in the range 1-13, inclusive (Ace-King)
    suit: a character in 'cdhs' for clubs, diamonds, hearts, and
          spades.

Operations:

    create(rank, suit):
        Create a new Card
        pre: rank in range(1, 14) and suit in 'cdhs'
        post: returns a Card of the given rank and suit

    suit():
        Card suit
        post: Returns Card’s suit as a single character

    rank():
        Card rank
        post: Returns Card’s rank as an int

    suitName():
        Card suit name
        post: Returns one of ('clubs', 'diamonds', 'hearts',
              'spades') corrresponding to Card’s suit.

    rankName():
        Card rank name
        post: Returns one of ('ace', 'two', 'three', ..., 'king')
              corresponding to Card’s rank.

    toString():
        String representation of Card
        post: Returns string naming the Card, e.g. 'Ace of Spades'
```

在这个描述扑克牌（Card）的规范里需要注意是，它使用了一些抽象属性（数字和花色），以及我们可以对扑克牌执行的操作来描述这个规范。
它并没有描述扑克牌是如何实际存储的，以及如何实现各个操作。
实际上，规范里甚至没有明确地引用任何扑克牌对象或参数。
这隐含地表明了一件事情，规范里的这些操作可以通过*某种*方式应用于任何扑克牌。

在设计抽象数据类型的过程中，我们的目标是：
提供一整套能够使得抽象数据类型变得有用的操作。
当然，扑克牌（Card）抽象数据类型可以有许多不同的设计可供选择。
比如，我们可以为不同的操作使用不同的名称。
一些设计师更喜欢将访问抽象数据类型的函数冠以“`get`”开头的名称。
因此，他们可能会使用`getSuit`和`getRank`代替获取花色和获取数字。
其他的设计师可能会为各种操作的参数提供不同的类型。
比如说，花色或许可以用整型（`int`）来表示而不是用字符串（`string`）。
或者通过简单地提供一组用来表示花色和数字的变量，来“隐藏”它们的确切存储方式。
比如，可以将叫做`CLUBS`（梅花）的标识符指定给表示花色的某个值，就像标识符`None`在Python里代表特殊地`None`对象一样。
同样地，扑克牌的数字也可以用`ACE`（尖），`TWO`（二），`THREE`（三）等名字来表示。

随着你不断地获得使用抽象数据类型的经验，你会慢慢发掘自己的设计灵感。
要记住，设计抽象数据类型最重要的一点是实现独立性。
抽象数据类型仅仅描述了一组操作，而不用去描述这些操作的具体实现方式。
一个可以用来“测试”抽象数据类型的设计的好方法是：尝试编写一些使用它的客户端算法。
例如，这里有一个用来打印出标准扑克牌牌套里所有牌的数字、花色和“名称”的算法：

```Python
for s in 'cdhs':
    for r in range(1, 14):
        card = create(r, s)
        print 'Suit:', suit(card)
        print 'Rank:', rank(card)
        print toString(card)
```

这个算法用了类似于Python的语法来表达，并且还加上了前面提到的抽象数据类型的抽象函数。
这个算法可以向我们表明，提供的抽象数据类型的操作集能够创建和打印所有的52种扑克牌。

### 实现抽象数据类型

在设计抽象数据类型的时候，是可以独立于语言的。但是一旦进入到实现和使用这个轴向数据类型的时候，我们就需要添加一些特定于特定编程环境的细节。
程序员可以通过很多种方式将抽象数据类型转换到特定的编程语言上。
实际上，所有的编程语言都提供了定义新函数的能力。
所以，实现抽象数据类型的其中一种方法，就是编写一组适当的函数。
比如，在Python中，我们可以为扑克牌抽象数据类型（`Card`）的每个操作都编写一个函数，并且将它们都放在一个模块文件中。

当然，在编写这些功能的时候，我们需要决定如何在计算机上存储扑克牌抽象数据类型（`Card`）。
这个抽象类型有数字和花色两个组件。
在Python里，一个简单的存储方式是：将数字和花色组合起来作为元组（`tuple`）里的一对值。
Python里的元组（`tuple`）是一个贫血（不可被修改）的值序列类型。
它是在括号中使用逗号分隔符来分隔的序列。
所以，使用元组之后，梅花尖可以被存储为元组`(1，'c')`，而黑桃王是`(13，'s')`。

抽象数据类型的基础存储方式称为*具体存储方式*（*concrete representation*）。
比如，我们会说元组`(5，'d')`是抽象扑克牌（方片五）的具体存储方式。

现在，我们已经为我们的扑克牌抽象数据类型（`Card`）决定了存储方式，编写具体的实现代码就变得非常简单。
下面有一个实现的版本：

```Python
# cardADT.py
# Module file implementing the card ADT with functions

_SUITS = 'cdhs'
_SUIT_NAMES = ['clubs', 'diamonds', 'hearts', 'spades']
_RANKS = range(1, 14)
_RANK_NAMES = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six',
               'Seven', 'Eight', 'Nine', 'Ten',
               'Jack', 'Queen', 'King']

def create(rank, suit):
    assert rank in _RANKS and suit in _SUITS
    return (rank, suit)

def rank(card):
    return card[0]

def suit(card):
    return card[1]

def suitName(card):
    index = _SUITS.index(suit(card))
    return _SUIT_NAMES[index]

def rankName(card):
    index = _RANKS.index(rank(card))
    return _RANK_NAMES[index]

def toString(card):
    return rankName(card) + ’ of ’ + suitName(card)
```

先来看看`create`函数。
它使用了一个断言（`assert`）来检查是否满足创建扑克牌类型的先验条件，然后它只返回一个数字花色的元组。
通过这种方式，这个函数虽然只返回一个值，但是这个值体现了有关特定扑克牌的所有信息。

数字（`rank`）和花色（`suit`）的操作只是简单的打开了扑克牌元组的一部分。
元组组件可以通过索引来访问，因此`card[0]`会给出第一个部分，即扑克牌的数字，同样的，`card[1]`能够给出花色。
这两个操作非常简单，所以你甚至可能会想是不是必须保留它们。
使用扑克牌抽象数据类型（`Card`）的客户端能不能通过像`myCard[1]`这样的方式直接拿到花色呢？
答案是，客户端*可以*这样做，但*不应该*这样做。
抽象数据类型的重点是对客户端和具体实现进行解耦。
如果客户端直接访问具体存储方式，那么后面如果修改了具体存储的方式，将会导致客户端代码异常。
在这里，请记住这一条例：客户端只能通过抽象数据类型提供的操作来使用抽象数据类型。

这段代码还有一个值得注意的地方是，里面使用了一些特殊的值：`_RANKS`，`_SUITS`，`_RANK_NAMES`和`_SUIT_NAMES`。
`suitName`函数和`rankName`函数其实可以用一个大型的多路`if`语句来实现。
但在这里，我们采用了*表格驱动*的方法。
通过索引（`index`）方法来得到数字或花色的位置，然后使用这个索引值来查找相应的名字。
这样做，缩短了代码，从而使它更容易修改。
比如说，我们只需要简单地在`_SUITS`和`_SUIT_NAMES`的末尾添加另一个元素，就能轻松地添加第五个花色。

值得一提的是，这个查找表格的变量名长得这么奇怪是有特殊原因的。
常量名使用全大写，通常是常量的编程约定。
常量就是被设置一次之后再也不会改变的事物。
名称前的下划线是Python的一种约定，表示这些名称在模块里是“私有的”。
当客户端像下面这样导入模块的时候

```Python
from cardADT import *
```

以下划线开头的标识符将不会被导入本地程序。
这就使得实现细节（例如，查找表格的使用）不会破坏客户端程序的命名空间（定义的标识符集合）。

现在，我们已经有了扑克牌抽象数据类型（`Card`）实现，那么我们也就能够使用这个抽象数据类型模块来编写打印所有扑克牌的程序。

```Python
# test_cardADT.py
import cardADT

def printAll():
    for suit in 'cdhs':
        for rank in range(1, 14):
            myCard = cardADT.create(rank, suit)
            print cardADT.toString(myCard)

if __name__ == '__main__':
    printAll()
```

总而言之，实现抽象数据类型的一种方法是：选择一个具体存储方式，然后编写一组操作这个存储方式的函数。
如果我们的实现语言支持模块（就像Python一样），我们可以将所有的实现放在一个单独的模块之中，从而让它拥有自己独立的命名空间。

如果用来实现的语言不支持分离模块的思想，那么我们可能会遇到抽象数据类型之间的操作名称“冲突”的问题。
比如说，在我们编写玩纸牌游戏的程序的时候，我们可能还会有一个叫做`deckADT`的牌组抽象数据类型来代表一整副牌。
可以肯定的是，牌组抽象数据类型会有自己的创建方法。
但是，因为没有模块分隔，我们就必须依靠命名约定来保持操作的正确性。
例如，扑克牌里的所有操作可能都会以`card_`开头，而牌组里的操作则会以`deck_`作为开头。
因此，这个时候，我们会有两个单独的函数：`card_create`和`deck_create`。

## 抽象数据类型和对象

就像刚才看到的，抽象数据类型包含了一组操作底层数据存储的行为。
你应该对这个概念很熟悉。
因为只要你使用的是面向对象的编程语言（例如Python），那么把抽象数据类型当作编程语言里的对象是非常自然的，因为对象里也会包含数据和操作。
简单来说：对象“能知道些什么（数据）还能做些什么（操作）。”
对象里的数据是存储在实例变量中的，相应的各种操作就是它拥有的函数。
所以，我们可以使用变量的实例来存储抽象数据的具体存储表示，编写各种函数来实现各个操作。

就像你已经知道的一样，新的对象类型可以使用类（`class`）来定义。
随着Python语言的发展，它已经支持了两种不同类型的类，它们被称为：
*经典*类（*classic* classes）和*新式*类（*new-style* classes）。
对于我们的例子来说，经典类和新式类的行为完全相同。
在本书中我们将会使用Python的新式类，因为在编写新代码的时候新式类被强烈推荐。
我们可以简单地通过使类继承内置的`object`对象来指示新式类。
你并不需要知道有关继承的任何细节，就能够使用新式类
对于旧代码，你只需稍微改变一下这个类的头部就行了。
比如，要创建具新式类的`Card`类，我们应该编写`class Card(object):`而不是`class Card:`。[^1]

> [^1] Python 3.0已经移除了对经典类的支持，因此类的头部定义将只能用新式类。

### 规范

在面向对象的编程语言里，我们可以通过定义一个新类来创建新的对象数据类型。
我们可以把抽象数据类型直接转换描述成一个合适的类规范。
下面就是一个关于`Card`类型的类规范：

```Python
class Card(object):
    """A simple playing card. A Card is characterized by two components.
     rank: an integer value in the range 1-13, inclusive (Ace-King)
     suit: a character in 'cdhs' for clubs, diamonds, hearts, and
           spades."""

    def __init__(self, rank, suit):
        """Constructor
        pre: rank in range(1,14) and suit in 'cdhs'
        post: self has the given rank and suit"""

    def suit(self):
        """Card suit
        post: Returns the suit of self as a single character"""

    def rank(self):
        """Card rank
        post: Returns the rank of self as an int"""

    def suitName(self):
        """Card suit name
        post: Returns one of ('Clubs', 'Diamonds', 'Hearts',
        'Spades') corrresponding to self’s suit."""

    def rankName(self):
        """Card rank name
        post: Returns one of ('Ace', 'Two', 'Three', ..., 'King')
        corresponding to self’s rank."""

    def __str__(self):
        """String representation
        post: Returns string representing self, e.g. 'Ace of Spades' """
```

简单来说，这个规范只是`Card`类在Python里的轮廓。
这个类的文档描述给出了概述，然后各个方法里的文档描述表明了每个方法的作用。
依照Python语言的一些约定，以双下划线为开头和结尾的方法名称（`__init__`和`__str__`）是特殊方法。
Python会将`__init__`识别为构造函数，而当要求Python将`Card`对象转换为字符串的时候，`__str__`方法都会被调用。
例如：

```Python
>>> c = Card(4, 'c')
>>> print c
Four of Clubs
```

现在我们已经把抽象数据类型转换成了面向对象的形式。
因此这个类的客户端将会使用点操作符来执行抽象数据类型的操作。
下面这段代码是用来打印出所有52张扑克牌的代码，这些扑克牌都被转换成了对象的形式：

```Python
# printcards.py
#   Simple test of the Card ADT

from Card import Card

def printAll():
    for suit in 'cdhs':
        for rank in range(1, 14):
            card = Card(rank, suit)
            print 'Rank:', card.rank()
            print 'Suit:', card.suit()
            print card

if __name__ == '__main__':
    printAll()
```

要注意的是，使用类名称`Card`的时候，就会调用构造函数。
然后当要求打印扑克牌对象的时候，Python会隐式调用`__str__`方法。

### 实现

我们可以把之前我们有的扑克牌抽象数据类型实现，转换成我们新的基于类的实现。
现在扑克牌的数字和花色组件可以被存储在适当的实例变量里了：

```Python
# Card.py
class Card(object):
    """A simple playing card. A Card is characterized by two components:
    rank: an integer value in the range 1-13, inclusive (Ace-King)
    suit: a character in 'cdhs' for clubs, diamonds, hearts, and
    spades."""

    SUITS = 'cdhs'
    SUIT_NAMES = ['Clubs', 'Diamonds', 'Hearts', 'Spades']

    RANKS = range(1,14)
    RANK_NAMES = ['Ace', 'Two', 'Three', 'Four', 'Five', 'Six',
                  'Seven', 'Eight', 'Nine', 'Ten',
                  'Jack', 'Queen', 'King']

    def __init__(self, rank, suit):
        """Constructor
        pre: rank in range(1,14) and suit in 'cdhs'
        post: self has the given rank and suit"""

        self.rank_num = rank
        self.suit_char = suit

    def suit(self):
        """Card suit
        post: Returns the suit of self as a single character"""

        return self.suit_char

    def rank(self):
        """Card rank
        post: Returns the rank of self as an int"""

        return self.rank_num

    def suitName(self):
        """Card suit name
        post: Returns one of ('clubs', 'diamonds', 'hearts',
              'spades') corresponding to self’s suit."""

        index = self.SUITS.index(self.suit_char)
        return self.SUIT_NAMES[index]

    def rankName(self):
        """Card rank name
        post: Returns one of ('ace', 'two', 'three', ..., 'king')
              corresponding to self’s rank."""

        index = self.RANKS.index(self.rank_num)
        return self.RANK_NAMES[index]

    def __str__(self):
        """String representation
        post: Returns string representing self, e.g. 'Ace of Spades' """

        return self.rankName() + ' of ' + self.suitName()
```

要注意的是，以前版本里就存在的查找表格现在被设置给了`Card`类的内部的一个变量，并且这个变量不属于任何一个方法。
他们被称为是*类变量*（*class variables*）。
它们“存活”在类的定义之中，因此所有类的实例都会共享同一个副本。
使用`self.<name>`约定，就能像访问实例变量一样的去访问这些类变量。
当Python被要求检索对象属性的值的时候，它会首先检查这个对象是否已经直接分配了这个属性。
如果没有，Python将会继续在对象的类里去检索这个属性。
比如说，在`suitName`方法里访问`self.SUITS`的时候，Python会知道`self`实例里没有`SUIT`属性，因此会去使用`Card`类里的值（因为`self`是一个`Card`类）。

现在，程序里可以有三种不同的变量类型来存储信息：常规（本地）变量，实例变量和类变量。
在实现一个抽象数据类型的时候，为给定的信息选择正确的变量类型是非常重要的。
为了正确选择，你必须回答的第一个问题就是：
需不需要将数据被不同的方法互相使用？
如果不需要，就应该使用本地变量。
`rankName()`中使用的索引（`index`）变量就是本地变量的一个很好的例子。
方法一旦结束，这个值就不再被需要。
可以看到，在`suitName`方法里也有一个名叫`index`的本地变量。
即使它们正好具有相同的名称，它们也是两个完全独立的变量。
因为，每个变量都只在执行它们的方法时才存在。
我们也可以在这两个方法里使用实例变量`self.index`来编写。
但是，这样做会是一个充满误导性的设计，因为我们没有理由在执行`rankName`或`suitName`方法的时候保留`index`变量里的值。
在这种情况下，不同方法可以重用这个实例变量，也就意味着方法之间存在一个不应该存在的连接。

需要被不同的方法互相使用的数据应该存储在实例变量或者类变量中。
在这种情况下，使用哪种变量类型取决于：
数据在不同的对象之间互不相等，或者对于这个类的所有对象都是相同的。
在我们的扑克牌示例中，`self.rank_num`和`self.suit_char`在不同的扑克牌里拥有不同的值。
因此，它们是特定扑克牌实例里的一部分，所以它们必须是实例变量。
相应的，花色名称对于扑克牌类的扑克牌实例来说都是相同的，这样的话，使用类变量才是有意义的。
常量通常都应该是类变量，因为根据定义，它们在不同的对象之间是相同的。
当然，有些情况下，非常量的类变量也是合理的。
记住这些简单的规则应该可以帮你轻松地将抽象数据类型转换为工作类。

正如你所见，抽象数据类型的概念与面向对象的类之间存在着自然的相互对应的关系。
在使用面向对象的编程语言的时候，一般都会把抽象数据类型实现成为一个类。
使用类的好处在于，它能够很自然地将抽象数据类型的两个方面（数据和操作），都融合到一个程序结构里。

### 改变存储方式

我们之前强调过，使用抽象数据类型来设计软件的主要优势是实现独立性。
然而，到目前为止我们讨论的扑克牌示例里并没有真正的体现这一点。
毕竟，我们只是定义了一张扑克牌的数字是个整型（`int`），而花色是个字符，然后我们把这些值存为实例变量。
客户端在操作数字和花色的时候，不是直接使用了这个存储方式么？

在这种情况下，客户端*好像看起*来可以直接访问存储方式的原因仅仅是因为：
我们选择的具体存储方式，直接反映了向抽象数据类型传递和来自于它的信息的数据类型。
然后，因为我们是通过方法（如`suit`和`rank`）来访问的数据，我们就能够可以在不影响客户端代码的情况下更改具体存储方式。
这个地方，就有了独立性。

假设我们正在为手持设备（比如：PDA或者手机）开发一款纸牌游戏。
在这样的设备上，我们可能会有更严格的内存限制。
目前，我们的扑克牌的存储方式需要每张扑克牌有两个实例变量：数字，这是一个32位的整型`int`；以及花色，这是一个字符。
另一种可以考虑的扑克牌存储方式的方法是：给它们编号。
由于一共只有52张扑克牌，每张扑克牌都可以用0到51之间的数字来表示。
所以，先考虑按照花色的顺序来排列扑克牌，比如说，所有的梅花在前面，方块次之。
然后，在整套扑克牌里，把扑克牌按照数字大小的顺序放入。
这样，我们就有了一个完整的扑克牌组，在这个牌组里的第一张牌是梅花尖，最后一张是黑桃K。

只要有一个扑克牌的序号，我们可以计算出它的数字和花色。
由于每个花色都有13张牌，将序号除以13（使用整数除法）就会得到一个属于0到3（含）之间的值。
这样0将会代表梅花，1将会代表方片，以此类推。
此外，这个除法的余数将会给出这个扑克牌在花色里相应位置（也就是扑克牌数字）。
比如，如果扑克牌的序号是37，因为`37 // 13 = 2`，所以，花色是红心。
而`37 % 13 = 11`，这说明，这个扑克牌的数字是Q，因为任意花色里的第一张牌（尖）的余数都会是0。
所以，序号为37的扑克牌是红桃Q。
通过这种方法，我们的扑克牌抽象数据类型的具体存储方式就变成了单个数字。
我们将会把这种更具内存效率的存储方式的`Card`类作为练习让读者去具体的实现。

### 面向对象的设计和编程

你一定已经发现了，抽象数据类型和面向对象编程的思想之间，存在密切的对应关系。
但面向对象（Object-Orientation，OO）不仅仅能用来实现抽象数据类型。
大多数的面向对象专家都谈到了开发真正面向对象的三个特性：
封装、多态和继承。

#### 封装

我们已经知道，对象能知道些什么还能做些什么。
它们结合了数据和操作。
将数据和可以对这些数据进行的操作集打包在一起的过程称为*封装*（*encapsulation*）。

封装是使用对象的主要吸引力之一。
它提供了一种方便的方法来构建复杂问题的解决方案，这些问题正好和我们对世界运作方式的直观看法相对应。
我们会非常自然地认为，我们周围的世界是由能够相互作用的物体所组成。
每个对象都会有它自己的身份标识，而知道对象是一个什么类型的对象，可以让我们能够理解它的本质和它的能力。
当你望向窗外的时候，你会看到是房屋，汽车和树木，而不是大量分子或者无数的原子。

从设计的角度来看，封装还是一个关键服务，被用来区分：
“是什么”和“如何做”。
对象的实际实现和它的使用无关。
封装是我们能够实现独立性的原因。
封装可能是使用对象的最大的好处，但只凭封装，也只能使系统*基于对象*。
对于真正的面向对象，还需要有多态性和继承性的特性。

#### 多态性

从字面上来看，*多态*（*polymorphism*）这个词的代表的是“多种形态”。
在面向对象的上下文里使用这个词的时候，它指的是一个对象在响应消息（方法调用）时所做的事情，取决于对象的类型或者是对象的类。
设想这样一个简单的例子：
假设你正在使用一个图形库来绘制二维图形。
这个代码库提供了许多可以用来绘制到屏幕窗口里的基础几何图形类。
每个图形类都有一个用来绘制这个图形的操作。
因此，我们会有类似下面这样的包含若干个类的集合：

```Python
class Circle(object):
    def draw(self, window):
        # code to draw the circle

class Rectangle(object):
    def draw(self, window):
        # code to draw the rectangle

class Polygon(object):
    def draw(self, window):
        # code to draw the polygon
```

当然，除了`draw`方法之外，这些类中也会有其他的一些方法。
我们在这里只是给出了一个简单的示例。

假设你编写的程序里，创建了一个包含若干种几何对象的列表，这个混合列表里有：
圆形、矩形、多边形等。
要绘制列表中的所有对象，你可以用下面这个代码：

```Python
for obj in objects:
    obj.draw(win)
```

让我们来看看在循环体中的那一行代码:
当`obj.draw(win)`执行的时候，调用的应该是什么函数？
其实，这一行代码调用了几个不同的函数。
当`obj`是圆形（`Circle`）时，它会调用圆形（`Circle`）类的`draw`方法。
当`obj`是矩形（`Rectagle`）时，它会调用矩形（`Rectagle`）类里的`draw`方法，对于多边形（`Polygon`）类也是一样的。
在这里，`draw`操作有多种形式。
具体使用哪一种，取决于`obj`的类型。
这就是多态。

多态为面向对象系统提供了执行对象的操作的灵活性，就像它很自然的执行对象的方法一样。
如果我们没有对象支持多态，就只能像下面这样做了：

```Python
for obj in objects:
    if type(obj) is Circle:
        draw_circle(...)
    elif type(obj) is Rectangle:
        draw_rectangle(...)
    elif type(obj) is Polygon:
        draw_polygon(...)
    ...
```

这段代码不仅更加繁琐，而且灵活性也低得多。
因为，在我们想要向图像库里添加另一种类型的对象的时候，我们就必须根据对象类型找到我们做出这些判断的所有位置，然后再添加另一个分支。
在支持多态的版本里，我们可以创建一个包含`draw`方法的新的几何对象类，而所有其他地方的代码都不用被修改。
多态的这一特性，允许我们能够在不修改现有代码的情况下扩展程序。

#### 继承

面向对象开发的第三个重要特性是*继承*（*inheritance*）。
顾名思义，继承的含义是一个新类可以在定义的时候，从另一个类里“借用”它的行为。
新类（进行借用的类）被称为*子类*（*subclass*），已经存在的类（被借用的类）则是它的*超类*（*superclass*）。

比如，现在我们要构建一个记录员工信息的系统。
我们可能会有一个`Employee`类，这个类里包含了所有员工共有的一般信息和方法。
一个例子是用来返回员工的家庭地址的`homeAddress`方法。
员工也有不同的类别，在这里，我们可以简单的把他们区分为全职员工（`SalariedEmployee`）和小时工（`HourlyEmployee`）。
我们可以创建基于`Employee`类的这些子类，这样的话，它们就同样会包含`homeAddress`方法。
同时，因为这些不同类别的员工的薪酬计算方式各不相同，每个子类都会有它自己的`monthlyPay`函数。
图2.1显示了描述这种情况的简单类图。 头部开放的箭头表示继承; 子类继承了Employee类中定义的homeAddress方法，但每个子类都定义了自己的monthlyPay方法实现。

图2.1：继承的简单示例，其中子类的继承共享了一个方法，每个子类也有单独实现的一个方法

继承提供了两个好处。
一个是我们可以构建系统里的类的关系来避免重复操作。
在上一个例子里，我们不需要为`HourlyEmployee`类和`SalariedEmployee`类都编写单独的`homeAddress`方法。
另一个的好处是新类通常可以基于已经存在的类，从而促进代码重用。

## 抽象数据类型的实例：数据集（`Dataset`）

现在，我们已经知道了抽象数据类型和面向对象的原则，让我们回过头来看看第1章中提到的统计信息程序。
只不过这一次，我们会用面向对象的办法来解决这个问题。

### 面向对象设计的过程

设计的本质是：用“黑箱”和它的接口来描述系统。
每个组件都通过接口来提供一个服务或者一套服务集合。
在自上而下的设计中，函数/方法起到了这个黑箱的作用。
客户端程序可以使用函数，只要它能够理解这个函数/方法能做什么就行了。
具体这个函数/方法是怎样完成这个功能的详细信息被封装在函数的定义之中。
相应的，在*面向对象设计*（*object-oriented design*，OOD）中，对象就是这个黑箱。

如果我们可以将一个庞大的问题分解为一组相互协作的类，那么我们就能够大大降低必须要考虑的复杂性，从而方便地理解程序的任何部分。
因为，每个类都能够独立存在。
面向对象设计是分析和定义某个给定的问题，从而得到一组有用的类的过程。
像所有设计工作一样，面向对象设计也充满着一部分的艺术和一部分的科学。

面向对象设计有很多种方法，每种方法都有一套属于它的特殊技巧、符号、关键点和注释。
了解设计的最佳方法应该就是不断去尝试。
当你设计得越多，你就能够掌握得更好。
下面是面向对象设计的一些非常直观的指南，应该能够让你更快的入门，：

1. *寻找候选的对象*：
目标是要去定义一组有助于解决问题的对象
首先来仔细考虑一下问题的描述。
对象通常都是用名词来描述的。
因此，你可以把问题描述里的所有名词都加上下划线，然后再一一考虑它们。
它们中的哪一个会在程序里被存储起来？
哪一个有一些“有趣”的行为？
可以用基础数据类型（数字或字符串）来存储的东西，一般来说，不会是对象的重要候选者。
而涉及到一组相关数据项（比如，点的坐标，或者是关于员工的个人数据）的事情，一般可能会是一个比较号的候选者。

2. *找出实例变量*：
在发现了一些潜在候选对象之后，考虑这些对象要完成其自身工作所需要的相关信息。
实例变量里应该有哪些值？
一些对象可能只会包含基础的元数据；
而其他的一些对象可能本身就是个复杂类型，因此应该用对象或者类。
不断进步，为你的程序中的所有数据都找到一个合适的“家”（类）。

3. *考虑一下接口*：
当您确定了潜在的候选对象/类以及和它们相关联的一些数据之后，就要开始去考虑这些类的对象应该有什么有用的操作。
和之前类似，你可以从问题描述里的动词作为开始；
因为，动词会被用来描述动作——这个对象必须要去做什么。
这样，你就能够列出这个类所需要的所有方法。
记住一件事情：对象的所有数据操作，都应该通过你提供的方法来完成。

4. *优化那些庞大的方法*：
有些方法看起来可以只需要几行代码就能够完成。
与此相对的是，其他的一些方法则需要大量的工作来开发相应的算法。
我们可以用自上而下的设计和逐步细化，来实现它的复杂方法的细节。
随着设计工作的进展，你可能会发现，这个类需要与其他类进行一些新的交互，而这就会让你只能在其他类里添加新的方法。
当然，有些时候，你也会发现可能需要一个全新的对象来定义另一个类的调用。

5. *迭代设计*：
在完成设计之后，你可能会在设计新类和向现有类添加新的方法之间来回反复。
这是正常的，接着做你需要做的事情就好了。
没人可以完美的、一次性的，就能够自上而下的把一个程序设计出来。
所以，做你需要做的事情就好了。

6. *尝试替代方案*：
当遇到一个看起来不起作用的方法，或者去验证一个想法的时候，不要害怕废弃这个方案。
好的设计里包含了大量的反复试验。
当你看别人的程序的时候，你看到的是一个已经完成了的工作，而不是他们如何设计编写实现这个结果的过程。
如果一个程序被设计得非常好，那么它很有可能不是第一次尝试就能得到的结果。
传奇软件工程师Fred Brooks创造了这样一句格言：“把扔掉也加进计划。”
通常来说，在你曾经错误的构建系统之前，你并不会真正地知道应该怎样去构建一个系统。

7. *把事情简单化*：
在设计的每一步，都应该尝试找到最简单的方法来解决手上的问题。
除非明确地知道，需要更复杂的方法来实现，不然不要设计额外的复杂性。

### 定义一个抽象数据类型

还是回到之前那个统计信息程序里。
我们的目标是：报告一组代表考试分数的简单统计数据。
这个程序里最有可能的候选者对象是什么？
从问题描述来看，我们需要对分数（名词）进行操作。
那么分数应该是一个对象吗？
一般来说，分数只是一个数字，看起来Python内置的其中一个数字类型能够被用在这里，比如说：浮点数`float`类型。
那问题里还有什么可以被我们知道的吗？
为了计算需要的统计数据，我们需要跟踪整组分数。
在统计里，我们把这些分数称为*数据集*（*dataset*）。
集合往往是抽象数据类型的一个良好候选者。
那么在这里，让我们尝试使用一个数据集（`Dataset`）类。
同样的根据问题里要求的统计信息，很明显我们需要一些方法来返回数据集中的：
最小值、最大值、平均值和标准差。

接下来，我们剩下的最后一个问题是：我们要怎样才能把数字输入到数据集（`Dataset`）里。
数据集（`Dataset`）类型提供了一个简单的方法`add`来在数据集中放置一个数字。
因此，我们可以在构造函数里，初始化一个空的集合，然后一个一个的添加数字。
这里有一个关于数据集（`Dataset`）的规范的例子：

```Python
# Dataset.py
class Dataset(object):
    """Dataset is a collection of numbers from which simple
    descriptive statistics can be computed."""

    def __init__(self):
        """post: self is an empty Dataset"""

    def add(self, x):
        """add x to the data set
        post: x is added to the data set"""

    def min(self):
        """find the minimum
        pre: size of self >= 1
        post: returns smallest number in self"""

    def max(self):
        """find the maximum
        pre: size of self >= 1
        post: returns largest number in self"""

    def average(self):
        """calculate the mean
        pre: size of self >= 1
        post: returns the mean of the values in self"""

    def std_deviation(nums):
        """calculate the standard deviation
        pre: size of self >= 2
        post: returns the standard deviation of the values in self"""
```

只需要看一看这个规范，就会让我们知道，我们应该在抽象数据类型里添加一个新操作。
这是因为，很多操作都需要基于数据集中有多少元素这个前提条件，所以我们应该有一个返回这个值的操作。
保证抽象数据类型操作的先验条件的有效性，始终会是一个好主意。
这样做，能够允许客户端能够正确地使用抽象数据类型，同时也能让实现代码更方便地检查先验条件。
因此，让我们再添加一个方法：

```Python
def size(self):
    """
    post: returns the size of self (number of values added)
    """
```

和以前一样，我们可以通过编写一些使用它的代码来“测试”我们的设计。
在这个例子里，可以直接利用数据集（`Dataset`）抽象数据类型，来为我们的应用程序编写主程序。
我们所需要的只是一个能够监听输入数据的循环：

```Python
# test_Dataset.py
def main():
    print 'This is a program to compute the min, max, mean and'
    print 'standard deviation for a set of numbers.\n'
    data = Dataset()
    while True:
        xStr = raw_input('Enter a number (<Enter> to quit): ')
        if xStr == '':
            break
        try:
            x = float(xStr)
        except ValueError:
            print 'Invalid Entry Ignored: Input was not a number'
            continue
        data.add(x)
    print 'Summary of', data.size(), 'scores.'
    print 'Min:', data.min()
    print 'Max:', data.max()
    print 'Mean:', data.average()
    print 'Standard Deviation:', data.std_deviation()

if __name__ == ’__main__’:
    main()
```

### 实现这个抽象数据类型

为了实现我们的数据集（`Dataset`）抽象数据类型，我们需要为这组数字提供具体存储方式。
一种显而易见的方法是：
使用一个数字列表，就像我们在使用自上而下设计开发的那个最初版本里做的一样。
在这种实现里，`add`方法只是把一个数字添加到列表之中。
然后，每个统计方法会循环遍历数字列表中的所有元素来执行计算。

当然，和几乎任何抽象数据类型一样，这里也可以用一些其他可能的具体存储方式。
比如，我们真的需要在数据集（`Dataset`）里储存所有列表里所有的数字吗？
实际上，这些方法里，没有一种真的需要知道在集合里的每一个具体的数字，他们只是需要一些关于这些数字的摘要信息。
比如说，很显然，对于`min`（最小值）和`max`（最大值）方法，我们只需要分别知道，到目前为止已经添加到集合里的最小值和最大值。
对于`average`（平均值），我们只需要知道所有数字的和以及整个数据集的尺寸就能实现。
因此，我们可以将诸如数据集尺寸、最小值、最大值和所有数据之和这类的摘要信息储存为实例变量。
那么，在将新数字添加到数据集（`Dataset`）的时候，`add`方法将会更新这些实例变量；
从而达到不需要单独存储所有的数字。

但是在这个时候，我们没办法得出标准差。
最早我们使用的标准差公式需要计算每个数字与平均值之间的差值。
显然，在我们拥有所有数据之前，我们没法知道平均值是什么，因此在计算标准差的时候，我们需要在知道平均值之后还能遍历每一个数字，从而能够得到它们与平均值之间的差值。
然而，在这里，有一个称为“捷径公式”的等价标准差公式，它的计算方法是这样的：

$$
s = \sqrt{\frac{\sum x_i^2 - \frac{(\sum x_i)^2}{n}}{n-1}}
$$

这个公式不需要我们知道每个$x_i$，只需要知道所有数字的和以及它们的平方和就行了。
因此，我们只需要在增加一个额外的实例变量来存储平方和，就能使用这个公式了。

那么，我们现在有两种可能的数据集（`Dataset`）类的具体存储方式：
第一个版本基于之前的设计，通过维护一个包含所有数字的列表的实例变量（例如self.data）来实现；
第二个版本则是通过维护一组表示数字的摘要信息的实例变量（self._size，self._min，self._max，self._sum，self._sum_squares）来实现。 [^2]

> [^2] 在实例变量名中使用前导下划线是一种通常的约定，这样做会将它们“标记”为实例变量，从而防止它们与类似命名的方法（max方法 vs. _max实例变量）产生冲突。

使用任何一个具体存储方式来实现数据集（`Dataset`）类，对你来说应该都没什么问题了。
编写实际的代码将会被当作练习。
但是，即使没有代码，我们也可以分析这两种存储方式的相对效率:
与最初使用的自上而下设计所开发的版本相比，第二种存储方式具有这样几个优点。
比如，最明显的，因为它不需要记住已添加到集合中的数字列表，所以它在存储空间方面会更加有效。
实际上，当添加更多数据时，这种更高效的数据集（`Dataset`）对象的内存占用量甚至不会发生改变。

非常有趣的是，第二种存储方式在执行时间方面也更加有效。
在第一个版本里，每个统计操作都必须循环遍历整个数字列表，因此时间复杂度是$Θ(n)$的效率，其中$n$是数据集的大小。
而第二个版本不需要循环，所有操作都是常量时间，因此是$Θ(1)$。

## 抽象数据类型的实例：有理数（`Rational`）

希望通过之前的例子，你能知道如何通过使用对象来设计以及实现抽象数据类型。
新的类型能够让我们扩展可用的词汇量来解决新的问题。
在本节中，我们将会通过一个新的数值数据类型，来介绍扩展Python的实用技术。

你已经知道了，含有小数的数字通常用`float`数据类型来表示。
使用浮点数（`float`）的一个缺点是：
底层存储方式只是一个近似值，而不是精确值。
数字会首先被转换为二进制（基数2），因此不是以2的幂作为分母的任何分数，都将会转换成具有无限循环的商。
而当这个商数为了放进有限的存储器位置时，就会被截断，也就会丢失一些精度。
对于某些应用程序，最好能有一个可以直接操作分数的数据类型，这样可以准确地存储和使用诸如$\frac{1}{10}$这样的值。
那让我们用一个表示有理数（分数）的新的有理数（`Rational`）类来扩展Python语言。

### 运算符重载

抽象地来说，我们的有理数（`Rational`）类应该像数学中的有理数一样。
一个有理数有分子和分母，它们都是整数而且也能支持常用的数字运算。
所以，具体来说，我们将在新的有理数（`Rational`）类里实现有理数这个抽象数据类型。

在构建新的有理数（`Rational`）类的时候，我们希望让它的行为尽可能的和现有的数字类型一样。
通常来说，我们会用数学运算符，比如`+`、`-`、`*`和`/`来执行整数和浮点数的操作。
从技术上来讲，这些运算符在Python（以及许多其他语言）中被*重载*（*overloaded*）了，因为每个运算符都根据数字类型的不同被用来做不同的操作。
例如，运算符`+`能被用于整数的加法和浮点数的加法。
这个时候，执行的具体操作取决于操作的数字的数据类型。
在用加法运算符的时候，我们可能不会太注意到这些，但是在使用除法运算符的时候，我们就能发现他们之间很大的差异。 [^3]

> [3^] 在Python 3.0中，单斜杠（`/`）是浮点除法，而双斜杠（`//`）则用于整数除法。

在我们设计自己的类的有些时候，让新的数据类型能够使用已有的运算符是非常有意义的。
一些面向对象的语言（比如Python和C++）支持这样一种机制，它允许程序员使用现有的运算符调用新函数，从而可以将运算符重载，扩展到程序定义的新的类型。
而其他的一些语言，比如Java，则不支持这样的操作。

如果我们在不能重载运算符的语言里实现有理数（`Rational`）类的话，我们只能编写代码来实现`add`方法，然后使用语法`r3 = r1.add(r2)`来调用它，从而让两个有理数相加，然后把结果存储在`r3`中。
这本身并没有任何问题，但是只要有理数加法可以写成`r3 = r1 + r2`，我们会更熟悉这样的表示，而且它有更好的可读性。
所以，运算符重载并不是必需的，但如果使用得当可以提高可读性。
当然，如果使用不当，它也可能导致可读性降低。
想想看，如果有人编写的代码导致加法运算符实际上是让两个对象相减，或者去执行一些完全不相关的函数会意味着什么。

在Python里，通过定义以双下划线开头和结尾的特殊名称的方法，就能够在新类里重载某些内置的运算符。
*Python参考手册*里指定了可以扩展的完整运算符列表。
表2.1是其中的部分列表，可以为你自己的类提供运算符功能。
在这个表里我们可以知道，如果我们希望能够让类的实例能够被写为`c = a + b`，我们就需要在类里编写方法`__add__(self, other)`。
只要我们这样做了，代码`c = a + b`就会相当于`c = a.__add__(b)`。
在Python中，`a`和`b`不必是相同的数据类型，但在大多数情况下，他们应该是相同的数据类型。

表2.1：一些可以在Python类里重载的运算符方法。

### 有理数（`Rational`）类

使用Python的运算符重载，可以非常容易地让我们编写有理数类。
下面的代码显示了有理数（`Rational`）类的开始部分。
它实现了`__mul__`和`__str__`方法，还实现了除了`self`参数之外，支持零个、一个或两个参数的构造函数。
与之前一样，每个方法的先验条件和后置条件都被描述在文档字符串里。
这个示例里有两个实例变量：`num`和`den`。
要注意的是，`__mul__`方法会创建一个新的有理数（`Rational`）对象，而不会去修改`self`或`other`里的实例变量。
当重载运算符的时候，保留运算符的“标准”语义非常重要，也就是说它们都是在不修改原始数据的情况下去生成新值。
因为，当我们看到代码`c = a + b`的时候，我们并不认为会改变`a`和`b`的值！

```Python
# Rational.py
# demonstrates operator overloading

class Rational(object):
    def __init__(self, num = 0, den = 1):
        """creates a new Rational object
        pre: num and den are integers
        post: creates the Rational object num / den"""

        self.num = num
        self.den = den

    def __mul__(self, other):
        """* operator
        pre: self and other are Rational objects
        post: returns Rational product: self * other"""

        num = self.num * other.num
        den = self.den * other.den
        return Rational(num, den)

    def __str__(self):
        """return string for printing
        pre: self is Rational object
        post: returns a string representation of self"""

        return str(self.num) + ’/’ + str(self.den)
```

当然，完整的有理数（`Rational`）类应该为所有的基本数值操作，都实现相应的方法。
你可能会很想深入挖掘里面的细节从而完成这个类。
这是一个很好的想法，但是在这里，我们建议你能够先把下一节中的内容学会。

## 增量开发以及单元测试

正因为我们将程序开发分解成了一个一个单独的类，所以要是能够在每个类的开发之后都能测试它是否有效就很好了。
而且，如果我们可以边开发边测试正在开发的类，那就会更加方便。
在Python里，一种不错的用来测试正在开发之中的类的方法是：
交互式地在Python的命令行里进行测试。
比如，我们可以这样来测试有理数（`Rational`）类的乘法：

```Python
>>> from Rational import Rational
>>> r1 = Rational(1,2)
>>> r2 = Rational(1,3)
>>> print r1 * r2
1/6
```

像这样单独测试一个组件被称为*单元测试*（*unit testing*）。
通过测试单独的一个组件，我们可以很轻松地隔离出发生错误的位置。
一旦我们对每个组件都充满信心的时候，我们就可以开始将它们组合到一个系统里了。

交互式单元测试的一个问题是，每次修改了组件之后，我们都只能重头创建测试。
假设我们的乘法测试给了我们一个不正确的结果，我们就会回到代码里，找到错误，修复代码。
完成修复之后，我们只能重新输入这四行测试代码。
对于小型测试来说这是可以接受的，但是当测试变得更庞杂的时候，这样做就会变得非常繁琐。

交互式单元测试的替代方法是，把单元测试编写成一个可以在需要时运行的实际程序。
这是一个十分常见的任务，因此已经有许多的框架被开发出来了，这也就使得我们编写单元测试越来越容易了。
Python的库里包含了两个不同的单元测试框架：`unittest`和`doctest`。
Python的`unittest`模块基于一个流行的框架（通常被称为xUnit），这个框架已经被移植到了许多面向对象的编程语言之中。
我们在之后的单元测试示例里将会使用这个框架。
下面是一些使用`unittest`模块来测试我们这个简单的有理数（`Rational`）类的代码。

```Python
# test_Rational.py
# unittest example

import sys
import unittest

sys.path.insert(0, '..')
from Rational import *

class RationalTest(unittest.TestCase):
    def testConstructorOneInt(self):
        r = Rational(-3)
        self.assertEqual(str(r), '-3/1')

    def testConstructorTwoInt(self):
        r = Rational(3, 4)
        self.assertEqual(str(r), '3/4')

    def testMul(self):
        r1 = Rational(2, 3)
        r2 = Rational(3, 4)
        r3 = r1 * r2
        self.assertEqual(str(r3), '6/12')

    def main(argv):
    unittest.main()

if __name__ == '__main__':
    main(sys.argv)
```

虽然这个例子里的代码并不多，但是里面有些代码你以前可能并没有见过。
比如说，在代码顶部的`sys.path.insert`这句代码。
很多程序员都遵循创建一个名为`test`的子目录来包含测试代码的惯例。
这样能让程序的生产代码和仅仅是为测试而编写的代码分隔开。
依照这个约定，我们假设`test_rational.py`会放在这个子目录中，因而这个子目录会位于放置有理数（`Rational`）类代码的文件（`Rational.py`）的目录之下的一个级别。

当我们把测试代码放在它自己的一个目录里会导致一个问题，那就是当测试代码需要导入有理数（`Rational`）模块的时候，Python并不会知道应该在哪里去找到它。
Python通过搜索来查找模块的目录序列被称为*路径*（*path*）。
通常来说，这个路径会包含Python在系统目录中所存放的所有标准库模块，以及执行Python的本地目录。
因此，只要我们导入的是系统范围的模块或者是和正在运行的程序位于同一文件夹里面的模块，就都没有问题。
那么，为了让测试代码能够导入有理数（`Rational`）模块，我们就需要修改这个标准路径。
Python允许程序员把需要的路径插入系统模块`sys.path`里的列表之中。
它只是一个字符串列表，指定了Python模块所在的各种目录。
执行代码`sys.path.insert(0，'..')`会将`'..'`放在路径列表的最前面。
`'..'`是一个用来指示当前目录（顺便说一下，用`'.'`表示）的父级的约定。
这样就能允许测试代码在执行`from Rational import *`这一行的时候，能够在父目录中去搜索`Rational.py`文件。

这个测试代码的核心在于这一行`class RationalTest(unittest.TestCase):`定义的名为`RationalTest`的类：
这个声明表明了`RationalTest`类是继承自`unittest`模块中的`TestCase`类。
我们换一种说法：`RationalTest`类是`unittest`模块中定义的`TestCase`类的子类。
基于继承，`RationalTest`的任何实例也将是超类`TestCase`的一个实例。
你可以把`TestCase`的实例当作我们要运行的一系列测试。

`TestCase`超类为单元测试定义了许多非常有用的方法。
最常用的两个是`assertEqual`（也称为`failUnlessEqual`）和`assertNotEqual`（也称为`failIfEqual`）。
每个方法都接受两个用来测试相等性的参数，以及一个可选的用来显示测试失败时要显示的消息的第三个参数。
如果前两个参数不相等，则测试`assertEqual`会失败，而如果两个参数相等，则测试`assertNotEqual`会失败。
`TestCase`类还支持很多其他的测试方法，你可以通过查阅`unittest`的文档来了解这些方法。

回到我们的`RationalTest`类里，当测试代码运行的时候，`unittest`框架将会自动调用以`test`这四个字母作为开头的所有方法。
单元测试的思想是编写方法来测试你所有的代码。
因此，你会发现测试代码里的方法甚至比`Rational`类里的方法还要多。
这是一个很常见的现象，因为只靠一个测试通常来说并不能确保函数/方法的正常工作。
要运行这些测试，我们只需要调用`unittest`模块里的`main`函数就行了。
这个函数会自动创建文件里的所有测试类（所有`unittest.TestCase`的子类）的实例，然后执行每个测试方法。
要注意的一点是，每个测试方法都会使用一个“全新”的测试用例来运行，因此每个测试都是相互独立的。
也就是说，测试运行的顺序对测试的结果没有任何影响。

下面这个输出，是所有测试都通过时`test_Rational.py`测试代码的输出：

```Python
...
----------------------------------------------------------------------
Ran 3 tests in 0.001s

OK
```

那三个点表明了我们三个测试方法的结果。
点代表测试成功完成了。
而如果测试代码发生了未处理的异常，则结果为“E”，“F”则说明测试里的验证失败了。

当然，当测试失败的时候，结果会更有趣。
比如，我们修改了`__mul__`方法，那一行代码现在成了`den = self.den * other.num`。
当我们再一次执行测试程序的时候，我们就会得到下面这个输出。

```Python
..F
======================================================================
FAIL: testMul (__main__.RationalTest)
----------------------------------------------------------------------
Traceback (most recent call last):
    File "./test_Rational.py", line 39, in testMul
        self.assertEqual(str(r3), '6/12')
    File "/usr/lib/python2.2/unittest.py", line 286, in failUnlessEqual
        raise self.failureException, \
AssertionError: '6/9' != '6/12'

----------------------------------------------------------------------
Ran 3 tests in 0.004s

FAILED (failures=1)
```

这时你应该能发现，输出结果的最上面的状态行显示第三个测试失败了，之后打印了一个回溯，来说明是哪一行导致了这个测试的失败。

以这种方式进行编码单元测试提供了诸多好处：
最明显的是，它能够允许在我们在修改代码的时候很简单的来运行测试。
因为，我们可以保存所有的测试，之后只要我们对代码进行了任何更改，我们都能够轻松地重新运行所有测试，甚至是之前已经通过了的测试。
让修改过的程序去运行之前已经成功的测试被称为*回归测试*（*regression testing*）。
回归测试有助于确保程序在开发的时候，是在不断地改进的（也就是说，新的修改没有破坏掉之前的功能）。

在编写一个类的同时去编写单元测试的另一个好处是：它们可以帮助我们去完成类的设计。
测试代码代表了应该如何去使用这个类，编写测试有助于帮我们确定我们的类是不是具有良好的设计而且易于使用。
当前，一些现代的软件开发方法都主张*测试驱动开发*（*test-driven development*）。
测试驱动开发代表着，在将任何实际生产代码被添加到系统之前，首先添加的会是测试代码。
按照这样一个流程，每个功能/方法被添加的时候，它都能够被立刻的测试。
在编写下一个函数/方法之前，你就可以确定这个函数/方法是不是能够正常工作了（通过这部分代码的测试）。

我们认为测试驱动开发是一种非常好的技术。
因此，我们建议你在编写一个新类的时候，一开始在每个方法里只使用`pass`语句；
然后，去编写其中一个方法的测试代码，接下来再去这个类里实现这个方法从而让它能够通过测试；
之后，不断地去重复编写新的测试和修改类的这一个过程，直到完成整个类并且通过所有的测试。
每次对类进行修改的时候都应该能够通过所有的已经存在的测试，这样会让你在尝试新的设计理念时充满信心。
像这样的测试框架有助于让我们对实现独立性这一承诺成为现实。
而且你会惊讶地发现，通过编写实现代码然后测试这样一前一后地流程来完成程序编码是多么的快速。

## 章节总结

这一章里，我们介绍了数据抽象和面向对象编程的基本思想。
下面是关于这些关键思想的摘要。

* 抽象数据类型（ADT）定义了一个独立于实现来操作数据的API。
在面向对象语言中，ADT通常使用类来实现。

* 封装，多态和继承是面向对象的代码里所使用的定义技巧。

* 设计一个类和实现它既是艺术也同时是科学。
一个普遍的规则是研究问题描述并且将名词识别为类，以及把动词当作方法。

* 运算符重载允许程序员定义一些方法，从而当内置运算符（如+， - ，<，>等）和程序员定义的类的实例一起使用可以被调用。

* 单元测试允许单独测试程序的各个部分。
单元测试的框架可以让我们方便地编写自动化单元测试，从而在编写代码的时候能够对代码进行测试。
回归测试可以帮助我们保证代码的修改不会“破坏”程序里以前能够正常工作的组件。

* 测试驱动开发是一种常见技术，它代表着在编写实现该功能的生产代码之前，应该为每一个新功能先编写测试代码。

## 练习

**判断题**

1. 在Python里，必须使用类来实现一个抽象数据类型。

2. 如果编程语言支持类，那么在实现抽象数据类型的时候通常应该使用类。

3. 类变量可以被类的所有实例所共享。

4. 在设计程序的时候，一种定位潜在对象的方法是在系统描述里查找动词。

5. *封装*（*Encapsulation*）是指将数据和方法组合成一个句法单元。

6. 通过使用多态，程序员将会编写多路`if`语句来查验对象的类型，从而确定应该调用哪一个方法。

7. 子类会继承其超类中定义的方法。

8. 运算符重载能够允许程序做一些在没有运算符重载的情况下不能做的事情。

9. 要在Python中重载运算符，就必须使用类。

10. 每次修改类的时候，都应该执行所有的单元测试。

**选择题**

1. 在开发大型软件系统的时候，你应该：

    a) 马上坐下来，开始编写代码。

    b) 设计系统的一部分，编写一部分代码，在需要的时候重新设计这部分代码，并且在编写代码时测试这部分组件。

    c) 在编写任何代码之前先设计整个系统。

    d) 在测试任何代码之前先实现整个系统。

2. 程序描述里的哪些部分对于找到系统设计时的可能的对象最有帮助？

    a) 形容词

    b) 名词

    c) 动词

    d) 以上所有内容

3. 程序描述里的哪些部分对于找到系统设计时的可能的方法最有帮助？

    a) 形容词

    b) 名词

    c) 动词

    d) 以上所有内容

4. 如何分别方法里的实例变量和本地变量？

    a) 实例变量是特定对象的数据的一部分，并且在多个方法里都是必需的，而本地变量仅仅在该方法里被需要。

    b) 一个类应该永远不使用本地变量；方法中使用的所有变量都应该是实例变量。

    c) 一个类应该永远不使用实例变量；方法中使用的所有变量都应该是本地变量。

    d) 实例变量只应该被用于常量。

5. 如果你正在检查其他人编写的Python类，你应该如何确定一个变量是本地变量还是实例变量？

    a) 在多个方法里都使用了相同的变量名。

    b) 通过在变量名前前置`self.`来访问这个变量。

    c) 在`__init__`方法里用到的变量。

    d) 实例变量总是以下划线开头。

6. 在什么时候应该使用类变量？

    a) 当类的每个实例都需要自己的数据副本时。

    b) 当类的每个实例可以共享相同的数据副本时。

    c) 数据是个常量时。

    d) 选项b)和c)。

7. 如果需要设计一个表示多项式的类，以下哪个应该是实例变量？

    a) 系数。

    b) 用于多项式计算的值。

    c) 多项式依照某个特定值计算出的结果。

    d) 以上所有内容。

8. 如果需要设计一个表示多项式的类，以下哪个应该是类变量？

    a) 系数。

    b) 用于多项式计算的值。

    c) 多项式依照某个特定值计算出的结果。

    d) 以上都不是。

9. 在使用Python的`unittest`框架编写单元测试时，测试代码的编写会？

    a) 有许多功能。

    b) 有一个单独的类，它是你的类的子类。

    c) 有一个单独的类，它继承子`unittest.TestCase`。

    d) 属于正在被测试的类的一部分。

10. 单元测试的目的是什么？

    a) 帮助思考你的设计。

    b) 帮助在代码中发现错误。

    c) 允许在每次修改代码时轻松地测试代码。

    d) 以上所有内容。

**简答题**

1. 类的*接口*（*interface*）和类的*实现*（*implementation*）有什么区别？

2. 在编写类的代码之前编写单元测试代码的原因是什么？

3. 在编写类的代码时同时编写单元测试代码的原因是什么？

4. 在编写类的代码之后编写单元测试代码的原因是什么？

5. 如果实例变量和方法使用了相同的名称，Python会怎么处理？
写一个简短的例子来试试吧。

6. 为用来模拟一整套扑克牌的`Deck`类提供两个不同的规范（列出各个实例变量和方法名称，但不用实现方法），包括为了要模拟纸牌游戏，所需要使用的各个方法。

7. 在一个玩tic-tac-toe的程序里，哪个类或哪些类可能会有用？
你的类应该包含哪些实例变量和哪些方法？

8. 编写单元测试有什么好处？

9. 运算符重载的目的是什么？

**编程练习**

1. 编写2.3节里的扑克牌（`Card`）类的单元测试代码。

2. 使用2.3.3里讨论的另一种存储方式来实现扑克牌（`Card`）类。
用上一个练习里的单元测试来对其进行测试。

3. 写一个扑克牌组的简单实现来随机发牌。
这个扑克牌组（`Deck`）类应该包含一个扑克牌对象的列表。
一开始的时候，扑克牌组里会包含全部52张可能的扑克牌的实例。
你的扑克牌组应该实现一个叫做`deal()`的方法，它会从列表中选择一个随机位置并“弹出”这张扑克牌。
你还应该实现一个叫做`cardsLeft`的方法，这个方法可以告知牌组里剩下的牌数。
要注意：在第3章里，我们实现了一个更复杂的Deck类。
不要直接使用那个设计。

4. 使用上一个练习中的扑克牌组（`Deck`）类，编写一个让两个玩家玩二十一点的程序。

5. 使用练习3里的扑克牌组（`Deck`）类，编写一个简单的玩单人纸牌游戏的程序。
游戏首先从扑克牌组的面朝上的发出几张扑克牌。
之后，如果有两张牌具有相同的数字，则从牌组里再面朝上发出另外两张牌。
重复这一过程，直到所有的牌都被发出，或者没有相同的数字的扑克牌。
如果已经发出了所有牌，则玩家“获胜”。
你的程序应该能够让用户选择用于游戏开始的牌数，然后模拟整个过程直到游戏结束。

6. 修改上一个练习，从而计算任何给定数量的牌数的获胜概率。

7. 使用本章里建议的两个具体存储方法来各自实现一个`DataSet`类。
需要包含测试所有方法的代码。

8. 编写这样一个程序，它能够让两个玩家在电脑上玩奥赛罗（也称为黑白棋）游戏。
如果你对这个游戏并不熟悉，你可以上网搜索相关的游戏规则。
你可以通过创建这样一个类来设计你的程序：
这个类能够用来记录棋盘上的各个棋子，并提供判断这一步棋是否合法的方法，根据合法的棋步来更新棋盘，以及（以文本或图形方式来）显示棋盘。
同时，这个类还应该提供一个用于确定棋盘上每个位置的棋子的方法。

9. 为你的奥赛罗/黑白棋类编写单元测试，从而测试检查合法的棋步的方法以及能否根据合法的棋步来更新棋盘。

10. 完成有理数（`Rational`）类，使得它能够支持加号运算符，减号运算符，除法运算符和六个比较运算符，并且编写单元测试类来测试所有方法。
在这里，比较运算符应返回`True`或`False`。
如果你能够让你的类始终以简化形式存储分数的话，可以获得奖励积分。（提示：在类的构造函数里使用欧几里德的最大公约数（Euclid's GCD）算法。）

11. 用有理数（`Rational`）类来编写一个理解古埃及分数的程序。
古埃及分数是不同的单位分数（也就是分子为1，分母为各不相同的正整数）的和。
比如$\frac{7}{8}$可以被表示为这样的和：$\frac{1}{2} + \frac{1}{3} + \frac{1}{24}$。
你的程序要能够让用户输入任意分数，然后输出相应的古埃及分数。
你可以先进行一些研究来找出相应的转换算法。

12. 编写一个类来表示多项式。
这个类应该保存一个系数的列表以及多项式的次数。
编写相应的加法，减法和乘法方法。
编写`__str__`方法来以字符串的形式返回多项式。
再提供一个方法来计算在某个特定值处的多项式的结果。
同时，为这个多项式类编写相应的单元测试。

# C++的动态内存

目标

* 了解C++的指针和Python的引用之间的相似点和不同点。

* 了解如何使用C++的运算符来访问内存地址以及解引用指针。

* 了解如何在C++里动态分配和释放内存。

* 学习如何使用C++来编写动态分配和释放内存的类。

## 简介

就像在前面的章节里已经简单提到过的那样，Python和C++在变量和名称里用来存储数据的内部机制是不同的。
在这一章里，我们将会去详细讨论这一部分的差异。
虽然C++默认的存储变量的机制和Python不一样，但是C++也支持类似于Python的引用这样的指针变量。
C++程序员可以根据他们所需要的效率以及功能来选择使用哪一种机制。
C++的指针将能够让我们灵活地把内存分配的时间延后到运行的时候再做决定。
这样做就能够在运行时更改数组的大小，以及可以在C++里创建链式结构。
使用C++的指针的时候相比在使用Python的引用的时候需要更加小心，因为使用指针的时候很容易出错，从而得到一个可以产生意外结果或者会崩溃的程序。
这一章和下一章将会介绍动态内存和指针的使用。
我们先回顾一下Python和C++的基本内存模型。

Python的名称是对内存地址的引用，这个内存地址存储了实际的数据、类型的信息以及引用的计数；
不同的名称可以引用相同的数据对象，同时赋值语句能够让名称去引用不同的数据对象。
C++则是把内存的地址与每个变量进行了关联（绑定），并且在变量的整个生命周期中将相同的内存地址用于这个变量。
并且，每个赋值语句都会把不同的数据存储到被绑定的变量的内存地址里去。
下面是一个C++的例子：

```C++
// memory.cpp
#include <iostream>
using namespace std;

int main()
{
  int x, y, z;
  x = 3;
  y = 4;
  z = x;
  x = y;
  cout << x << " " << y << " " << z << endl;
  return 0;
}
```

下面这个表格展示了这个程序执行的时候的内存情况。
当`main`函数开始执行时，每一个整数变量（一共三个）都会被分配到四个字节。
在我们这个表格里，我们用内存地址1000来作为开头，但是这个特定的内存地址并不重要，而且在每次运行程序的时候，它都会不一样。
这里需要注意的关键点是：用于每个变量的内存地址是不会改变的；存储在内存地址的数据则会随着为变量赋上不同的值而改变。
就像你可以看出来的，这个程序的输出是`4 4 3`。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | x | 先是3后面被替换为4 |
| 1004 | y | 4 |
| 1008 | z | 3 |

于此相对应的，这个程序的Python版本是这样的：

```Python
# memory.py
x = 3
y = 4
z = x
x = y
print x, y, z
```

虽然内部的存储方式是不同的，但是通过对比可以看出来，用C++的变量的代码与对不可变类型的Python的引用的最终结果是相同的。
Python的程序也会输出`4 4 3`。图10.1展示了这个Python代码的内存的图形表示。
这里要注意的关键点是，在固定的存储地址有对象`3`的一个​​副本和对象`4`的一个​​副本；
名称会引用这些对象，而且当代码在执行的时候，`x`所引用的内存地址会从`1000`变为`1012`。
在程序的最后，我们会有多个名称引用着相同的内存地址。
在这里，我们没有显示对象的引用计数和类型信息，但是每个Python的整数对象在32位系统里，都会需要12个字节来存储所有的信息。

图10.1：Python内存引用的图片

因此，我们可以看到，Python和C++之间的重要区别是：

* 每个C++的变量都对应于一个固定内存地址来存储数据；
每次为这个变量赋新的值的时候，存储数据的内存地址都是相同的。

* Python的名称引用着内存里的对象。
Python的对象还必须要同时存储有关于它的类型和引用计数的信息，因此在Python里存储数据会比在C++里存储相同数据需要更多空间。

* 为Python的名称分配一个对象会修改引用，因此它会引用另一个别的对象（也就是名称引用的内存地址会被修改）。

* Python里可以有多个名称引用相同的对象。
通过一个名称来修改一个可变对象会影响其他的名称。
在C++里，每个变量都有自己的固定地址，因此修改一个变量不会影响到其他变量。

* C++也支持引用，但它们并不常用。
C++也支持更常用的指针，指针将能够允许我们执行与Python的引用类似的操作。

当你直接修改一个可变类型而不是把变量赋给一个新的或者是另一个对象的时候，在使用引用的Python和把实际数据存储在变量的C++之间的区别就会非常明显。
我们将使用之前章节里介绍过的`Rational`类来展示这个区别。
我们将研究相对应的Python和C++代码片段：

```Python
# Python code
r1 = Rational()
r1.set(2, 3)
r2 = r1
r1.set(1, 3)
print r1
print r2
```

```C++
// C++ code
Rational r1, r2;
r1.set(2, 3);
r2 = r1;
r1.set(1, 3);
cout << r1 << endl;
cout << r2 << endl;
```

先假设我们已经为我们的类定义了适当的方法。
Python以及C++里的`set`方法分别是：

```Python
# Python code
    def set(self, num, den):
        self.num = num
        self.den = den
```

```C++
// C++ code
void Rational::set(int n, int d)
{
  num_ = n;
  den_ = d;
}
```

在Python里，就像下面这个表格里显示的一样，`r1`和`r2`都会指向我们假设存储在内存地址`1000`里的相同对象。
我们前面提到过Python需要额外的内存来存储有关对象的数据类型和对象的引用计数的相关信息，但是在这里，我们不会在表格里包含这部分的信息。
因为我们创建的`Rational`对象有`num`和`den`两个实例变量，所以在变量名称这一列我们使用了`Rational`对象的实例变量名称。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `.num` | 对`2`进行引用，之后引用`1` |
| 1004 | `.den` | 对`3`进行引用 |

如果你回忆一下4.2节里的内容，你就能够理解这段Python示例代码将会同时修改掉两个名称所共同引用的这个`Rational`对象。

于此对应的C++的声明将会导致创建了两个`Rational`对象：`r1`和`r2`，也就是说会像下面这个表格展示的那样，需要分配一共16个字节的内存。
因为有两个`int`实例变量，而每个`int`变量需要四个字节，所以每个`Rational`对象都会需要八个字节。
C++里并不需要额外的内存，这是因为C++的运行时环境不需要去追踪数据类型和引用的计数。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `r1.num` | `?` |
| 1004 | `r1.den` | `?` |
| 1008 | `r2.num` | `?` |
| 1012 | `r2.den` | `?` |

在语句`r1.set(2, 3)`之后，内存会存储：

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `r1.num` | `2` |
| 1004 | `r1.den` | `3` |
| 1008 | `r2.num` | `?` |
| 1012 | `r2.den` | `?` |

除非我们在C++的`Rational`类里定义了我们自己的`operator=`运算符重载（我们将在10.4.3小节里讨论这部分内容），否则当执行`r2 = r1`时，会相当于`r2.num = r1.num`和`r2.den = r1.den`这两个语句的执行。
在代码里，因为实例变量是私有的，所以我们并不能直接显式地编写这两个语句，但是编译器会自动生成能够执行这两个赋值语句的代码。
因此，这样将会让我们能够把存储在内存地址`1000`里的数据复制到内存地址`1008`去，并且存储在内存地址`1004`的数据也会被同时复制到内存地址`1012`里。
下面这个表格展示了这个赋值语句之后的内存情况。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `r1.num` | `2` |
| 1004 | `r1.den` | `3` |
| 1008 | `r2.num` | `2` |
| 1012 | `r2.den` | `3` |

在语句`r1.set(1, 3)`之后，现在内存会是：

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `r1.num` | `1` |
| 1004 | `r1.den` | `3` |
| 1008 | `r2.num` | `2` |
| 1012 | `r2.den` | `3` |

和Python版本不同的是，`r1`和`r2`现在拥有不同的值了，因此`r1`的输出将会是`1/3`，而`r2`的输出则会是`2/3`。
如果把我们的代码改成执行`r2.set(1, 3)`语句的话，那么`r1`的输出会是`2/3`，而`r2`的输出是`1/3`。
Python和C++之间的区别在于，C++里每个声明的变量都有它自己的内存地址来存储实例变量，并且将一个变量赋值给另一个变量的时候会复制数据。
然而Python里将一个名称赋值给另一个名称将会导致两个名称都引用向同一个对象。

这些不同的用来管理内存的机制各有优劣。
Python的机制将能够允许动态类型并且直接支持链式结构。
但是，因为我们必须将标识符名称存储在一个字典里（引用），还需要存储包含类型信息和引用计数的实际数据。
总的来说，Python会使用更多的内存。
此外，它还需要进行两次内存访问才能获取给定Python名称的数据。
而C++的机制将会使用更少的内存，而且总是能够更快的访问数据。
Python会在两个名称上进行赋值，并且这些名称是具有大量数据的类的时候更快。
C++直接提供了深拷贝，而Python则会去引用相同的数据。
因此，对于类对象来说，Python的赋值会更快，但它和C++并不是执行的是相同操作。
这就是为什么，即使我们不想修改变量里的数据，类的实例的变量在C++里还是通常会通过引用进行传递的原因。
正如我们提到过的那样，当我们不想修改数据的时候，应该使用`const`来指定这个参数，从而编译器会保证我们的代码不会去修改这个变量。
计算机科学家们用用术语*引用语义*（*reference semantics*）来描述Python的赋值语句是如何工作的，因为它会创建另一个引用，同时会用术语*值语义*（*value semantics*）来描述C++的赋值语句是如何工作的，因为它会复制整个变量的值。

Python的内存管理机制被称为*隐式堆动态*（*implicit heap dynamic*）。
Python解释器会根据需要去自动分配和释放内存。
一段被称为*动态内存堆*（*dynamic memory heap*，有时会简称为*堆*，*heap*）的内存被用于这些分配和释放。
C++的默认内存管理机制被称为*堆栈动态*（*stack dynamic*）。
当函数被调用的时候，变量所需的内存会在堆栈上被分配。
而且，因为在大多数情况下，我们可以在编译时就确定所有的局部变量所需要的内存大小，所以可以直接使用机器语言指令来分配整个堆栈上的空间。
当函数结束之后，堆栈会缩小回函数调用之前的大小，从而有效地释放本地变量的内存。

堆栈动态技术的一个缺点是：它不直接支持链式结构。
另一个缺点是在第一次分配之后，我们不能去修改为一个变量已经分配了的内存量。
在大多数情况下，在编译时就会确定需要为一个变量所分配的内存量；而我们曾经看到过的一个例外是，在第8.11节里提到过的可变长度的数组。
在这种例外里，分配的内存量不是在编译时被确定的，但是一旦整个分配结束之后，我们就不能再去用相同的变量来让数组变得更大了。
因此，这使得基于堆栈动态的数据结构是不能像Python的内置列表那样，根据需要进行增大的。

你可能已经想到了，C++肯定会支持另一种为变量分配内存的机制，这是因为Python的解释器是用C语言编写的。
这个C++的另一种机制被称为*显式堆动态*（*explicit heap dynamic*）。
就像Python那样，一段被称为*动态内存堆*（*dynamic memory heap*，简称为*堆*，*heap*）的内存将会被用于内存的分配和释放。
但是，就像这个术语：显式堆动态所暗示的那样，在C++里，你的程序代码必须要包含这些直接分配和释放内存的指令。
C++使用了指针变量来支持这种动态的内存分配和释放。
通过使用C++的指针，可以在运行时（而不是在编译时决定内存数量）能够让我们决定以及更改分配的内存量的代码。
因此，我们可以使用C++的指针来编写可以根据需要而增大的数据结构，以及各种链式结构。
这一章将会探讨如何使用C++的指针，它们与Python的引用是如何类似，以及如何编写使用动态内存的C++类。
我们将在第11章里学习如何用C++编写链式结构。

## C++的指针

在C++里，*指针*（*pointer*）变量被用来存储内存地址。
C++要求使用特定的类型来定义指针。
这个类型被用来指示需要如何去解释内存地址里的数据。
我们已经知道了，在计算机的内部，内存存储的是1和0，而C++的变量的类型将会告诉编译器它所生成的代码应该如何去解释这些比特数据。
同时，由于指针变量被用来存储的是内存地址，因此所有的指针变量都会需要相同的内存空间（32位系统上的四个字节）。
这就有点像是Python里的引用了。
C++的指针是一个类似于Python的引用的概念。
它们的区别在于：
使用C++的指针，你可以访问指针指向的地址以及数据（也就是这个内存地址处的数据）；
而Python的引用则只能让你去访问引用所指向的数据。

C++的指针通过使用星号（`*`）作为变量名的前缀来进行声明。
加上星号将代表着这个变量将会保存存储指定类型的数据值的内存地址的地址。
当你想在一个定义语句里声明多个指针的时候，一个常见的错误是忘记在每个变量名之前都加上星号。
在下面的这个例子里，`b`和`c`将会被声明为指向`int`类型的指针，而`d`则会被声明为`int`类型。
这个代码片段里的第二行也是合法的，但是我们并不建议你使用这种风格。
在单词`int`之后跟着放置一个星号，会使得这条语句看起来像是，它里面的所有变量都是指向`int`类型的指针，但是，实际上只有`e`是指针而`f`是一个`int`类型。
因为`int`类型和指针类型都需要四个字节，因此这个例子一共会分配20个字节。

```C++
int *b, *c, d; // b and c are pointers to an int, d is an int
int* e, f; // only e is a pointer to an int, f is an int
```

接下来，你应该思考的下一个问题是我们应该怎么在指针变量里去存储地址。
我们并不知道我们的程序被允许使用哪些内存地址，因此我们必须要去请求一个有效的地址。
一种方法是使用现有变量的地址。
下面的例子里展示了这一方法，同时这个例子还向我们展示了如何去访问指针变量所指向的数据。

```C++
// p1.cpp
#include <iostream>
using namespace std;

int main()
{
  int *b, *c, x, y;
  x = 3;
  y = 5;
  b = &x;
  c = &y;
  *b = 4;
  *c = *b + *c;
  cout << x << " " << y << " " << *b << " " << *c << " ";
  c = b;
  *c = 2;
  cout << x << " " << y << " " << *b << " " << *c << endl;
  return 0;
}
```

一元符号`&`运算符会计算它所对应的操作数的地址。
因此，语句`b = &x`将会让程序把`x`的内存地址存储到变量b的内存里。
下面这个表格展示了计算机使用了从`1000`到`1015`的内存地址来存储我们的变量，而且，还显示了在执行了`c = &y`语句之后的每个变量的值。
与之前类似的，计算机并不一定会使用从`1000`开始的地址，但在这本书里的示例里，我们会使用这个地址。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `b` | `1008` |
| 1004 | `c` | `1012` |
| 1008 | `x` | `3` |
| 1012 | `y` | `5` |

一元符号`*`运算符被用来当作指针的*解引用*（*dereference*）。
解引用一个指针是指访问这个指针所储存的内存地址处的数据。
语句`*b = 4`会让程序把数据值`4`存储在内存地址`1008`里（因为`b`当前的值是`1008`）。
在阅读下一段之前，看看你能不能根据这些知识来确定那个示例程序的输出。

语句`*c = *b + *c`将会得到内存地址`1008`（`b`指向的地址）和内存地址`1012`（`c`指向的地址）的整数值，并且将`4`和`5`加在一起。
之后，会把结果`9`存储在内存地址`1012`（`c`指向的地址）处。
语句`c = b`则会把`b`的数据值（地址`1008`）复制到`c`的内存里（也就是说，`1008`会被存储在内存地址`1004`里）。
你需要注意的是，对指针变量进行赋值和在Python里对两个名称进行赋值是基本上一样的；
`b`和`c`现在都会指像相同的数据。
通过这部分段落里的知识，你应该能够知道，这个程序的输出会是`4 9 4 9 2 9 2 2`。
在`*c = 2`语句之后，内存的情况将会是：

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `b` | `1008` |
| 1004 | `c` | `1008` |
| 1008 | `x` | `2` |
| 1012 | `y` | `9` |

需要理解的另一个你可能已经发现了的重要概念是：指向`int`的指针和`int`类型并不是同一个类型。
继续使用之前那个例子的变量声明的话，语句`b = x`和`x = b`都是不合法的。
因为变量`b`是指针，所以必须给它赋地址的值，而`x`是一个`int`类型，因此只能给它赋整数值。
如果我们使用另一种类型（比如说`double`）来声明指针变量的话，这个现象会更明显，因为在32位系统里，它们用了不同数量的内存。
不论对于哪一种类型，指向这个类型的指针和实际的类型都不是兼容的数据类型。

我们现在将编写一个更具有实际意义的例子来展示取地址运算符和解引用运算符。
C语言不像C++语言那样支持按引用传递，因此在使用C语言的时候，想要能够修改实参的唯一方法就是使用指针。
相应的技术方法是传递实参的地址，然后让函数或方法取解引用这个指针，从而能够修改与形参对应的内存地址处的值。
你也可以在C++里执行这样的操作，但程序员们通常会使用按引用传递来完成这项操作。
下面这个例子展示了交换两个整数变量的`swap`（交换）函数。

```C++
// swap.cpp
#include <iostream>
using namespace std;

void swap(int *b, int *c)
{
  int temp = *b;
  *b = *c;
  *c = temp;
}

int main()
{
  int x = 3, y = 5;
  swap(&x, &y);
  cout << x << " " << y << endl;
  return 0;
}
```

形参`b`和`c`分别传递了变量`x`和`y`的内存地址。
因此，赋值语句`*b = *c`相当于在`main`函数里直接写`x = y`。
你可以看到这两者之间的相似性以及通过引用进行的传递。
如果我们将代码行`b = &temp`添加到`swap`函数的末尾会发生什么呢？
它会改变`x`吗？
事实上，这个语句将不会对`x`有任何影响。
变量`b`将会被修改为保存`temp`变量的地址，但是这并不会修改`x`变量或者是与`x`变量所对应的内存地址的值。

在我们的这些例子里，我们使用了一元符号`&`运算符来给指针变量赋一个有效地址的值。
另一种可以把指针设置为指向一个有效地址的方法是`new`语句。
C++的`new`语句被用来从堆里分配一块动态内存，并且返回这个分配的内存的起始地址。
使用`new`语句的时候，必须要指明想要分配的对象的数据类型；这是因为指定的数据类型将会被用来确定需要分配的内存大小。
在C++里显式地分配了内存之后，在不再需要这部分内存的时候，你就必须要去释放内存。
`delete`语句将被用来释放这块动态分配的内存。
下面这个例子展示了在10.1节里编写的Python和C++程序的显式堆动态版本。

```C++
// p2.cpp
#include <iostream>
using namespace std;

int main()
{
  int *x, *y, *z;
  x = new int;
  *x = 3;
  y = new int;
  *y = 4;
  z = x;
  x = y;
  cout << *x << " " << *y << " " << *z << endl;
  delete z;
  delete y;
  return 0;
}
```

指针变量`x`、`y`和`z`都是堆栈动态变量，它们所需要的12个字节在函数一开始的时候就会被自动分配，之后在函数结束的时候会被自动地释放掉。
在下面这个表格里，我们使用了`1000`到`1011`的内存地址来表示这12个字节。
在`new`语句被执行的时候，会在内存地址从`2000`开始的动态内存堆里分配内存。
要注意的是，这段代码里，我们有两个`new`语句，因此我们必须要有两个与此对应的`delete`语句。
虽然我们没有在使用`new`和`delete`语句的时候使用一一对应相同的变量名，但是由`x = new int`语句分配的内存将会被`delete z`语句释放掉，这是因为`z`保存了这个`new`语句分配的内存地址。
类似的，`delete y`语句会释放`y = new int`语句分配的内存。
这个时候，我们其实还可以使用`delete x`而不是`delete y`来释放内存，这是因为`x = y`语句会让`x`和`y`储存相同的内存地址。
在这里需要记住的关键点是，每个被执行了的`new`语句，在后面都必须要有一个与此对应的`delete`语句，这个语句会被用来释放`new`语句所分配的内存。
如果你忘记这个`delete`语句的话，程序将会出现*内存泄漏*（*memory leak*）。
虽然有内存泄漏的程序可能不会崩溃，但是这样的代码通常也不会被认为是正确的。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `x` | 先是`2000`，之后为`2004` |
| 1004 | `y` | `2004` |
| 1008 | `z` | `2000` |
| 2000 | | `3` |
| 2004 | | `4` |

通常来说，你会像我们在10.1节里那样来编写这个程序，因为那样做的话效率会更高。
而且，这个使用了指针的代码版本需要更多的内存，并且在解引用指针的时候会需要计算机去访问两个内存地址（`cout<< *x`需要先访问内存地址`1000`，然后再去访问内存地址`2004`）。
这段C++版本的代码在内存的分配方式上是和Python版本类似的。
因此，你可以把这个版本代码的内存指示表格和图10.1里的内存图进行比较。
同时，这个例子也展示了Python的引用和C++的指针在本质上是相同概念的不同语法。

由于Python只会使用引用，因此它并不需要像C++里的指针那样，有解引用这样一个额外的语法。
在C++里把一个指针变量赋给另一个指针变量之后，它们就都会指向同一个值或者是对象。
通过使用指针，我们就可以在C++里去像Python版本一样地分配内存地方式来实现我们在这一章开头的那个`Rational`类的例子了。

但是，使用指针的话，访问类的实例成员时会有一个问题：点运算符（句点）的优先级会高于用于解引用的星号（一元的`*`符号）运算符。
这也就是说，如果我们有一个`Rational`类的实例`r`的话，我们就不能像`*r1.set(2,3);`这样来些代码了，我们应该去写成`(*r1).set(2,3)`这样的形式。
好在，C++还提供了一个额外的运算符，来让我们可以使用指针并且不用添加括号去访问成员；
这个符号是`->`（减号后跟一个大于符号）所以`(*r1).set(2,3)`就可以写成`r1-> set(2,3)`这样。
通常来说，会使用`->`这样的形式来写代码，而不会去用括号的版本。

与这一章前面的Python版本的`Rational`类相对应的使用C++的指针的C++代码就像下面这样：

```C++
Rational *r1, *r2; // constructors not called

r1 = new Rational; // constructor is called
r1->set(2, 3);
r2 = r1;
r1->set(1, 3);

cout << *r1 << endl;
cout << *r2 << endl;
delete r1;
```

因为`r1`和`r2`是指向了相同内存地址的指针，这个示例程序的结果是会把`r1`和`r2`都输出为`1/3`。
这个代码片段的内存表格会是这样：

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `r1` | 先是`?`，之后为`2000` |
| 1004 | `r2` | 先是`?`，之后为`2000` |
| 2000 | | 先是`2`，之后为`1` |
| 2004 | | `3` |

在`r1`和`r2`声明的时候，会为每个变量分配四个字节，这是因为指针需要四个字节。
而且，在声明指针的时候，是不会去调用`Rational`类的构造函数的，这是因为我们只是在创建指针，而并没有去创建一个`Rational`对象。
因此，`r1 = new Rational`语句将会导致八个字节被分配，因为这个实例有两个整数型的实例变量`num_`和`den_`，而它们总共需要八个字节。
`r1 = new Rational`语句还会让变量`r1`存储在的内存地址`2000`这个地方。
在`r1 = new Rational`语句被执行的同时，因为它创建了一个`Rational`对象，所以构造函数也会被调用。
接下来，`r1->set(2,3)`语句将会让`2`被存储在内存地址`2000`处，相应的`3`会被存储在内存地址`2004`处。

之后的`r2 = r1`这个语句，由于`r1`的值是2000，将会让`2000`被存储在内存地址`1004`上。
因此，现在我们就和我们的Python例子具有相同的内存结构了，也就是`r1`和`r2`都指向了相同的`Rational`对象。
而后，当我们执行`r1-> set(1,2)`语句时，我们并不会区域更改`r1`里的值，而是会去修改被存储在`r1`所指向的那个内存地址里的对象。
由于`r2`指向的是与`r1`相同的对象，因此我们可以得到和Python一样的结果。
当像我们这样的C++代码片段的函数执行结束的时候，声明的变量的内存地址（`1000`到`1007`）会像之前提到过的那样被自动释放，但是我们还需要`delete r1`语句来释放内存，由于使用`new Rational`语句，而显式分配的内存地址（`2000`到`2007`）。
因为`r1`和`r2`两个指针都指向了相同的地址，我们也可以使用`delete r2`来释放内存，但我们不能写成`delete r1; delete r2`这样，这是因为对于每个`new`语句来说，都必须有且只有一个相应的`delete`语句。
尝试在相同的内存地址再次去释放内存可能会破坏掉这个动态内存堆，从而导致程序崩溃。

在C++里，使用带有动态内存的指针可以为你提供像Python的引用那样的灵活性，但是，由于你需要去负责显式地处理内存的分配和释放，因此要比完成相同功能地Python版本的代码更难。
如果在使用动态内存的时候粗心大意的话，那么程序的每次运行都会产生不同的结果，甚至可能会整个都崩溃掉。
我们将在这一章里去讨论显式堆动态内存的这些问题。

## 动态数组

在第8.11节里，我们讨论了具有固定大小的内置数组数据结构。
然而多数情况下，我们在编译的时候并不知道数组的真实大小，或者我们会希望在程序运行的时候能够改变数组的大小，因此我们需要能够有一种可以在运行时分配指定大小的数组的机制。
就像我们在上一节里看到的那样，C++的指针可被用来*动态分配*（*dynamically allocate*）内存。
这也就意味着，分配内存是发生在程序运行的过程之中，也就是说可以在运行时，而不是在编译时，去确定需要分配的内存量。
下面这个代码片段展示了数组的动态内存分配以及释放：

```C++
int i, n;
double *d;

cout << "Enter array size: ";
cin >> n;

d = new double[n];
for (i = 0; i < n; ++i) {
  cout << "Enter number " << i << ": "
  cin >> d[i];
}
delete [] d;
```

这个例子让用户能够在运行的时候去指定数组的大小。
代码里的`new`命令将会分配指定的内存量，并且返回这些分配的内存的起始地址。
当在`new`语句里的数据类型之后使用了括号（`[]`）的时候，这个语句将会分配括号内指定的元素数量所需的内存量，并且返回起始地址。
在这个例子里，会在需要八个字节来存储`double`值的机器上分配$n * 8$个连续的字节。
在括号内的表达式代表的是需要分配的double类型的值的数量；
一个大小为`n`的数组被分配了内存，因此它的有效索引值就是$0$到$n - 1$。
在分配了动态内存之后，就可以用数组的括号表示法来访问它们了。
由于指针变量保存了连续内存段的起始地址，因此你可以用像第8.11节里讨论过的那种方法来计算数组索引。

当你动态分配了内存之后，就必须要在程序执行的后面的语句部分去释放这部分内存。
而由于我们是分配了一个数组的内存，因此当我们告诉`delete`语句释放内存的时候，需要告诉它是一个数组而不是保存单个值的内存。
因此，当分配和释放数组的时候，`new`语句和`delete`语句都必须要和方括号一起使用。
在释放动态数组的时候，不用去指示数组的大小;
C++的运行时环境会知道需要释放多少内存。
不断地分配内存然后忘记在C++程序里释放它们最终会导致程序占用计算机的大部分内存，从而导致计算机因为需要使用硬盘来获取额外的存储空间而变得越来越慢。
这就是为什么需要对不再使用的内存进行释放的很重要的原因。

使用动态数组的主要原因是你不需要在编译的时候就去知道数组的大小。
在很多情况下，你都不会事先知道首次分配这个数组的时候所需要提供的大小。
Python的内置列表能够允许你根据需要来添加任意数量的元素，因此在第一次分配内存的时候不需要去确定要分配的内存量；
也因为列表的不同使用场景会需要不同的大小，所以不可能提前就知道应该分配多少内存。
而一旦数组被填满了，我们就需要让这个数组变得更大。
但是，由于紧跟动态数组的内存可能已经被使用了（我们提到过，数组元素必须要在连续的内存地址），因此我们没办法让这个数组变得更大。
于是这一步的解决方案就是去分配一个新的更大的数组，再把原始数组里的值复制到新数组里去，最后删除原始数组。
下面这个代码片段展示了这一点：

```C++
int *data, *temp;
int i;

// create original array
data = new int[5];
for (i = 0; i < 5; ++i) {
  data[i] = i;
}
// create new larger array
temp = new int[10];
// copy from original array to larger array
for (i = 0; i < 5; ++i) {
  temp[i] = data[i];
}
// deallocate original array
delete [] data;
// make data point to new larger array
data = temp;
// now we can access positions 0-9
for (i = 5; i < 10; ++i) {
  data[i] = i;
}
// deallocate last allocation
delete [] data;
```

假设我们提供给局部变量的内存地址是从`1000`开始的，而动态分配的内存是从`2000`到`2019`的内存块（五个整数里的每一个都需要四个字节）。
那么在执行了第一个`new`语句和它后面的`for`循环之后，这段代码的内存表格就会像下面这样。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `data` | 先是`?`，之后为`2000` |
| 1004 | `temp` | `?` |
| 1008 | `i` | `5` |
| 2000 | | `0`|
| 2004 | | `1`|
| 2008 | | `2`|
| 2012 | | `3`|
| 2016 | | `4`|

在为`temp`指针分配了内存之后，将开始从原始数组里复制数据，并且把值`5`到`9`也存储到这个更大的数组里去。
那么假设从位置`3000`开始的内存会被用于`temp`指针，这个时候的内存表格会像下面这样。。

| 内存地址 | 变量名称 | 数据的值 |
| ----- | ----- | ----- |
| 1000 | `data` | `2000` |
| 1004 | `temp` | `3000` |
| 1008 | `i` | `10` |
| 2000 | | `0` |
| 2004 | | `1` |
| 2008 | | `2` |
| 2012 | | `3` |
| 2016 | | `4` |
| 3000 | | `0` |
| 3004 | | `1` |
| 3008 | | `2` |
| 3012 | | `3` |
| 3016 | | `4` |
| 3020 | | `5` |
| 3024 | | `6` |
| 3028 | | `7` |
| 3032 | | `8` |
| 3036 | | `9` |

在第一个`delete [] data`语句之后，位置`2000`到`2019`的内存将会被释放并且返回到动态内存堆，所以它可以在之后的情况下被再次使用。
后面的语句`data = temp`会让内存地址`1000`处存放值`3000`（也就是，`data`现在指向了后面那个更大的数组）。
在这个时候，`data`和`temp`都指向了同一个动态分配的数组。
这和在Python里对同一数据进行两次引用的概念是一样的。
在这个赋值语句之后，下一个循环将会把值`5`到`9`填充到内存地址`3020`到`3039`里去。
而最后的`delete [] data`语句则会去释放内存地址`3000`到`3039`的内存，从而让这部分内存可以被再次使用。

图10.2通过图片向我们展示了这个例子的内存。
图的上半部分显示了我们创建了一个新的更大的数组，并且把第一个数组进行了复制之后的情况。
图的中间部分则显示了第一个`delete [] data`语句之后的情况。
图的底部则显示了在最后的`delete [] data`语句被执行之前的内存状态。

图10.2：调整动态数组大小的图形表示

如果我们之后又填满了这个新的数组，于是又需要一个更大的数组的话，我们可以不断重复像这样再分配一个更大的数组，复制先前分配的数组里的值，然后删除先前的这个数组。
每次调整大小的操作都需要把先前的这个数组删除掉，只有这样，如果我们才能保证再执行了若干次这个调整大小的操作之后，也不会有内存泄漏。
在我们的例子里，`data`指针在最后会指向新分配的最后一个数组（在我们执行了`data = temp`语句之后）。
这种分配新的动态内存给另一个指针变量；把旧的值复制到新的内存里；释放旧的内存；以及最后把原始指针变量设置为新的内存地址的模式是C++动态内存里常见的模式。
因此，在继续阅读之后的部分之前，你要保证你完全理解了这个模式是如何工作的，以及为什么这些步骤的顺序非常重要的相关知识。
在下一节里，我们将使用一个类来验证这个模式。

## 动态内存类

当你编写一个通过指针的实例变量来动态分配内存的类的时候，你需要保证使用的内存能够被正确地释放掉。
因此，动态内存类必须要用另外三种C++方法来正确地分配和释放内存。
这三个方法分别是析构函数（Destructor），复制构造函数（Copy Constructor）以及赋值运算符（`operator=`）。
如果你的类不使用动态内存的话，那么就不需要编写这些方法。
如果要使用动态内存的话，这个类就必须要编写一个析构函数来释放内存。
而后两种方法可以在`private`部分来进行实现，或者是只声明它但不用去实现它。
在私有部分声明这些方法但不去实现它们会防止它们被调用。
我们将会在这一节里，讨论应该在什么时候去调用这些方法，以及它们必须要执行些什么操作的详细信息。
将它们正确地实现可以避免你的类发生内存泄漏或者其他的一些内存错误。

### 析构函数

就像前面我们讨论过的那样，在C++里，你必须显式地释放使用`new`命令显式分配的任何内存。
C++类里包含一个特殊的被称为*析构函数*（*destructor*）的方法，这个方法被用来释放内存。
析构函数方法和类的名称是一样的，不过它的前面会有一个波浪号（`~`）。
而且和构造函数没有返回类型一样，析构函数也没有返回类型。
析构函数的作用是用来释放类里面已经分配了，但还没有被释放的任何动态内存。
你永远都不用去通过这个方法名称来直接调用析构函数，因为当类的实例不在作用域范围里，或者是对指向这个类的实例的指针使用了`delete`运算符的时候，这个方法都会被自动调用。
如果你的类使用了动态内存并且没有析构函数的话，那么大多数情况下，你的代码就会有内存泄漏。

我们将从一个简单的动态数组类开始，通过在这一章里不断地扩展内容，来展示如何正确的编写动态内存类。
在这个类的第一个版本里，我们会在头文件里内联编写所有的方法。
我们也在实现里添加了一些输出语句，从而能够让你可以看到构造函数和析构函数被调用的情况。
这个`List`类会使用三个实例变量。
实例变量`data_`被用来保存包含列表元素的动态数组的起始地址。
`size_ instance`变量代表着列表里当前有多少个元素。
`capacity_ instance`变量则被用来表示这个动态数组有多大（也就是说，在动态数组需要调整大小之前，当前列表可以容纳多少个元素）。

```C++
// List1.h
#ifndef __LIST_H__
#define __LIST_H__

#include <iostream>

class List {

public:
  List(int capacity=10);
  ~List() { delete [] data_; std::cout << "destructor\n";}

private:
  int size_;
  int capacity_;
  int *data_;
};

inline List::List(int capacity)
{
  std::cout << "constructor\n";
  data_ = new int[capacity];
  size_ = 0;
  capacity_ = capacity;
}

#endif __LIST_H__
```

我们在头文件里没有添加`using namespace std`语句的原因和之前说的一样，还是因为如果这样做的话，包含这个头文件的任何文件都会有这个语句。
另外要注意的是，我们只需要把`size`参数的默认值放在`List`的构造函数的声明里就行了，而不用在构造函数的实现里包含它。
下面这个简单的程序展示了应该如何使用我们的类：

```C++
// test_List1.cpp
#include <iostream>
using namespace std;

#include "List1.h"

int main()
{
  List b;
  return 0;
}
```

编译并执行这个程序的话，会输出：

```
constructor
destructor
```

声明语句`List b`会激发构造函数的调用并且分配相应的动态内存。
当`main`函数的执行结束之后，就超出了变量`b`的作用域，因此析构函数会被自动调用，并且释放动态内存。
这也就是程序会输出这两行的原因。
下面这个程序也会产生相同的输出：

```C++
// test_Listp.cpp
#include <iostream>
using namespace std;

#include "List1.h"

int main()
{
  List *b; // constructor is not called here

  b = new List(20); // constructor is called here
  delete b; // destructor is called here
}
```

这个代码片段里的注释表示了构造函数和析构函数会在什么时候被调用。
之前提到过，声明语句`List *b`会分配用来存储要分配的地址的四个字节。
`new`语句通过调用具有指定大小的构造函数来创建`List`对象。
`delete`语句会调用`List`的析构函数，并且释放构造函数里分配的动态内存。
当变量`b`超出`main`函数的末尾的作用域的时候，就像内存里的任何超出作用域的变量一样，指针的四个字节将会被自动释放。
这也就是只有在类分配了动态内存的时候才需要编写析构函数的原因。

### 复制构造函数

顾名思义，复制构造函数是通过复制现有对象来创建新对象。
在C++里，当类的实例通过值传递来传递给函数或者是方法的时候，将会调用类的复制构造函数。
我们提到过，按值传递会创建实际参数的一个独立副本，而这就是原因所在。
你也可以在声明变量的时候直接调用复制构造函数，我们将在这一节的后面对这种用法进行展示。

除非你为一个类编写了复制构造函数，不然的话，C++编译器会为你生成默认的复制构造函数。
编译器创建的默认复制构造函数可以有效地把现有对象的每一个实例变量都会赋给新创建的对象里的相应实例变量。
对于不使用动态内存和指针的类，这就已经完成了你所想要的功能。
比如我们一直在讨论的`Rational`类。
要创建`Rational`对象的一个完整的副本，我们就需要去对它的分子和分母实例变量进行赋值，这也正是默认复制构造函数能够做的功能。

对于使用了动态内存的类来说，默认的复制构造函数将会创建动态分配数据的一个浅拷贝；
这两个实例里的指针变量将会引用相同的动态分配的内存部分。
这就会引起一系列的问题。
比如，当调用其中一个对象的析构函数时，它将会释放掉两个对象共享的动态内存。
另一个对象之后就不能再去合法地访问这些数据了，而且，在为这个对象调用析构函数的时候，它将会去尝试再次释放相同的内存。
内存被释放两次是非法的，将会出现内存损坏错误，从而导致程序会提供不正确的结果甚至是崩溃。
就像我们之前讨论过的那样，动态分配的每个内存都只能被释放一次。

我们将通过添加复制构造函数来继续扩展我们的动态数组类的例子。
由于复制构造函数也是一个构造函数，因此，它还是和类使用相同的名称。
而且，因为它被用来复制一个类的实例，所以我们必须要把这个实例作为参数传递进去。
我们提到过，当我们按值传递类的实例的时候，将会调用复制构造函数。
而如果复制构造函数参数是按值传递的，那么就需要再次调用自身来进行复制，从而会导致无限次地一直调用下去。
因此，必须让复制构造函通过引用来传递参数，从而避免这种情况的发生。
我们之前提到过，要通过引用来传递对象，那么唯一需要的就只是传递对象的地址而已。
我们曾经在10.2节里写的`swap`函数展示了引用传递的等价性。
下面的代码更新了动态数组类的头文件，在这个版本里，我们添加了复制构造函数：

```C++
// List2.h
#ifndef __LIST_H__
#define __LIST_H__

#include <iostream>

class List {

public:
  List(int capacity=10);
  List(const List &source);
  ~List() { delete [] data_; std::cout << "destructor\n";}

private:
  int size_;
  int capacity_;
  int *data_;
};

inline List::List(int capacity)
{
  std::cout << "constructor\n";
  data_ = new int[capacity];
  size_ = 0;
  capacity_ = capacity;
}

inline List::List(const List &source)
{
  int i;
  std::cout << "copy constructor\n";
  size_ = source.size_;
  capacity_ = source.capacity_;
  data_ = new int[capacity_];
  for (i = 0; i < size_; ++i) {
    data_[i] = source.data_[i];
  }
}

#endif __LIST_H__
```

就像代码里写的那样，复制构造函数的参数通过引用进行传递，并且指定了`const`，这些细节让这个方法不会需要去调用自身并且也不会更改现有的数据。
对于形参，你可以用任何的名称，但一个常见的约定是把它命名为`source`，这样做就可以表示这是你将要复制的类的源实例。
当引用`size_`的时候，这个时候，我们指代的是正在被创建的新对象的实例变量。
而当我们引用`source.size_`的时候，它指的是我们正在复制的对象的实例变量。
你可能觉得我们可以使用像`size_ = source.size_`这样的代码来引用其他对象的实例变量会非常奇怪，因为这个实例变量是私有的；
由于我们正在编写的是类的一个方法，因此被允许可以访问的不仅仅是调用它的实例，而且是所有的这个类的任何实例的私有数据。

对于非指针的实例变量来说，我们会希望为每一个实例变量都进行赋值，从而能够在新创建的对象里具有相同的大小和容量值。
在之后，我们还需要去分配一个具有相同容量的新数组，并且把源对象的数组里的元素都复制到里面。
这样的结果就会创建一个深拷贝。
可以看到，在代码里因为过去的值和对象并没有关系，我们只复制了当前的`size_`变量里的值，
在这个时候，我们还没有任何方法来向这个简化的类里放置元素，从而能够让`size_`变量大于零，但在我们的最终版本里，将会有相应的方法。
下面这个代码片段是一个使用这个类的复制构造函数的例子，它可以让我们了解到复制构造函数是在什么时候被用到的：

```C++
// test_List2.cpp
#include <iostream>
using namespace std;
#include "List2.h"

void f(List c)
{
  cout << "start f\n";
  cout << "end f\n";
}

void g(List &d)
{
  cout << "start g\n";
  cout << "end g\n";
}

int main()
{
  List b;
  f(b);
  g(b);

  List e(b);
  return 0;
}
```

这个程序的输出会像下面这样。
括号里的注释很明显并不是输出的一部分，我们用它来解释为什么这个方法会被调用的原因。

```
constructor (create b in main function)
copy constructor (create the copy c from b in f function)
start f
end f
destructor (destructor for c when function f completes)
start g
end g
copy constructor (create e in main function)
destructor (destructor for e or b)
destructor (destructor for e or b)
```

这段代码里要注意的第一个问题是，在调用函数`f`的时候，复制构造函数将会被隐式地调用。
复制构造函数会在函数开始执行之前就被执行，从而能够生成用于参数的副本。
当函数完成之后，将会自动调用析构函数，从而释放掉由复制构造函数动态分配的这部分内存。
而由于函数`g`是通过引用进行参数传递的，因此它不会去调用复制构造函数。
除此之外，当函数`g`完成的时候，也不会为`d`调用析构函数；
就算是要调用析构函数的话，我们也应该在`main`函数里为变量`b`去释放动态内存。
语句`List e(b)`显式地调用了复制构造函数来从现有对象`b`创建了`e`。
当`main`函数完成的时候，`e`和`b`都会执行析构函数从而释放它们的动态内存。
在调用析构函数的时候，你不能也不用去关心如何从`e`和`b`的顺序来知道调用的顺序。
你需要关心的是，当`main`函数完成的时候，两个对象都将会被正确的销毁就行了。
就像这个例子里展示的那样，如果正确地编写了每一个方法的话，那么调用构造函数，复制构造函数和析构函数的规则将能够正确地分配和释放内存。

就像我们前面提到的，你可以将复制构造函数声明为`private`，并且不去实现它。
这样做可以防止使用你的类的代码去执行复制构造函数；
相应的，那些代码将没办法通过值来把实例传递给函数或者方法，以及不能显式地去调用复制构造函数。
任何尝试执行这些操作的代码将导致编译器错误。
如果你的类使用了大量的内存的话，你可能会希望把复制构造函数标记为私有的，从而防止你的类的用户去复制它。
下面这个头文件展示了这一点：

```C++
// List3.h
#ifndef __LIST_H__
#define __LIST_H__

#include <iostream>

class List {
public:
  List(int capacity=10);
  ~List() { delete [] data_; std::cout << "destructor\n";}
private:
  List(const List &source);
  int size_;
  int capacity_;
  int *data_;
};

inline List::List(int capacity)
{
  std::cout << "constructor\n";
  data_ = new int[capacity];
  size_ = 0;
  capacity_ = capacity;
}

#endif __LIST_H__
```

### 赋值运算符

使用动态内存的时候必须要编写或者声明为私有的另一个方法是`operator=`方法。
将类的实例赋值给这个类的另一个实例（例如，`b = c`）的时候，将会调用这个方法。
除了左侧的实例（前面例子里的`b`）已经存在了之外，这是一个与复制构造函数非常相似的操作，因此它已经有了为它分配了的动态内存。
调用复制构造函数的时候，这个对象还没有被分配相应的内存，但对于赋值运算符来说，之前的时候就已经调用过了这个对象的构造函数，因此，也就应该已经为它分配了相应的动态内存了。

与复制构造函数相类似的，如果不编写它的话，编译器将会为你的类编写一个默认的赋值运算符。
这个默认赋值运算符将会像你所知道的那样，并且会单独地对每个实例变量进行赋值。
如果你的类不使用动态内存地话，它已经达到了你想要的目的。
然而，出于和复制构造函数那里地讨论的相同原因，你并不会希望对用了动态内存的类使用默认运算符；
因为这个默认函数将会导致对象的两个实例共享相同的动态分配的内存。
下面这个头文件展示了你所需要编写的全部三个方法。
我们在头文件里通过使用内联的方法来编写了这些示例，从而能够让这个例子更短。
当然，我们也仍然可以使用单独的实现文件来编写它们。
在这个例子里，因为我们已经知道了这些方法会在什么时候被调用，我们也删除了所有的输出语句：

```C++
// List4.h
#ifndef __LIST_H__
#define __LIST_H__

class List {

public:
  List(int capacity = 10);
  List(const List &source);
  ~List() { delete [] data_; }
  void `operator=`(const List &source);

private:
  int size_;
  int capacity_;
  int *data_;
};

inline List::List(int capacity)
{
  data_ = new int[capacity];
  size_ = 0;
  capacity_ = capacity;
}

inline List::List(const List &source)
{
  int i;
  size_ = source.size_;
  capacity_ = source.capacity_;
  data_ = new int[capacity_];
  for (i = 0; i < size_; ++i) {
    data_[i] = source.data_[i];
  }
}

inline void List::`operator=`(const List &source)
{
  int i;
  if (this != &source) {
    delete [] data_;
    size_ = source.size_;
    capacity_ = source.capacity_;
    data_ = new int[capacity_];
    for (i = 0; i < size_; ++i) {
      data_[i] = source.data_[i];
    }
  }
}
#endif __LIST_H__
```

由于赋值运算符在调用的时候，另一个对象已经被创建了，因此它会比复制构造函数稍微复杂一些。
而且，我们必须要能够正确地释放已经分配的内存，从而保证这个类不会意外地把对象分配给自己。
如果这样的话，我们就会释放掉这个数据的唯一一个副本了。
在C++的类里，标识符`this`是显式调用方法的对象的隐式指针。
比如说，如果我们有两个`List`对象`b`和`c`并且有代码`b = c`的话，这段代码就相当于写的是`b.operator=(c)`。
如果你不知道为什么可以这样写，你可能需要去看看第9.4节，来回顾一下运算符重载的相关内容。
赋值运算符必须被写为类的成员，而不能像许多其他运算符那样可以被编写为独立的函数。
对于赋值语句`b = c`来说，`this`指针将用来表示`b`的地址。
在这里，`this`指针等同于所有Python的方法都具有的显式引用`self`。
如果我们愿意地话，我们可以通过使用`this`指针来显式地引用所有实例变量和方法，比如像`this -> size_`，而不仅仅是`size_`这样来编写代码。
但是，大多数C++程序员都不会使用这种风格来编写代码。

方法里的`if`语句用来检查赋值语句的左侧（在我们的例子里是：`b`）是否与赋值语句右侧的对象是位于同一个地址的对象（在我们的例子里是：`c`）。
如果它们是同一个对象的话，我们的代码不会做任何事情。
删除动态内存将会删除掉动态内存的一个副本。
你可能已经注意到了，复制构造函数和赋值运算符有着相似的大部分代码；
因此，编写一个可以被复制构造函数和赋值运算符调用的私有方法，然后把共享的代码编写在这个私有方法里是非常常见的。
我们将在本节后面的动态数组类的最终版本里展示这一点。

你可能会想，如果程序员把对象分配给它自己会发生什么。
当然，没有程序员会在他们的代码里写`b = b;`这样的代码，而且，也可以编写一个能够捕获这个错误的编译器。
就像你知道的那样，因为我们使用了指针，所以我们可以有指向同一个对象的两个不同名称的指针。
从下面这个故意设计出的例子里，你可以想象一下这样一个场景，当一个函数会返回一个指向`List`对象的指针的时候，程序员并不会知道有其他的`List`指针变量也指向它。

```C++
#include "List3.h"

int main()
{
  List *b, *c, d;
  b = &d;
  c = b;

  *b = *c; // causes `operator=` to be called
  return 0;
}
```

在这个示例里，`b`和`c`都引用着作为变量`d`的`List`对象，因此语句`*b = *c`将会导致调用`List::operator=`方法。
但要注意的是，语句`b = c`并不会调用`List::operator=`方法。
这是因为，变量`b`和`c`是指针，因此这个语句是两个指针的赋值操作，将会让它们都存储相同的地址。

### 完整的动态数组类

接下来，我们将会编写一个完整可用版本的`List`类，这个版本里，我们将会添加一些之前讨论过的那些新的概念。
如果不使用动态内存的话，我们就没办法在C++里编写一个允许超过数组初始大小的`List`类。
下面这个例子展示了正确实现动态内存所需要的所有方法（复制构造函数、赋值运算符和析构函数）。
在这个例子里，我们使用了数据类型`size_t`——它和`unsigned int`（也就是非负整数）是同义词——用来表示数组里索引的实例变量和参数，这是因为数组的大小一定不能为负数。
并且，使用`unsigned int`的话，会有一些潜在的缺陷，我们将在本节后面讨论这部分内容。

```C++
// List.h
#ifndef _LIST_H_
#define _LIST_H_

#include <cstdlib>
class List {
public:
  List(size_t capacity=10); // constructor - allocates dynamic array
  List(const List &a); // copy constructor
  ~List(); // destructor

  int& operator[](size_t pos); // bracket operator
  List& operator=(const List &a); // assignment operator
  List& operator+=(const List &a); // += operator
  void append(int item);
  size_t size() const { return size_; }
private:
  void copy(const List &a);
  void resize(size_t new_size); // allocate new larger array
  int *data_; // dynamic array
  size_t size_; // size of dynamic array
  size_t capacity_; // capacity of dynamic array
};

inline int& List::operator[](size_t pos)
{
  return data_[pos];
}
#endif // _LIST_H_
```

括号运算符（`operator[]`）提供了和Python里`__getitem__`和`__setitem__`方法相同的功能。
在这个例子里，它在类的定义之后被声明为了内联函数，并且返回了一个引用类型。
在类型名称后面的`&`符号表示返回的是对整数的引用，这也就意味着它能够直接返回数组相应位置的地址。
因此，这也就能够像`b[0] = 5`这样，在赋值语句的左侧继续使用操作符，这个小例子里的`b`是`List`类的实例。
类似的，操作符也可以在赋值语句的右侧被使用，就像非引用的返回类型一样，从而作为表达式的一部分。
如果不返回引用类型的话，那么就只能在赋值语句的右侧使用运算符了（相当于Python里的`__getitem__`方法）。
通常来说，只有当一个引用是对实例变量或者是动态分配的内存的引用的时候，才会返回引用。
我们将在这一章的后面来讨论这个问题。

`List`类包含了一个整数数组，它的初始大小在调用构造函数的时候就被指定了。
在构造函数里，它分配了这个具有指定容量的动态数组，并且初始化了`size_`实例变量来表示当前列表为空。
如果我们没有在构造函数里分配内存，而是把这一步延迟到另一个方法里（比如第一次调用`append`方法的时候）的话，我们可以把这个指针变量初始化为`NULL`。
`NULL`常量是在`cstdlib`头文件里定义的。
值`NULL`被定义为零，因此它永远都不可能是动态分配的内存的有效地址。
在C++里使用`NULL`来指示无效指针，就相当于在Python里使用的`None`来指示没有初始化为特定类型的对象的引用。

这个类使用了一个叫做`copy`的私有方法来实现复制构造函数和赋值运算符里所需要的代码。
赋值运算符在分配适当大小的新的动态数组，并且复制数据之前，还需要额外的代码来释放现有的动态数组。
要知道，复制构造函数会创建一个新的对象，因此在调用复制构造函数之前，是没有为这个对象分配任何内存的。
但是，赋值语句的左侧的变量已经调用了构造函数，并且分配了相应的内存，所以需要释放掉这部分内存。
析构函数的代码和复制构造函数类似。
析构函数只会去释放之前分配的动态数组，并且会在`List`的非指针实例超出作用域的时候被自动调用。
这里要注意的是，它不会去释放非指针实例变量，因为这些变量的内存会被自动释放。
在这个例子里，我们将会使用一个单独的实现文件，而不像之前的简单示例那样，整个类都是在头文件里编写的。

```C++
// List.cpp
#include "List.h"

List::List(size_t capacity)
{
  data_ = new int[capacity];
  capacity_ = capacity;
  size_ = 0;
}

List::List(const List &list)
{
  copy(list);
}

List::~List()
{
  delete [] data_;
}
```

在这里，我们编写的`operator=`方法将会与之前略有不同，从而能够让我们可以在链式赋值语句里去使用它。
这个方法将会返回对`List`对象的引用。
通过返回`*this`，我们将会返回刚刚分配好的`List`对象。
因此，我们就可以去编写赋值语句的链式形式（比如说，`b = c = d`）了。
在这里，赋值运算符是从右到左执行的，所以它也就相当于`c = d; b = c`。
通过返回左侧对象的引用，代码片段`c = d`的结果也就会是我们在赋值`b`的时候，用作右测参数的对象`c`。

`operator=`和复制构造函数使用的`copy`方法会分配一个和传递给它的`List`对象大小相同的数组，并且把参数对象数组里的所有数据都复制到新分配的数组里去。
在这里，我们还实现了`operator+=`方法，因此我们可以展示另一个潜在的出错的可能性。

```C++
void List::copy(const List &list)
{
  size_t i;
  size_ = list.size_;
  capacity_ = list.capacity_;
  data_ = new int[list.capacity_];
  for (i = 0; i < list.capacity_; ++i) {
    data_[i] = list.data_[i];
  }
}

List& List::operator=(const List &list)
{
  if (&list != this) {
    // deallocate existing dynamic array
    delete [] data_;
    // copy the data
    copy(list);
  }
  return *this;
}

List& List::operator+=(const List &list)
{
  size_t i;
  size_t pos = size_;
  if ((size_ + list.size_) > capacity_) {
    resize(size_ + list.size_);
  }

  for (i = 0; i < list.size_; ++i) {
    data_[pos++] = list.data_[i];
  }
  size_ += list.size_;
  return *this;
}
```

`operator+=`的实现看起来很简单，但如果不小心的话，它也可能会导致一些细微的错误。
如果我们用下面这段代码来替换最后几行，从而能够在把元素添加到数组的同时来增加`size_`变量的话，在大多数情况下，它都能够正常工作。

```C++
  // this version is incorrect
  for (i = 0; i < list.size_; ++i) {
    data_[size_++] = list.data_[i];
  }
```

但是，如果我们有一个`List`实例`b`，并且执行了语句`b += b`的话，会发生什么呢？
在这种情况下，`size_`和`list.size_`是同一个内存地址的两个名称而已（也就是说，它们都指向了同一个内存地址）。
由于我们每次都会通过循环来递增`size_`，因此`for`循环将永远都不会结束，因为变量`i`将会始终都小于`list.size_`。
这种类型的细小错误可能会非常难以查找，因此在为自己的代码编写相关对应的测试的时候，要始终考虑这些特殊情况。

`append`方法也很简单，只不过如果我们已经填充满了现有数组的话，我们就会需要再去分配一个更大的数组。
在这里，我们编写了一个单独的`resize`方法来实现这个功能，`append`方法会在必要的时候来调用它，从而完成分配一个新的更大的数组、复制数据、更新指针、然后释放旧的较小数组的步骤，就像我们在10.3节里提到过的那样。

```C++
void List::append(int item)
{
  if (size_ == capacity_) {
    resize(2 * capacity_);
  }
  data_[size_++] = item;
}

// should this method have a precondition? see end of chapter exercises
void List::resize(size_t new_size)
{
  int *temp;
  size_t i;

  capacity_ = new_size;
  temp = new int[capacity_];
  for (i = 0; i < size_; ++i) {
    temp[i] = data_[i];
  }
  delete [] data_;
  data_ = temp;
}
```

我们将会把在C++的动态内存列表里去添加其他的内置Python列表的API方法作为练习留给你。
我们之前曾经提到过，使用`unsigned int`或者等效的`size_t`数据类型的时候需要小心。
因为，像图8.4所表述的那样，32位系统上的`int`类型的范围通常从大约负20亿到大约正20亿；
而对于`unsigned int`数据类型来说，由于它没有与正负符号相对应的位来进行表示，因此`unsigned int`类型的范围将会是从0到大约40亿的样子。
因此，我们会遇到的一个问题是，当一个操作返回的是负数的时候会发生什么呢？

```C++
// unsigned.cpp
#include <iostream>
using namespace std;
int main()
{
  unsigned int x = 0;
  x--;
  cout << x << endl;
  return 0;
}
```

在为32位系统编译的程序里，这个操作的输出将会是`4294967295`——这是可以用32位来表示出的最大的整数了（所有32位都是`1`的情况）。
在这里，就像超出了汽车里程表中的位数那样，我们已经*溢出*了位的表示。
设想一下，如果你把汽车里程表向后移动到零以后会发生什么？
一般来说，你会得到里程表里可以容纳的最大值。
这就和在计算机里整数值溢出的时候所发生的情况基本相同。
C++不会主动地指示会在什么时候发生溢出。
会有一些办法检测这些溢出，但是我们并不会在这本书里去介绍这部分的细节。
因此，在编写代码的时候，我们必须要保证不会意外地溢出正在使用的数据类型可以存储的值范围，不然的话就会出现各种意想不到或者是不正确的结果。
下面这个代码片段展示了溢出所引起的错误：

```C++
  unsigned int i;
  unsigned int pos = 0;
  for (i = 5; i >= pos; --i) {
    cout << i << endl;
  }
```

如果你为这个循环创建一个程序并且运行它的话，你可能会希望循环被执行六次（当`i`是五，四，三，二，一和零的时候，布尔表达式`i >= pos`的结果应该是真的）。
但问题出现在，把`i`设置为零之后，`i`的下一个值将会是`4294967295`，很明显它也会大于或者等于零，因此这段代码会产生无限循环。
但是，如果`pos`是任何一个正数值的话，则不会发生这种情况。
一般来说，使用这些边界条件来测试你代码会是一个很好的主意，因为这样做可以保证相应的代码能够在所有情况下都能正常工作。

### 引用返回类型

通过前面的学习，我们应该知道了你不应该返回一个对局部变量的引用。
这是因为这样的引用会直接返回存储变量的内存地址，而不是这个变量的值。
然而，函数里的局部变量在函数结束之后会被自动释放。
如果使用术语来描述的话，局部变量的*生命周期*是函数执行的总时间。
当函数结束之后，用来分配给局部变量的内存地址会被回收，并且这些内存地址将不再*绑定*到这些局部变量。
因此，你只能通过引用来返回函数或方法结束的时候，生命周期还尚未结束的变量。
下面这个例子展示了一个返回对局部变量的引用，这并不是一个正确的例子，而且大多数编译器都会对这个情况产生警告。

```C++
// this is incorrect
int& f()
{
  int x;
  return x;
}

int main()
{
  f() = 5;
}
```

在我们关于`List`类的内容里，我们提到过，因为`operator[]`返回了一个引用，所以我们可以写`b[0] = 5`这样的代码，其中`b`是`List`类的一个实例。
在赋值语句的左侧，我们调用了运算符，从而得到了一个对内存地址的引用。
然后使用这个内存地址来存储值`5`。
在上面这个例子里，语句`f() = 5`想要执行类似的操作——在函数`f`返回的变量`x`的内存地址存储值`5`。
但是，这个例子的问题是，函数结束后相应的内存地址将不再被用于局部变量`x`了。

就像我们在`List`代码里那样，返回对类的实例的实例变量的引用是可以的。
这是因为，对象的实例变量与类的实例具有相同的生命周期。
语句`b[0] = 5`里的`b`就是`List`类的实例，因此它就相当于是代码`b.data_[0] = 5`，然而由于`data_`是类的私有成员，因此并不能这样做。
括号运算符是一种公有方法，它可以返回对私有数据的引用，从而能够让我们可以直接并且合法地访问私有数据。
通常来说，这样做会被认为是一种糟糕的编程风格，但对于封装的动态数组的类来说，人们普遍会认为这是合理的。

`operator[]`方法的先验条件是指定的索引需要介于`0`和`size_ - 1`之间。
为防止类的用户通过传递列表大小范围之外的索引，从而导致程序崩溃，我们可以通过在访问动态数组里的这个位置之前，先验证指定的索引是否在0和`size_ - 1`之间来解决。
但是，如果使用这个类的代码始终都满足这个先验条件的话，那么也可以不需要添加这部分额外的开销。
一种常见的解决方案是在测试和调试程序的时候，包含验证先验条件的代码，之后，一旦证明了程序是正确的，就可以删除验证先验条件的这部分代码从而获得一些性能上的提升。

## 动态内存错误

在C++里使用指针能够让你的程序拥有更多的灵活性和更好的功能性，但也更容易出错。
另外，这些指向数据对象的指针也需要额外的内存，这是因为你需要同时存储指针和数据，而在C++的默认堆栈里的动态变量则只需要内存来存储数据就行了。
动态内存错误是大多数大型程序里的错误的根源。
基于这些原因，你应该只有在需要额外的性能时才去使用动态内存。

动态内存错误通常很难追踪和修复。
因为它的表现是，你的程序可能会运行正常，有可能能够运行但结果不正确，也有可能会直接崩溃。
我们建议你去学习如何使用编程环境所支持的调试器来帮助你跟踪这些内存错误。
你也可以通过在代码里放置输出语句来查找错误，但是从长远来看，学习如何使用调试器将会为你节省大量时间和避免令人沮丧的挫败感。
追踪这些错误的另一个难度在于，导致程序崩溃的语句通常不是那个不正确的语句，因此校对动态内存代码也非常重要。
在这一节里，我们将去讨论动态内存可能出现的不同类型的错误。

### 内存泄漏

我们已经简单地提到过了一种被称为*内存泄漏*（*memory leak*）的错误。
分配内存但不去释放内存时，就会发生内存泄漏。
如果你的程序反复调用这个会泄漏内存的函数或方法的话，那么这个程序最终会需要比计算机自带内存还要多的内存。
这就会导致操作系统将使用磁盘来作为额外内存。
然而，由于磁盘的读写速度相比内存的读写速度要慢得多，因此计算机的整体速度会变慢。
好在，当程序完成之后，操作系统会回收程序所使用的任何内存，因此内存泄漏通常都不会导致程序崩溃。
但是，如果操作系统本身有内存泄漏的话，它最终会消耗掉所有的内存。
这也就是为什么有些人会建议你偶尔重启一次计算机的原因。

这一节里包含的错误的代码示例是一些你通常不会写出，但会在较大代码片段的某一部分发生的错误。
第一个例子里执行了两个`new`语句，但只执行一个`delete`语句。

```C++
// this code is incorrect
void f()
{
  int *x;
  x = new int;
  *x = 3;
  x = new int;
  *x = 4;
  delete x;
}
```

图10.3通过图形展示了这段内存泄漏代码。
左边部分是执行了`*x = 3`这一行之后的结果：
将会动态分配四个字节，其中用`x`保存这个内存的地址，并且把值`3`存储在这个地址。
图的中间部分则是在执行了第二个`x = new int`语句后的结果。
在这个时候，我们将不再有任何方法可以访问最初由第一个`x = new int`语句分配的那部分动态内存了。
图的右侧部分则表示了在`delete x`语句执行之后的结果：
在这个时候，变量`x`将会指向一个不能再被使用的内存地址，而包含`3`的内存地址由于我们没有保存这个地址的变量，将会仍然存在而且没办法去释放它。
这就是内存泄漏。
要修复这段代码的话，我们需要在第二个`x = new int`语句之前加上另一条`delete x`语句。

图10.3：内存泄漏的图形表示

在许多情况下，释放由`new`语句所分配的内存的`delete`语句并不会在同一个函数或方法体里。
这会使得检测内存泄漏变得更加困难。
比如，如果你回顾一下`List`类里的`resize`方法的话，你会注意到它里面的`delete`语句并没有去释放由函数调用期间先执行的`new`语句所分配的内存。
在第一次调用`resize`方法的时候，`delete`语句将会释放由构造函数分配的内存。
之后每次调用`resize`方法时，它则会去释放前一次调用`resize`方法所分配的那部分内存。
看起来，你可能会认为这好像会导致内存泄漏，但要知道，如果从未调用resize方法，析构函数将会去释放构造函数分配的内存；
不然的话，析构函数会释放最后一次调用`resize`方法时所分配的内存。

事实上，通常来说，一一对应的`new`和`delete`语句并不会出现在同一个函数或方法体中，因此很难保证你的代码没有任何的内存泄漏。
我们将在第11章里看到另一个关于链式结构的例子。
这时候，仔细校对和检查代码将会非常显著地帮助你去避免这些错误。
某些开发环境提供了在程序执行的时候可以跟踪内存使用情况的工具，通过这些工具，可以让你监控是否有内存使用量的意外增长。
你可能会由于操作系统会在程序退出时回收程序使用的所有内存，而认为内存泄漏不是一个需要特别关注的问题。
但是，许多程序会运行很长一段时间。
比如，商业站点的网络服务器可能会一次性连续运行几个月而不会重新启动。
如果你不去经常重启计算机（让计算机进入睡眠状态或者休眠模式都并不等于重启它），并且一直运行着像是电子邮件或者时网络浏览器这样的程序的话，很明显，这种情况下你并不会希望这些程序有内存泄漏。
如果你正在运行的这些程序（或者说操作系统本身）存在内存泄漏的话，那么计算机将会在你重新启动它之前，由于使用磁盘作为外部内存，从而随着时间的推移而越来越慢。
因此，养成编写没有内存泄漏的代码的习惯非常重要。
要做到这一点的关键是，对每一个被执行了的`new`语句，当程序使用完这个`new`语句所分配的内存之后，都必须要有一个相对应的`delete`语句被执行。

### 访问无效内存

现代计算机的硬件会提供检查来保证一个程序不会访问到另一个程序所使用的内存。
这样做可以防止许多问题，比如说，一个程序的运行导致了另一个程序产生了不正确的数据或者崩溃。
如果一个程序可以访问另一个程序（比如说，Web浏览器）所使用的内存的话，那么这个程序就可以访问你在Web浏览器里键入的密码以及其他的一些敏感信息了。
计算机硬件把内存分隔成了被称为*分页*（*pages*）的各个部分。
在大多数现代计算机里，分页大小为4KB或者是8KB。
随着计算机内存量的不断增长，分页大小可能也会增加。
硬件会在分页这个级别提供保护。
如果程序试图访问不是程序正在使用的某个分页里的内存的话，那么就会产生硬件异常，并且导致程序崩溃。

由于硬件只会在程序试图访问不是操作系统为它分配的分页之一的内存时才能检测到错误，因此程序可以访问分配给它的任何一个分页、但并不是有效内存地址的内存。
在这种情况下，你的程序并不会立即崩溃，但是，每次运行它的时候，都可能会有不同的结果，或者它可能会在之后的某个时间点崩溃。

我们将从一个不使用动态内存的简单例子开始，但在这个例子里，会产生意外的结果。
在阅读这段代码后面的段落之前，先看看你能不能找到这个程序里的错误：

```C++
// this program is incorrect
#include <iostream>
using namespace std;

int main()
{
  int x[10];
  int y = 0;
  int i;

  for (i = 0; i <= 10; ++i) {
    x[i] = i;
  }
  cout << "y=" << y << endl;
  return 0;
}
```

与Python不同的是，当你尝试访问数组里的元素时，C++并不会执行任何的索引验证（Python会在你尝试访问列表里的元素时进行验证）。
因此，这个例子里的问题是，这个数组只能够使用值`0`到`9`来对它进行索引访问，但是，`for`循环里会用到`x[10]`。
根据为局部变量分配内存的方式，即使我们将`y`设置为了零，这段代码也可能会让程序输出的`y`的值是`10`。
这是因为，如果用于变量`y`的内存位置紧跟在数列的内存位置之后的话，那么`x[10]`和`y`都指向了相同的内存地址。
但是，如果不是按照这个顺序来分配变量的内存的话，那么程序将会按照预期而输出`0`。

要知道，指针包含的是一个地址，而解引用一个指针会表示尝试在这个地址进行读取或存储数据。
这样也就可以让你访问一个你不应该去使用的内存了。
下面这个简单的程序几乎可以保证在任何计算机上都会崩溃：

```C++
// this program is incorrect
int main()
{
  int *p;
  p = (int*) 8;
  *p = 1;
  return 0;
}
```

这个程序先会把指针变量设置为数字`8`的内存地址。
并且，因为不应该直接将指针设置为一个整数值，我们必须使用强制类型转换来让编译器接受这个操作（你应该使用一元`&`符号运算符，或者是`new`语句来把指针变量设置到一个内存地址上）。
执行`p = (int*) 8`这条语句并不会让程序崩溃，但这一行是不正确的。
后面的`*p = 1`语句将会尝试把值`1`存储在`8`的内存地址那里，而由于这个内存地址并不是动态内存里的一部分。
硬件会检测到这个错误，从而导致程序崩溃。
和之前一样，你并不应该把这种写法放到正常程序里去。
但这个例子可以告诉你，如果你意外地将指针变量设置成了你的程序不再使用的内存地址，并且在之后尝试去解引用这个指针的话，你的程序将会崩溃。
下面这个程序是同一问题的一个更容易出现的例子：

```C++
// this program is incorrect
int main()
{
  int *x;
  *x = 5;
  return 0;
}
```

在这个例子里，`x`永远都不会被初始化去保存一个有效地址，因此对应于变量`x`里的内存地址是分配给它的任何内存里的那个值，而程序又会去尝试把这个地址所对应的值设置为`5`。
如果这个地址恰好位于操作系统给我们程序分配的一个分页地址里的话，这个程序并不会崩溃。
但是，这并不太可能。
因为存储在`x`变量里的地址更有可能不是一个有效地址，因此尝试存储`5`将会导致硬件产生异常，从而导致我们的程序崩溃。
下面是另一个可能会导致同样问题的例子：

```C++
int main() // this program is incorrect
{
  int *y = new int;
  delete y;
  *y = 3;
  return 0;
}
```

在这个例子里，我们尝试解引用指针`y`，并且在释放了`y`指向的内存地址之后，把值`3`存储到这个地址里。
这段代码也可能会导致我们的程序崩溃或者会运行完成。
你现在应该开始明白为什么在较大的程序里，很难去追踪这些类型的错误了。

我们将在这一章里再检查一个有错误的程序，但是你其实会在很多不同的地方都会遇到这些问题。
下面这个程序有两个错误：

```C++
// this program is incorrect
int main()
{
  int *x, *y;
  x = new int;
  y = new int;
  *x = 3;
  y = x;
  *y = 3;
  delete y;
  delete x;
```

第一个问题是这个程序存在内存泄漏。
它一开始分配了两个整数的内存，但是语句`y = x`会导致两个指针都引用到相同的内存地址。
这也就会导致由语句`y = new int`分配的那部分内存被泄漏，从而不能再访问到它并且释放它。
之后的`delete y`语句会释放掉`x = new int`语句分配的内存。
而由于`x`也指向了这个内存地址，因此语句`delete x`会尝试再次释放相同的内存块。
而这样做，可能会破坏动态内存堆。
这种破坏也可能会导致程序立即崩溃，或者在以后崩溃，或者并不会崩溃。

### 内存错误总结

某些C++的运行时环境不会显示程序崩溃的确切行，也不会显示导致程序在这一行崩溃的函数以及相应的方法调用的堆栈序列。
大多数IDE（集成开发环境）都会向你显示类似于Python那样的执行跟踪，从而指示程序崩溃的行以及在崩溃时所调用的函数或方法。
这些信息对于确定程序崩溃的原因非常重要。
不幸的是，就像我们提到过的那样，程序崩溃的那一行并不见得是真正出错的行。
如果导致程序崩溃的行是解引用一个指针，那么问题可能是：
要么你忘了给那个指针一个有效的地址；
要么它以某种方式指向了你的程序里不再有效的内存（比如说，你已经调用过`delete`的内存块，或者是指针被设置为与有效地址不对应的值）。
执行的回溯会告诉你函数或者方法被调用直到崩溃那一点的顺序。
这些内容将会帮助你确定导致这些问题的代码。

此外，就像我们之前提到过的，有些时候你可以通过访问不正确的内存地址或为同一个内存块调用两次`delete`来破坏动态堆。
这种错误，在你尝试下一次分配新的内存之前，通常都不会导致崩溃。
因此，这种类型的错误可能会非常难以追踪并且让人感到灰心丧气。
好在，在开发代码的时候，可以使用提供调试器的IDE来帮助你跟踪这些错误。
调试器提供了许多功能，这些功能能够帮你在程序里查找错误。
大多数调试器都允许你停在程序里的特定源代码的某一行执行代码，并且检查在这一点的变量值，而且可以在你观察变量值的同时，一次只执行一行或者是一个函数。
调试器通常还会提供更多这里没有提到的功能。

在调试器里运行程序并且程序崩溃的时候，调试器通常会向你显示一个与Python回溯类似的信息。
在没有调试器的情况下开发Python代码相当容易，但是在用C++编写动态内存代码的时候，一个调试器和好用的IDE将能够帮助你更快地跟踪内存错误从而避免挫败感。
有时候，校对崩溃点周围的代码（或者如果崩溃是在方法里发生的话，就校对整个类）是解决这些问题的最有效方法。

找到导致程序崩溃或者工作不正确的最小样本输入也是个很好的主意。
在处理动态内存错误的时候，这一点尤其重要。
如果我们确定了我们的`List`类在`append`方法里没有正常工作并且导致了程序崩溃，我们首先要检查的就是：
能不能在添加更少的元素，并且在没有去调用`resize`方法之前的时候就发生这个错误。
如果是这种情况的话，由于我们只调用了`append`方法和构造函数，因此我们可以知道问题发生在构造函数或者是`append`方法里。
如果只有在调用`resize`方法之后，程序才会在`append`方法里崩溃的话，那么问题可能会在构造函数、`append`或者`resize`方法里，但在这种情况下，我们建议首先检查`resize`方法。
这样，通过尽量减少执行的代码量，但仍然让问题出现，可以减少你必须检查的代码量，从而能够让你可以更快地找到问题所在从而避免挫败感。

## 章节总结

这一章我们介绍了在C++里使用指针和动态内存的相关问题。
我们在这里总结了一些重要部分。

* Python的引用和C++的指针的工作方式是类似的，基本上只是具有不同语法的相同概念。

* C++的指针允许你在使用`new`和`delete`语句时，延迟确定在运行时所需要分配的内存量。

* C++的指针允许你编写像`List`这样的类，这些类的大小会随着时间的推移而增长；
它们还能够让你编写链式结构，我们将在第11章里讨论它。

* 每个`new`语句都必须有一个相对应的`delete`语句，当程序不再使用这部分内存的时候，这个`delete`语句将会释放由`new`语句分配的内存。

* 使用动态内存的类必须实现一个析构函数，这个析构函数在实例超出作用域的时候，会释放类的实例里仍然在被使用的任何动态内存。
动态内存类还必须要编写复制构造函数和`operator=`方法，它们可以用来构建动态内存的深拷贝，或者你也可以声明这些方法成私有的，从而不让外部去调用它们。

* 使用动态内存可以提供更多的灵活性和和更好的功能性，但也更容易出错。
因此，应该只在需要这部分功能的时候，才使用动态内存。

* 动态内存错误是许多程序中的错误来源，这些错误很难被追踪和修复。

## 练习

**判断题**

1. 应该用动态内存来创建所有的C++数组。

2. 动态内存错误是程序中常见的错误来源，它通常难以被追踪。

3. 永远不释放动态内存并不会导致问题，因为程序结束的时候会回收程序所使用的所有内存。

4. 使用动态内存会比使用标准的自动变量要更多内存。

5. 让函数返回本地堆栈的动态变量的地址是能够正常工作。

6. 函数可以返回在函数内动态分配的内存地址。

7. 类的方法可以返回这个类的实例变量的地址。

8. 使用了动态内存，并且在运行了一次之后而不会崩溃的C++程序将永远都不会崩溃。

9. 分配了动态内存的C++方法必须在这个方法结束之前释放它。

10. 分配了动态内存的C++类并不需要有复制构造函数和`operator=`。

11. 为实例变量分配了动态内存的C++类并不需要包含析构函数。

12. 下面这个代码有内存泄漏。

    ```C++
    int* f()
    {
      int *x = new int;
      *x = 3;
      return x;
    }
    int main()
    {
      int *y = f();
      int z = *y;
      delete y;
      return 0;
      }
    ```

**选择题**

1. 以下哪一项在Python和C++里的工作最相似

    a) Python的名称和C++的堆栈动态变量

    b) Python的名称和C++的指针

    c) C++的值传递和Python的参数传递机制

    d) C++的引用传递和Python的参数传递机制

2. 下面这段C++代码片段有什么问题？

    ```C++
    int x, *y;
    y = &x;
    delete y;
    ```

    a) 代码片段是正确的。

    b) 代码片段有内存泄漏。

    c) 赋值`y = &x`不正确。

    d) 语句`delete y`不正确，因为它所指向的地址并没有通过`new`运算符来进行分配。

3. 下面这段C++代码片段有什么问题？

    ```C++
    int *b, *c;
    b = new int;
    *b = 3;
    c = b;
    delete c;
    delete b;
    ```

    a) 代码片段是正确的。

    b) 代码片段有内存泄漏。

    c) 语句`delete b`尝试去释放了已由语句`delete c`释放的相同内存地址。

    d) 第一个语句必须是`delete b`，这是因为内存是为变量`b`分配的。

4. 下面这段C++代码片段有什么问题？

    ```C++
    int *b, *c;
    b = new int;
    *b = 3;
    c = b;
    delete c;
    ```

    a) 代码片段是正确的。

    b) 代码片段有内存泄漏。

    c) `delete`语句必须是`delete b`，因为内存是为变量`b`分配的。

    d) 语句`c = b`必须是`*c = *b`。

5. 一个C++程序，它有指针变量但从不调用new或delete

    a) 永远都不会崩溃。

    b) 不会有内存泄漏。

    c) 会有内存泄漏。

    d) 永远都不会去尝试访问不被允许访问的内存地址。

6. 使用上一章里的`Rational`类，下面这段C++代码片段的输出是什么？

    ```C++
    Rational r1, *r2;
    r1.set(1, 2);
    r2 = &r1;
    r2->set(3, 4);
    cout << r1 << " " << r2;
    ```

    a) `1/2` `1/2`

    b) `1/2` `3/4`

    c) `3/4` `1/2`

    d) `3/4` `3/4`

7. 如果你正在编写一个使用动态内存的类，那么你必须要在类的定义里声明哪些方法？

    a) 析构函数

    b) 复制构造函数

    c) 赋值运算符

    d) 以上所有内容

8. 如果你有一个使用动态内存的类并将它的一个实例赋值给了这个类的另一个实例，会发生什么？

    a) 你会有内存泄漏。

    b) 你将创建一个深拷贝。

    c) 你将创建一个浅拷贝，导致动态内存被解除分配两次。

    d) 一切都会正常运作。

9. 在C++的类里，下列关于`this`指针的论述，哪一个是正确的？

    a) 你必须把`this`指针声明为想要访问它的方法的参数。

    b) 你可以在静态方法，以及类的方法里使用`this`指针。

    c) 在调用它的方法里的`this`指针，会存着类的实例地址

    d) 你必须始终通过`this`指针访问私有数据。

10. 如果你的动态内存代码不正确会发生什么？

    a) 每次运行程序时，程序都可以正常运行。

    b) 你的程序可能会在某些时间正常运行，而在其他的某些时间给出错误的结果。

    c) 你的程序可能会在某些时间正常运行，之后在其他的某些时间直接崩溃。

    d) 以上所有都是可能的。

**简答题**

1. `List`类的`resize`方法是否存在潜在的问题？
如果有的话，有什么先验条件可以解决这个问题？
而且，由于这个方法被声明成了私有的，那么我们的`List`类的用户是否会遇到问题？

2. 使用动态内存有什么好处？

3. 使用动态内存有什么缺点？

4. 什么时候应该使用动态内存？

5. 编写一个有内存泄漏的C++代码片段。

6. 编写一个C++代码片段来访问不应该被访问的内存。

7. 我们讨论过的关于`operator+=`方法的任何潜在的、微妙的问题是否同样适用于编写`operator+`方法？
为什么是或者为什么不？

8. 为什么函数或者方法返回对本地堆栈动态变量的引用是不合法的？

9. 在什么时候返回对变量的引用是合法的？

10. 在下面的代码片段里，访问这些数据需要多少次内存访问（不计入访问程序指令本身所需的内存访问）？
解释你是如何得出答案的。

    ```C++
    int *b, *c, x, y;
    x = 3;
    y = 4;
    b = &x;
    c = b;
    *c = 2;
    cout << *b << " " << *d << " " << x << " " << y << endl;
    ```

**编程练习**

1. 通过使用动态分配的数组（添加`extend`、`index`、`insert`、`pop`和`remove`方法），使用与Python内置列表相同的语义和API来完成C++里的`List`类。
再添加一个名为`len`的方法，这个方法用来返回列表里的元素数量，以及添加`operator+`方法或函数。
在任何需要让数组变大的时候，都应该把它当前的容量加倍。
比如说，`append`、复制构造函数、`operator=`、`operator+=`、`operator[]`以及析构函数。
然后，编写一个程序来测试这个列表类，检查所有的方法，包括各种边界情况，例如，再列表的开头或者结尾处的插入操作。

2. 编写一个允许整数任意大的C++的`LongInt`类。
通过存储一个数组来实现它，数组通过它的每一个元素都代表一个数字（`0`到`9`）来组成数字（比如说，数字`678`在这个数组的位置`0`有`8`，在数组的位置`1`有`7`，在数组的位置`2`有`6`）。
因为只需要一个字节就足够用来保存数字`0`到`9`了，所以使用`unsigned char`的动态数组来实现这个类。
重载相应的运算符，从而能够让你可以进行添加、减去、相乘、复制和输入/输出类的实例的相关操作。
然后，编写一个程序来测试你的类。

3. 实现一个多项式类，其中动态双精度数组里的每个元素都被用来存储多项式的系数。
重载相应的运算符，从而能够让你可以进行添加、减去、相乘、复制和输入/输出类的实例的相关操作。
然后，编写一个程序来测试你的类。

4. 使用动态字符数组来编写一个你自己的`string`（字符串）类的实现。
重载相应的运算符，从而能够让你可以连接两个字符串、访问特定位置的元素以及输入/输出你的`string`类的实例。
再添加一些Python或者C++里的`string`类所支持的一些方法，例如：
切片/子字符串、搜索元素、反转字符串、等等。
将你的类命名为`MyString`，来避免与现有的`string`类的名称造成的混淆。

5. 研究如何动态分配和释放多维数组（本书未涉及）。
编写一个程序，它可以动态分配一个用户输入的大小的二维数组，填充相应的内容，输出内容，然后释放分配。

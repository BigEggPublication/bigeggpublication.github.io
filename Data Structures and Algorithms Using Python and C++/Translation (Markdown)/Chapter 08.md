# 为Python程序员准备的C++简介

目标

* 了解C++的编译过程。

* 了解C++的内置数据类型、输入/输出、决策语句和循环语句这些主要组成部分的语法和语义。

* 了解C++的数组的语法和用法。

* 了解C++的函数和参数传递机制的详细细节。

* 了解C++的变量的作用域和它的生命周期。

## 简介

本书前面部分的章节重点介绍了如何使用Python语言来开发算法和数据结构。
Python因为具有相对简单的语法，以及强大的内置数据结构和函数库，所以它是一个非常适合于初学者的优秀语言。
目前看来，Python在行业内的使用量还是非常小的，但是这个比例正在不断地持续增长。
然而，即使Python已经是最常用的语言之一，所有计算机科学家也应该知道若干种其他不同的计算机语言。
不同的编程语言提供了不同的功能，这就让任何一个单一的编程语言都不会是所有问题的最好的选择。
不同的编程语言具有不同的能力，而这将会鼓励你不断地去思考解决问题的更多方法，因此学习新的编程语言有助于扩展你的解决问题的能力。

Python语言的数据结构和许多内置函数隐藏了程序的许多底层实现细节。
正如我们之前讨论的那样，使用Python的时候，你不必像在使用某些语言的时候那样，去担心内存释放相关的操作。
很明显，当人们在开发更高级别的语言，并为这些语言编写解释器和运行时环境的时候，需要了解实现它们所需要的所有底层细节。
应该明白的一点是，Python一般来说，并不是处理大量数据或者需要大量计算的应用程序的最好的语言。
这是因为，它使用了额外的内存来存储每个对象的引用计数以及这个对象的数据类型。
而且，它的解释器在执行的时候，还必须要把这个Python的执行语句，从字节码转换成机器代码。

这一章和接下来的四章里，我们将会介绍C++编程语言的一个很大的组成部分。
C++对Python程序员来说，是非常优秀的补充语言，这是因为它是一种相对来说较低级别的语言。
它需要你了解许多底层实现的细节，其中就包括了内存管理。
C++可以更有效地使用计算机的内存和CPU。
能够同时使用Python和C++编程的这项能力，将会能够让你在解决给定问题的时候选择更恰当的语言。
在实际工作中，当算法的速度和内存使用很重要的时候，Python程序通常都会去直接使用已经编译好的C或C++代码。

## C++的历史和背景

C语言是在20世纪70年代早期开发出的一个跨平台系统语言。
在20世纪60年代的时候，当一台计算机被制造出来之后，每台机器装上使用汇编语言编写的新的操作系统。
于是，AT&T贝尔实验室的布莱恩·柯林汉（Brian Kernigan）和丹尼斯·里奇（Dennis Ritchie）决定开发出一种用于系统代码的高级跨平台语言。
他们和肯·汤普逊（Ken Thompson）一起用C语言开发出了Unix操作系统，而且，他们可以轻松地把这个操作系统移植到新的计算机硬件上。
直到现在，C语言仍然被广泛地用在对于速度至关重要的应用里，比如说像操作系统和科学计算这些地方。
事实上，Python的解释器就是用C语言编写的。

在20世纪70年代末和80年代初的时候，计算机科学家们开始意识到：
面向对象设计以及面向对象的编程将能够允许他们编写出更易于维护以及可重用的代码。
当时有若干个已经存在了的面向对象语言，但C语言在里面是最受欢迎的。
在20世纪80年代早期的时候，AT&T的比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）决定开发一种对C程序员来说相对容易学习的新的面向对象的语言。
他为C语言添加了显式的面向对象编程的支持，并称为这个新语言为C++。
除了C++会使用的独有的新关键字之外，C++基本上是向后兼容C语言的，这也就使得C语言的程序员可以很容易地去开始使用C++。
完整的C++语言比C语言更大，更复杂，许多程序员在编写C++代码的时候只会使用C++的一部分功能。

C和C++是比Python更低级的语言。
C语言不提供内置的列表和字典类型。
C++语言则使用了被称为标准模板库的类和方法集来支持一些更高级别的数据结构。
C和C++相比较Python而言，会显得更简洁，而且它们使用了更多的特殊字符（比如，`&&`相当于Python的`and`，`||`相当于`or`）。
新版本的C++，在现在除了特殊符号之外，也开始允许使用`and`和`or`了。

这本书里主要使用的是C++语言，然而，在这一章里包含的大部分内容也同样适用于C语言。
后面章节里的一些话题也同样适用于C语言，但在通常来说，我们不会去明确地指出什么部分适合于C语言。
简单来说，任何涉及到了类的部分，都不会适用于C语言。

当你读到前面的段落的时候，你肯定会问为什么你需要学习C++语言，因为用它来编写代码看起来会更难一些。
在你发现编写C++代码更困难的同时，你还会发现执行相同操作的情况下，C++源代码几乎总是比Python源代码更长。
但是，Python并不是适用于所有应用程序的最好的语言。
使用C或C++这类的编译语言所编写的代码，通常来说执行速度会快一个数量级。
而且，这些代码所使用的内存，也会比解释相应的Python代码要少。
直到现在，在许多应用程序领域，你仍然会希望能够最大限度地提高执行速度，并且有效地利用内存，从而能够让你的代码可以处理大量数据。
比如说，你肯定不希望用Python来编写操作系统或者像是Web服务器以及数据库服务器这样的服务器。
最后，学习C++还可以帮助你更好地理解Python解释器里的细节。

C和C++源代码将会被编译成机器语言代码，而Python则使用的是混合过程，这个混合过程里，源代码将会被编译成字节码，然后通过解释这些字节码来执行。
两种方法都各有优缺点。
编译代码的执行速度比解释代码快得多，但是不如解释代码灵活。
我们将在后面的章节里讨论它们之间的一些差异。
编译C++代码过程可以用图8.1里的图形来表示。
我们将使用下面这个简单的C++程序来描述编译过程的工作原理。

```C++
// hello.cpp
#include <iostream>
using namespace std;

int main()
{
  cout << "hello world\n";
  return 0;
}
```

>      C++源文件   C++源文件    头文件    头文件
>          |          |          /      /
>          |          |       /    /
>          |          |    /  /
>          |          | / /
>       预处理器    预处理器
>          |          |
>          |          |
>          |          |
>          |          |
>      预处理过的  预处理过的
>       源文件      源文件
>          |          |
>          |          |
>          |          |
>          |          |
>        编译器     编译器
>          |          |
>          |          |
>          |          |
>          |          |
>       机器代码    机器代码    以机器代码
>                             方式分发的库
>            \        |        /
>              \      |      /
>                \    |    /
>                  \  |  /
>                   链接器
>                     |
>                     |
>                     |
>                     |
>                  可执行的
>                  机器代码

图8.1：C++代码的编译和链接过程

如果告诉你`cout`是用来产生输出的，你可能就已经能够猜到这个程序和`print "hello world"`这样的Python程序做的是同一件事了。
预处理器（通常被称为*C预处理器*，*C preprocessor*）获取到源代码之后，会处理所有以井号（`#`）开头的行。
示例程序中的`#include`预处理程序指令会告诉预处理器将`iostream`文件里的所有代码复制到我们的源文件里。
这和我们把这个文件里的内容复制粘贴到`#include`语句所在的程序里的效果是一样的。
`iostream`文件被称为*头文件*（*header file*）。
每个C++源文件可以包含任意数量的头文件。
我们将会在这一章的后面以及之后的章节里更详细地讨论头文件的细节。
现在，你需要知道的是，头文件包含了一些关于在其他文件里编写的源代码的信息。

预处理器的输出结果仍然是C++源代码，然后它们会被送到C++编译器去。
编译器的工作是将C++源代码转换为特定芯片和特定操作系统的机器语言代码（计算机CPU可以执行的0和1）。
编译器执行的第一步是检查代码里是否存在任何的语法错误。
这是因为语法错误就意味着程序是不正确的，因此编译器将无法确定你的代码的意思，从而完成整个过程。
如果你的代码有语法错误的话，编译器就会停下来，并且向你显示一条错误消息，这条消息会指向它无法理解的那部分内容。
这也就意味着，在修复掉所有的语法错误之前，你是没办法尝试运行这个程序的。
当源代码在语法都上正确之后，编译器将会生成与C++源文件中的代码相对应的机器语言代码。
这种机器语言代码通常也被称为*目标代码*（*object code*）。

就像我们会把Python程序拆分成多个文件一样，除最简单的C++程序之外的所有程序通常都会被分成多个源文件。
和图8.1里所展示的一样，每个源文件都是会被独立编译的。
一个源文件里可以调用另一个源文件里定义的函数。
这也是使用头文件的主要原因：
通过包含在另一个文件中定义的函数的有关信息，编译器才可以知道你是不是正确的调用了这个函数。
*链接器*（*linker*）的工作是：
把各个机器代码的目标文件组合成一个可执行程序，并且确保每个被调用的函数都存在于其中的一个目标文件里。
大多数操作系统也支持机器代码库——也就是，这个库里包含常用​的​类以及函数的目标/机器代码。
在C++里，输入和输出语句是`iostream`头文件所声明的库的一部分。
在最后，就像图8.1里一样，链接器还会把程序里使用的库里的代码复制到最终的可执行代码里去。

由于生成的可执行程序是机器语言，因此它只能在支持这个机器语言和操作系统的计算机上被执行。
比如，为运行Windows操作系统的英特尔芯片所编译的程序，一般来说，都可以在任何与英特尔兼容的计算机（同一代或更新版本的英特尔芯片）以及相同版本或者更新版本的Windows操作系统上运行。
但是，在英特尔芯片的计算机上为Linux操作系统编译的程序，通常都不能在Windows系统上运行，反之亦然。
对于简单的C/C++程序来说，可以通过针对另一个操作系统或计算机芯片来重新编译，从而达到*移植*（*porting*）程序的效果。
移植程序是指：
让程序能够在不同的芯片或者操作系统上执行的过程。
将代码移植到另一个操作系统的真正困难在于，不同的操作系统有不同的功能库来支持输入/输出以及图形用户界面（Graphical User Interfaces，GUI）。
许多操作系统都提供了额外的代码库。
使用了任何这些特定于操作系统的代码库的程序，通常来说都很难移植到其他操作系统。
在这种情况下，移植程序将会需要把这些库也移植到其他操作系统上，或者重写这部分代码来避免使用这个代码库。

Python代码与机器是无关的，它可以在任何包含Python解释器的机器上被执行。
这就意味着，Python解释器本身就必须要为这个计算机以及操作系统进行单独的移植和编译。
如果你的程序使用了特定于某个操作系统的额外的Python模块（例如仅存在于某个操作系统上的GUI工具包），那么你的Python代码将不能被移植到其他操作系统上。
如果你只使用了Python的标准模块，那么Python程序将能够在不需要对代码进行任何修改的情况下，在任何包含解释器的机器以及操作系统上运行。
当然，就像Python解释器可以在许多不同的系统上编译来支持它们一样，许多额外的模块也是可以被移植到其他操作系统的，很明显，这就需要更多的工作来完成了。

执行Python代码的过程与编译和链接C++代码的过程有很大不同。
图8.2用图像表示了这个过程。
可以看到，你只能直接执行一个Python文件。
但是，你可以通过导入其他Python文件，来有效地组合多个源文件的代码。
Python源代码首先会被编译成与机器无关的指令集，它们被称为*字节码*。
当你运行Python程序或者导入Python模块的时候，都会自动发生这个过程。
你可能已经发现了，在你的计算机里有一些以.pyc为扩展名的文件，这些就是导入Python模块的时候，所创建的字节码文件。
一个字节码指令可以对应着的是：
函数调用，或者是添加两个操作数之类的代码。

>        Python     Python
>        源文件      源文件
>          |          |
>          |          |
>          |          |
>          |          |
>        Python     Python
>        翻译器      翻译器
>          |          |
>          |          |
>          |          |
>          |          |
>        Python     Python
>        字节码      字节码
>            \        |
>              \      |
>                \    |
>                  \  |
>                   Python          以机器代码
>                   翻译器  ------- 方式分发的库
>                     |
>                     |
>                     |
>                     |
>                  可执行的
>                  机器代码

图8.2：Python编译和解释的混合过程

在编译成字节码之后，Python解释器就会开始处理与程序里的第一个语句所对应的字节码。
每次处理字节码语句的时候，这段代码都会被转换为机器语言，进而被执行。
就是在这个过程里，解释器解释了每一个字节码语句，并且在每次执行字节码的时候都把它转换为机器语言，这也就是为什么Python代码的执行效率比编译过的C++代码要慢的原因。
然而，字节码可以比纯粹的Python源代码更快地被转换为机器语言。
这也就是为什么Python会一次性地先把所有的源代码都转换为字节码，而不是在执行每一个Python语句的同时将它转换为机器语言的原因。

在之后，就像图里所展示的那样，你的Python代码可以调用已经编译好了的在机器代码库里的C或C++代码。
这也就能够让你在自己的程序里混合使用Python、C和C++三种代码。
编写可以被Python解释器调用的C或C++代码需要遵循一些特别的约定，我们不会在书里详细介绍这一部分内容。
对于任何你希望在Python里调用的C或C++代码，都必须要在对应版本的操作系统以及相应的芯片上进行编译。

当在Python里编写显式地循环调用时，Python和C/C++之间的执行的速度差异将会变得非常明显。
因此，对于大型迭代来说，最好是调用内置的Python方法或函数，而不是直接编写这个循环，来执行相应的操作（如果存在的话）。
这是因为Python里内置的方法或函数都是通过编译了的C代码来实现的。
比如说，你应该已经注意到了，1.3.1节里我们手动编写的线性搜索功能，和使用`index`方法的性能差别。
总之，权衡应该使用Python还是C/C++的主要因素是：执行速度和代码量以及开发时间之间的关系。

Python和C++的基本语句是类似的。
因此，对于Python程序员来说，学习如何阅读C++代码相对会比较容易。
然而，学习如何编写C++代码会比较困难，这是因为，编写相应的代码需要你去学习C++的具体语法细节。
但是，Python程序员学习C++还是会比没有编程经验的人更容易。
毕竟，已经了解了一种编程语言的程序员也就已经理解了一些基础知识，像是：
决策语句、循环、函数这类的常用概念。
许多编程语言，包括C，C++，Python，Java，C#以及Perl，它们都使用了相似的语句和语法来让这门语言能够和其他语言一样易于学习。
我们通常会认为Python是初学者的理想语言，因为它的语法够简单；
C++是一种很好的第二语言，因为它类似于Python；
但又同时能够让大家获得Python解释器所隐藏的底层编程细节的相关知识。

这一章和接下来的几章里所介绍的许多C++的概念一般来说也同样会适用于C语言，但并不是全部的概念都相通。
具体来说，输入/输出机制在C和C++里是不同的，这是因为C语言并不完全地支持类。
这本书里不会涉及到在C语言里的输入/输出、或者是C语言里的类的简化版本——结构。
书里的这些关于C++的章节并不是为了让你了解C++语言的所有细节，而是为了能够让一个Python程序员可以快速的开始使用C++语言，并且帮助你了解显式的内存管理的细节。
要成为C++专家，我们建议你去阅读比如像是比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）撰写的C++的参考书这样的相关书籍。
由于C++是一种相当复杂的语言，因此在编写完整的C++程序之前必须要掌握许多的相关知识。
我们将在学习过了Python的基础之上开始介绍这些概念。

## 注释、代码块、变量名和关键字

C++支持两种类型的注释。
和Python里的`#`注释标记相对应的是两个正斜杠（`//`）。
一行里从两个正斜杠开始到行尾的任何字符都将被视为注释，从而被编译器所忽略。
同时，C++编译器还支持多行注释。
这种注释以`/*`开头，以`*/`结尾。

```C++
// this is a one-line C++ comment

/* this is a
multi-line
C++ comment */
```

Python使用缩进来表示代码块。
而在C++里，它使用大括号对（`{}`）来标记代码块的开头和结尾。
在C++中，缩进除了让代码更易于阅读之外，不会有任何效果。
因此，为了易读性，程序员们通常还是会遵循和Python相同的缩进规则。
空白（空格、制表符和换行符）除非是在字符串里，不然对C++代码也不会产生影响。
而由于空格，制表符和换行符在C++中没有任何作用，因此，每个C++语句都必须要以分号作为结束。
于是，对于熟悉Python的程序员来说，在语句结束的地方忘记了分号是非常常见的一个错误。
更麻烦的事情是，当你忘记分号的时候，许多C++编译器都会显示在下一行代码里存在问题。
因此，在跟踪编译错误的时候，通常需要查看编译器指示存在错误的代码行的上面一行或多行代码。

合法C++变量名的规则与Python的规则是相同的：
变量名必须以字母或下划线开头；
在首字母或下划线之后，后续的字符可以是字母，数字或者是下划线；
除此此外，变量名也不能是C++的关键字。
图8.3列出了所有C++的关键字。[^1]
但是在本书里，将不会涵盖所有C++的关键字的详细信息。

> [^1] 这个关键字列表来自于比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）所著的《The C++ Programming Language》（位于马萨诸塞州雷丁镇的艾迪生韦斯利出版社1997年出品），第三版。794。

图8.3：C++的关键字

## 数据类型和变量声明

和Python不同的是，C++要求所有变量在使用前都必须要被显式地声明。
C++支持这些内置的数据类型：
`int`、`char`、`float`、`double`以及`bool`。
在使用指定的数据类型声明变量之后，变量就只能保存这个类型的数据值了。
`int`类型对应于Python中的整数类型，并且也支持相同的操作，包括模数运算符（`%`）。
但是，与Python不同的是，Python里的整数会根据需要自动地转换为长整数，而对于C++的`int`类型如果值太大而无法存储的时候会静默地溢出。
C++的int类型必须至少使用16位内存，也就是说它的合法的值大约在为+/-32,000之间。
然而，大多数系统使用的都至少是32位，也就是说它的可以存储的合法的数字在+/-20亿这个范围之内。
另一个类型`char`类型则会被用来存储单个字符。
在内部，它存储的是字符的ASCII值，因此`char`变量可以存储介于-128到127之间的值。

C++的`int`类型还支持修饰符`short`和`long`。
在大多数32位系统里，`short int`是16位，`int`是32位，而`long int`也是32位。
它们的区别是：`long int`类型保证至少使用32位内存，而`int`仅仅保证至少使用16位内存。
`int`和`char`类型也都支持`unsigned`修饰符，这个修饰符被用来表示变量只支持非负数，从而允许更大的值。
`32`位`unsigned int`可以支持从0到大约40亿的数字，而不是+/-20亿之间的值。
相对应的，`unsigned char`则可以存储0到255之间的值。

`float`和`double`数据类型对应的是被数学家们称为实数的类型，但是在计算机里，它们并不是被完整的存储的。
这是因为，在内部它们只能使用0和1的位来表示这个实数，因此，它们其实被称为*浮点数*（*floating point number*）会更适合。
`float`类型使用32位内存来存储数字，并且提供6位或7位有效十进制数字。
`double`类型使用64位内存来存储，并且提供15位或16位有效数字。
在Python里，它使用的是C语言的`double`类型来实现的浮点数。
这是因为，现代计算机都具有足够大的内存，并且现在大多数浮点运算都是在硬件中实现的，所以在几乎所有情况下都应该使用`double`类型而不是`float`类型。
图8.4总结了C++数据类型的一些细节。

| 数据类型 | 通常的值的范围 | 通常使用的字节数 | 备注 |
| ---- | ---- | ---- | ---- |
| int | -2,147,483,648到2,147,483,647 | 4 | 仅限整数值 |
| unsigned int | 0到4,294,967,295 | 4 | 仅限整数值 |
| short int | -32,768到32,767 | 2 | 仅限整数值 |
| unsigned short int | 0到65,535 | 2 | 仅限整数值 |
| char | -128到127 | 1 | 仅限整数值 |
| unsigned char | 0到255 | 1 | 仅限整数值 |
| float | 大约+/−10<sup>38</sup> | 4 | 包含6位或7位有效数字的实数 |
| double | 大约+/−10<sup>308</sup> | 8 | 包含15位或16位有效数字的实数 |
| bool | `true`或者`false` | 1 | `true`和`false`是常量 |

图8.4：C++的内置数据类型

在C++里，变量可以在代码块的任何一个地方被定义；
之后，就可以从这个地方开始一直到这个代码块的末尾都能访问到它们。
出于对代码格式以及可读性的考虑，许多C++程序员会在代码块的顶部声明这部分代码将会需要的所有变量。
声明变量是通过指定类型，然后在类型之后跟着变量名来完成的。
在声明变量的同时也可以通过用逗号分隔变量名，这样就可以在一行上声明多个相同类型的变量了。
下面的代码片段展示了一个包含变量声明的简单程序。
根据我们之前的内容可以知道，`cout`被用来生成输出，因此，利用你的Python的相关知识，你应该能够猜到这个C++程序最终会输出的内容：

```C++
// output.cpp
#include <iostream>
using namespace std;
int main()
{
  int i, j;
  double x, y;

  i = 2;
  j = i + i;
  x = 3.5;
  y = x + x;
  cout << j << "\n" << y << "\n";
  return 0;
}
```

你可能会想,为什么在C++里要求你声明变量，而Python并不需要你这样做。
要知道，C++代码会被直接编译为机器语言，而机器语言的指令是基于特定的数据类型的。
比如说：
所有的CPU都有用来添加两个整数的指令，而且大多数现代CPU甚至还有添加两个浮点数的指令。
一些老式的CPU没有直接的浮点指令，但是可以通过使用多个整数指令在软件里实现浮点计算，而这样的操作会使浮点运算慢不少。
在这个例子里，编译器需要知道数据类型来为`j = i + i`这个添加两个整数的语句生成机器指令；
也需要知道数据类型来为`y = x + x`这个添加两个浮点数的语句生成机器指令。
因此，指示了数据类型的变量声明，将能够允许编译器编译出正确的机器指令。

而Python解释器则会把这两个相对应的Python添加语句，比如`add i, i`和`add x, x`，转换为相同的字节代码。
也就是说，相同的字节代码会被用来表示这两种不同情况下的`add`语句。
然后，当Python解释器执行这部分字节代码的时候，它才会去确定这两个操作数的数据类型，从而在第一种情况下生成整数`add`指令，在第二种情况下生成浮点`add`指令。
如果两个操作数是字符串，那么它将生成连接两个字符串的机器指令。
于是乎，由于Python在真正执行这个语句之前不会创建机器指令，因此在编写代码的时候，它不需要像C++编译器那样线需要知道数据的类型。
这样，在Python里，即使相应的变量的数据类型在语句的多次执行之间发生了变化，也能够让代码可以正常工作。
下面这个看起来挺蠢的Python程序就表示了这个例子。
在第一次循环的时候，语句`x + x`添加了两个整数，而在第二次循环里它被用来连接两个字符串。
在C++里，如果不为每种不同的数据类型使用单独的变量的话，这段代码是不可能正常工作的：

```Python
for i in range(2):
  if i == 0:
    x = 1
  else:
    x = 'hi'
  print x + x
```

这类问题的术语是*动态类型*（*dynamic typing*）和*静态类型*（*static typing*）。
Python使用了动态类型，这也就意味着变量或名称的数据类型是可以更改的。
相应的，C++使用的是静态类型，也就是说特定变量的数据类型在编译时是固定的，是不能更改的。
Python和C++在处理变量方面的另一个显著区别是：
C++的变量在函数被调用的时候就被分配好了内存，并且在执行函数的时候，这个变量会继续使用相同的内存位置。
然而，纯理论来说，在Python里使用术语*变量*（*variables*）是不正确的，而应该使用术语：名称。
Python的名称是指存储在内存中的某个对象。
在执行Python函数的过程中，名称所引用的内存位置是可以改变的。
我们在4.2节里曾经讨论过这个话题。
在下面这个简单的程序里，名称`x`引用了两个不同地址里的两个不同对象。

```Python
x = 3
x = 4
```

Python的名称在它被使用之前是不会分配相应的内存地址的，而且，在每次把新对象分配给它的时候，这个内存地址都会更改。
然而，C++的变量将会一直使用一个特定的被分配的内存位置，并且在执行期间一直都不会被改变。
因此，相同的内存位置会被用来存储`3`以及之后的`4`。
我们将在第8.7节和第10章里更详细地研究这个问题。

C++还支持常量和编译时的检查，来保证程序不会尝试更改某个值。
用一个例子来表示的话：定义一个常量`const double PI = 3.141592654;`。
在程序里定义了这个常量之后，如果还包含另一个为这个常量赋值的语句（例如，`PI = 5`）的话，那么就会发生语法错误，因此程序将无法编译。
许多程序员都使用全大写字母的名字来表示常量。

C++不像Python那样提供了许多内置的像列表、元组和字典这样的高级数据结构。
C++支持可以被用来构建类似数据结构的数组（在第8.11节里介绍）。
正如你所期望的那样，因为C++是一种面向对象的编程语言，所以它提供了类来让你去封装数据成员和相应的函数。
因此你可以去构建出自己的可以用来操作相应数据的列表、元组以及字典类。
我们将在9.1节里去了解C++类。

## `Include`语句、命名空间以及输入/输出

Python里使用`import`语句来访问另一个文件里编写的代码。
在C++里，将会使用`#include`语句来把不同文件里定义的类和函数声明复制到当前文件里，从而让编译器可以在检查这些函数或者类的时候知道有没有被正确地使用。
包含这些声明的文件称为*头文件*（*header files*）。
头文件除了包含类和函数声明之外，还可以包含一些其他的元素，但我们现在不用去关心这部分内容。
关于函数原型的细节部分将会在8.12节里讨论，它的基本思想是：
函数原型指定了参数的数量，每个参数的数据类型以及函数的返回类型。
函数原型能够让编译器创建一个列表来包含所有存在的函数和类。
因此，当你尝试调用文件里没有被定义过的函数的时候，编译器就可以判断在其他地方是不是已经存在有声明了的具有这个名称的函数，以及你是否使用了恰当的参数来调用这个函数。
同样的概念也同样适用于类的定义，从而让编译器可以确定你是否正确地使用了一个类（也就是，存在一个具有这个名称的类，并且这个类里包含了你使用的这个方法）。
头文件里通常不会包含函数以及类方法的代码，它只会包含相应的声明。
一般来说，会有一个单独的实现文件来包含函数的定义（即函数体）。
但是这个方面也有一些特例，我们将会在稍后的章节来讨论这些特殊情况。
函数和类的实际机器代码将会由*链接器*（*linker*）组合在一起，从而创建可执行代码（如图8.1所示）。
我们将在这一章的后面来介绍一些关于编译以及链接的其他的详细信息。

与Python模块创建的命名空间一样，C++也支持类似的命名空间（`namespace`）技术。
每个Python文件都是它自己的模块，这样也就直接地拥有了自己的命名空间。
C++并不强制要求使用命名空间，但是很多内置的C++类和函数都是在命名空间里定义的。
我们将在选读小节8.17.2里介绍如何编写自己的命名空间的相关细节。
在这部分的内容里，我们将只介绍应该如何使用现有命名空间的基础知识。
最常用的命名空间是标准命名空间，它的缩写为`std`，而且，这个命名空间是C++编程语言的定义的一部分。
由于在`std`命名空间里声明了许多C++内置的函数和类，因此我们需要先知道如何使用命名空间，才能去编写C++程序。

C++使用了函数库来处理输入/输出相关的操作，这就需要包含一个文件来访问这个函数库。
访问这个函数库的最简单方法是将下面这段代码放在文件的顶部：

```C++
#include <iostream>
using namespace std;
```

正如我们前面提到过的那样，`#include`语句能够让C++编译器快速地把`iostream`头文件里的内容复制到你的文件里去，然后编译整个文件。
这个头文件里定义了各种输入/输出相关的函数和类，这些函数和类都位于命名空间`std`里。
C++输出语句使用的是`iostream`文件里定义的`ostream`类的`cout`实例。
`using namespace std`这条语句将会告诉编译器，接下来的代码将允许直接访问`std`命名空间里定义的所有元素。
这就像是Python里的包含语句一样——`from math import *`——它将允许访问`math`模块里定义的所有元素。
如果没有`using`语句的话，就只能使用`std::cout`这样的全称来引用它。
另一个方案是：
在包含语句之后使用`using std::cout`语句。
这将能够让我们在使用cout实例的时候不用去指定`std::`前缀，但对于`std`命名空间里的其他任何成员，都不会允许我们直接访问。
这在Python里也就类似于`from math import sqrt`这样的语句，它将能够让我们访问`math`模块里定义的`sqrt`函数，但不能访问`math`模块里定义的除它以外地其他任何元素。
C++和Python的命名空间（每个Python文件是一个单独的命名空间）之间的主要区别在于：
C++里，即使不使用`using`语句，都始终可以使用全名（`namespace::item`）来访问C++命名空间里定义的元素；
而对于Python命名空间来说，必须使用import语句来允许使用命名空间里的元素。

C++的`cout`实例与Python里的`print`语句，所执行的工作方式是类似的，它们都可以输出变量、表达式以及常量。
Python使用逗号来分隔一个语句里输出的多个元素；
而在C++里，则会使用符号`<<`来分隔在一个语句里输出的多个元素。
同时，C++不会像Python那样对每个以逗号分隔的元素之间自动地插入空格，而且C++也不会像Python的`print`语句那样自动输出换行符。
和Python类似的是，对于任何不在引号内的元素都会被执行。
但是，必须使用双引号来表示C++的字符串。
在C++里，单引号仅被用来表示单个字符（即内置的字符数据类型）。

所有的C++程序都必须要有一个名为`main`的函数（主函数），同时，这个`main`函数还必须要能够返回一个`int`值。
在执行程序的时候，这个函数将会被调用。

把到目前为止我们所学到的概念汇总到一起，你现在就应该能够理解我们的“hello world”代码示例里的大部分语法了。

```C++
// hello.cpp
#include <iostream>
using namespace std;

int main()
{
  cout << "hello world\n";
  return 0;
}
```

和Python一样，C++也使用反斜杠来作为转义字符。
上面的程序里使用了`\n`，从而能够在打印出`hello world`之后输出一个换行符，这样新的输出将会在一个新行里。
C++还允许使用在`std`命名空间里声明的`endl`（如果没有使用`using namespace std`这一行的话，就必须要用全程`std::endl`）来表示换行符。
因此，上面的`cout`语句也可以写成`cout << "hello world" << endl`。
通常来说，会在`cout`输出语句以引号结束的时候使用`\n`，而当语句的最后一项不是字符串常量的时候使用`endl`。使用`"\n"`和`endl`的一个区别是：`endl`将会强制刷新输出缓冲区。
正式利用了缓冲输出，操作系统才可以等一会并在稍后的时间里将输出的数据发送到屏幕（或文件，如果你正在写入文件）里，从而提高整体效率。
当程序正常退出的时候，输出缓冲区会被刷新，但如果遇到了程序崩溃，你就可能看不到程序已经生成的某些输出了。
而这样，你就可能会认为你的程序崩溃的地方早于实际崩溃的位置了。
因此，如果你使用`cout`语句来帮助你跟踪程序崩溃的位置的话，你就应该需要使用  `endl`来换行。

与`cout`实例类似的，C++还有一个在`istream`类里`cin`实例，它也是标准命名空间的一部分，用于输入。
符号`>>`用来分隔多个输入的值。
`cin`语句使用空格来分隔多个值，并跳过任何空白（空格、制表符或空行）来查找下一个数字、字符、字符串等等。
下面的程序和执行输出示例表示了你在第一门编程课程里所学习过的程序以及它的执行结果。
在这里，我们使用符号`␣`来表示源代码和输出里的空格的位置，这是因为`cout`并不会像Python的`print`语句那样自动输出空格以及换行。

```C++
//␣ctof.cpp
#include␣<iostream>
using␣namespace␣std;
int␣main()
{
␣␣double␣celsius,␣fahrenheit;
␣␣cout␣<<␣"Enter␣Celsius␣temperature:␣";
␣␣cin␣>>␣celsius;
␣␣fahrenheit␣=␣9.0␣/␣5.0␣*␣celsius␣+␣32.0;
␣␣cout␣<<␣celsius␣<<␣"␣degrees␣Celsius␣is␣";
␣␣cout␣<<␣fahrenheit␣<<␣"␣degrees␣Fahrenheit\n";
␣␣return␣0;
}
```

```
Enter␣Celsius␣temperature:␣22.5
22.5␣degrees␣Celsius␣is␣72.5␣degrees␣Fahrenheit
```

如果我们将`celsius`变量声明为`int`类型，那么用户就只能输入整数值。
这样做的话，会让这个程序不那么通用。
因此，在声明变量的时候，你应该问一问自己，这个变量可能值是什么。
如果它可能是浮点值的话，那么就应该使用`double`类型；但如果它只会是整数的话，就应该使用`int`类型。

当使用`cin`来输入多个值的时候，用户可以输入任意数量的空白来分隔各个值。
用户可以通过输入一个或多个空格或者制表符来分隔的两个值，或者是在输入每个数字后按回车键（`Return`）来输入数据。
与Python类似的，在按下回车键之前程序不会去处理输入操作。
下面是一个完整的代码示例，它展示了如何使用`cin`语句来输入的两个值。
我们将把这个程序基于特定输入的输出作为练习。

```C++
// input1.cpp
#include <iostream>
using namespace std;
int main()
{
  double x, y;
  cout << "enter x and y: ";
  cin >> x >> y;
  cout << "x = " << x << " and y = " << y << endl;
  cout << "x + y = " << x + y << endl;
  return 0;
}
```

在C++里使用`cin`输入值会跳过空白这个现象，在使用它输入字符的时候会有一些麻烦。
在读取数字的时候跳过空白肯定是应该的，但是，由于输入的值也是`char`数据类型，因此在使用`cin`读取`char`数据类型的时候，用户没办法让自己输入的空白存储在`char`类型的内存空间里。
比如说，如果用户在执行下面这个程序的时候输入的是`x␣y␣z`的话，程序的输出将会是`xyz`，而不是你所猜想的`x␣y`。

```C++
// input2.cpp
#include <iostream>
using namespace std;

int main()
{
  char a, b, c;

  cin >> a >> b >> c;
  cout << a << b << c;
  return 0;
}
```

## 编译

我们已经介绍了足够的背景知识了，因此你已经可以开始自己编写简单的C++程序了。
我们在这里将会简单地讨论一下应该如何在你的计算机上编译程序。
目前，三个最常用的操作系统分别是Microsoft的Windows，Unix/Linux以及Mac OS X。
这些操作系统都提供了相应的应用程序来编辑和编译程序。
微软销售的是一个当前叫做Visual Studio的开发环境的完整版本。
同时，它还提供了一个免费但有限的版本，是Visual Studio Express。
如果你使用的是Microsoft Windows，那么，你可以从Microsoft的网站上下载这个软件。
尽管它没有完整版本里的所有功能，但对于这本书里的所有C++的示例和练习，它应该是够用了。
Apple向所有人都免费提供了名为Xcode的完整开发环境。
它可能已经预先安装在了你的Mac计算机上，如果没有的话，你也可以从Apple的网站下载（在撰写这本书的时候是需要注册的，但是是免费的）。
Unix有许多不同的操作系统。
我们不会在这本书里介绍Unix的历史，但你需要知道不同的公司会销售略有不同的Unix版本。
事实上，Apple的Mac OS X就是建立在Unix操作系统之上的。
Linux操作系统是Unix系统的免费克隆版本。
在这本书里，我们将会使用术语Unix来代表包括Linux在内的所有Unix系统。

Visual Studio和Xcode的图形开发环境会随着时间的推移而发生变化，因此我们不会在这本书里详细介绍如何使用这些应用程序来编写和编译C++代码。
因为是图形开发环境，因此你自己就可以很容易地，或者在别人的指导下，弄清楚应该怎么使用它们。
在大多数的Unix系统上，GNU g++编译器会被用来编译C++程序。
当然，也有适用于各种Unix系统的商业级的C++编译器。
严格来说，Mac的Xcode也只是g++编译器的图形化前端，因此，你可以在Mac上直接通过终端来使用g++。
由于g++的命令行用法在几年内都没有改变，所以我们将会介绍一下g++在Unix系统上编译C++程序的基本用法。

C++程序的文件扩展名通常使用.cpp，.C以及.cc。
在这本书的各个例子里，我们将使用.cpp扩展名，这是因为它被三个常用操作系统上的编译器所使用。
对于不使用任何其他库，被称作`program.cpp`的单个文件来说，如果你的程序在语法上都是正确的话，命令`g++ program.cpp -o program`将会使用C++源文件`program.cpp`来创建一个名为`program`的可执行文件。
你可能还记得这一章开头的编译相关的话题里提到的多个步骤：
预处理、编译以及链接。
我们指定的g++命令执行了所有步骤。

根据Unix系统上的`make`的版本，指令`make program`也可能会产生相同的结果。
但要记住，`program.cpp`文件里必须要包含一个`main`函数，这是`program`文件开始执行的地方。
要执行这个程序的话，可以键入`./program`然后按回车键。
在可执行程序名称前面的`./`是用来确保操作系统在当前目录中执行这个程序的最安全方法。
当然，根据你的Unix帐户的设置，你可能也可以只输入`program`来执行这个程序，但我们还是建议你养成输入`./program`的习惯，因为，不论配置是怎样的，这个指令都是有效的。

和Python类似的，我们最好把大的应用程序拆分为被良好组织的许多较小的源文件。
就像我们在这一章的开头里提过的那样，C++里的每个文件都会被单独编译，从而为这个文件中的C++代码生成相应的机器语言代码。
那么，在使用`g++`的时候，每个以.cpp扩展名结尾的源文件都可以通过使用`g++`命令的`-c`标志来编译出一个扩展名为.o的目标文件。
这个命令对应着预处理和编译这两个步骤。
如果你不使用`-c`标志的话，`g++`的命令将会去尝试执行预处理、编译和链接三个步骤。
然而，在你有多个源文件的时候，链接这个步骤是你不想执行的。

图8.5展示了如何编译两个源文件，这个例子里，main函数是在test_sort.cpp文件中。
最后一行的指令是执行链接步骤，它将会去检查test_sort.o文件是否包含一个叫做`main`的函数，以及所有文件调用的每个函数在这些.o为后缀名的文件里都只出现了一次。
在这个例子里，我们还在`g++`命令里添加了`-g`标志，因此它的输出将会包含符号名称。
这就让调试器能够提供有关变量和函数的实际名称的相关信息，而不仅仅是存储它们的内存地址。

```Bash
g++ -g -c test_sort.cpp
g++ -g -c sort.cpp
g++ -g test_sort.o sort.o -o test_sort
```

图8.5：编译多个源文件

和大多数重复性的任务一样，这个过程也可以被自动化。
Unix操作系统提供了`make`命令，这个命令可以被用来重新编译自上次创建相应目标文件以来被修改的源文件，并且链接所有的目标文件。
`make`命令将会查看名为`Makefile`或`makefile`的文件，这个文件被用来描述应该如何从源文件创建可执行文件。
图8.6展示了用于图8.5中的排序例子的`Makefile`文件的内容。

图8.6：`test_sort`的makefile

这本书里不会去涵盖makefile的所有的细节，但这个文件的基本思路是：
带冒号的行里，在冒号的前面有一个文件的名称，冒号的后面的若干个文件名则被用来表示这个文件所依赖的文件（也就是说，如果冒号后的文件被修改了，那么就需要重新生成冒号前的文件）。
带冒号的行的下面一行用来指定如何生成上一行的冒号之前的那个文件，并且这一行必须用制表符作为开头（就是说，你不能用空格来对这一行进行缩进）。
当你输入了`make`并按回车键之后，它就会去构建`makefile`里列出的第一个元素（在这个例子里，它会去构建可执行的test_sort文件）。
你还可以通过在`make`命令里带另一个名称来告诉它应该构建之后输出其他名称（也就是，你可以输入`make linear_sort.o`并执行它，它就会创建一个名为`linear_sort.o`的文件）。
通常来说，`clean`指令会删除所有添加的目标文件和可执行文件，因此你可以通过键入`make clean`命令来删除所有对象，然后使用所有的源文件重建整个可执行文件。
你可以在大多数介绍Unix的书籍或者是网络上找到有关makefile的更多详细信息。
但是，如果你使用的不是Unix系统的话，集成开发环境（integrated development environment，IDE）一般都会有用来自动编译程序的构建系统。

```Bash
test_sort: test_sort.o sort.o
        g++ -g test_sort.o sort.o -o test_sort

test_sort.o: test_sort.cpp
        g++ -g -c test_sort.cpp

sort.o: sort.cpp
        g++ -g -c sort.cpp

clean:
        /bin/rm -rf test_sort *.o
```

## 表达式和运算符优先级

表达式在C++里和Python里是类似的，但是，C++不支持任意数据类型的赋值，而且也用了不同的布尔运算符。
C++赋值语句的语法和Python是一样的，只是C++里并不支持元组赋值语法；
C++表达式右侧的数据类型必须与分配给它的在左侧的变量的数据类型相互兼容。
再有的是，C++语言的赋值运算符的左侧只能有一个变量。
要在C++里完成像Python语句`x, y = y, x`这样的功能，就必须要使用一个临时变量。
下面这段C++代码展示了这一点。

```C++
// swap.cpp
#include <iostream>
using namespace std;

int main()
{
  int x = 3, y = 5, temp;
  cout << x << " " << y << endl;
  temp = x;
  x = y;
  y = temp;
  cout << x << " " << y << endl;
  return 0;
}
```

这个程序的输出是：

```C++
3 5
5 3
```

在这个示例里，你可以看到所有变量都必须要事先声明，当然在声明语句里，也可以同时为变量分配一个初始值。
C++也像Python一样支持这样的赋值语句：`x = y = z`。
它代表了`y`被`z`的值给赋值，然后`y`的值又赋值给了`x`。

如果忘记了在表达式里使用变量之前赋值的话，通常会产生一些奇怪的结果。
下面这个程序在编译以及执行的时候都没有任何错误，但会产生不确定的结果。
比如，在某一次执行的时候，它可能会输出`134514708`，而另一次的执行则会输出`-3456782`。

```C++
// uninit.cpp
#include <iostream>
using namespace std;

int main()
{
  int x, y;

  y = x;
  cout << y << endl;
  return 0;
}
```

通常来说，在函数内部声明的本地变量被称为*自动变量*（*automatic variables*）。
函数在开始的时候，会为自动变量分配一个内存位置，但不会对这个变量使用任何的值进行初始化。
因此，在为它们分配一个值之前，它们将一直保留在函数启动时这个内存位置里的任何值。
这也就是为什么在每次运行上面那个例子里的程序的时候，你都可能会得到不同的结果的原因。
这种在C++里会发生的编程错误在Python里是没有的。
因为，在Python里，如果第一行代码就是`y = x`的话，那么将会抛出`NameError`异常，这是因为名称`x`并不存在。

前面有提到过，C++里支持的运算符和Python支持的运算符除了一些较小的语法差异（例如，表示逻辑与（`and`）的`&&`，表示逻辑或（`or`）的`||`，以及表示逻辑否（`not`）的`!`）基本上是相同的。
运算符的优先级规则也是相同的，但是C++支持一些Python里没有的其他运算符。
比如，C++提供的两个加号运算符是增量和减量运算符，这些运算符有前缀和后缀两个版本。
它们可用被用来让整数变量的值加`1`或者减`1`：
加一的增量运算符是`++`运算符；相对应的，减量运算符是`--`运算符。
这些运算符可以和赋值语句一起混用，也可以不和赋值语句一起混用。
下面这个例子展示了增量运算符、减量运算符的工作方式是完全相同的，只是它们的作用一个是增`1`另一个是减`1`而已。
看这段代码的时候要注意的一点是，前缀版本和后缀版本的增（减）量操作符的差异在与赋值语句一起混用的时候非常关键。
所以，许多C++程序员为了让代码更清晰，会避免把增量和减量运算符和赋值语句一起使用。

```C++
// increment.cpp
#include <iostream>
using namespace std;
int main()
{
  int a, b, c, d;
  a = 2;
  b = 5;
  a++; // increments a to 3
  ++a; // increments a to 4
  c = ++b; // increments b to 6 and then assigns 6 to c
  d = c++; // assigns 6 to d and then increments c to 7
  cout << a << " " << b << " " << c << " " << d << endl;
  return 0;
}
```

Python里的所有的名称实际上都是对相应内存位置的引用。
而每个C++的变量都是指向了保存实际值的内存位置。
将一个变量赋值给另一个变量的时候，在Python里这两个变量都会引用相同的内存位置；然而在C++里，赋值运算符会把数据从赋值语句的右侧变量的内存位置复制到左侧变量的内存位置。
还好，在只使用不可变类型的时候，C++和Python之间的这种差异并不太明显。
与Python的引用的相应的功能在C++里就是指针变量。
你可以把引用理解为一个不带指针符号的指针。
在第10章的内容里，我们将会介绍关于自动变量、引用以及指针的内存使用和分配的详细信息。

## 条件语句

和Python一样，C++支持相同的基本条件语句——`if`语句。
虽然有一些语法差异，但是，整个语句的语义还是相通的。
比如说：在Python里的`elif`，在C++里使用的两个单词的`else if`。
此外，C++还要求用括号把布尔表达式括起来，而Python不需要这样做。
我们提到过，大括号对`{}`被用来标记代码块，因此，它也被用来指示当`if`语句的布尔表达式为真的时候，应该执行哪些代码。
但是，C++里有一个特例，如果`if`语句为真的时候只执行一条语句的话，那么可以不用大括号。
但是，如果在后面又去添加了第二条语句的话，就可能会导致混淆从而产生错误。
因此，许多程序员会通过总是使用大括号来避免这个问题。
下面这个例子展示了这个问题：

```C++
// if1.cpp
#include <iostream>
using namespace std;

int main()
{
  int x = 5, y = 3;

  // incorrect example: misleading indentation
  if (x < y)
    cout << "x is less ";
    cout << "than y\n";
  cout << "the end\n";
  return 0;
}
```

这个程序的输出是：

```C++
than y
the end
```

在这个例子里，缩进是具有误导性的，代码行`cout << "than y\n";`在布尔表达式为假的时候，也会被执行。
要知道，在C++里，缩进并不重要。
要正确编写上面这个程序的话，就需要像下面这样使用大括号了：

```C++
// if2.cpp
#include <iostream>
using namespace std;

int main()
{
  int x = 5, y = 3;
  if (x < y) {
    cout << "x is less ";
    cout << "than y\n";
  }
  cout << "the end\n";
  return 0;
}
```

这个程序的输出是：

```C++
the end
```

在这段代码里，左大括号的位置并不是统一的。
一些程序员喜欢把它放在与`if`语句相同的行，而其他一些程序员则喜欢把它放在下面一行。
但是，几乎所有人都同意：右大括号应该在独立的一行上，并且应该与`if`语句（或者`{`如果左大括号在单独的一行上的话）相互对齐。
许多程序员即使会把`if`语句以及其他的一些C++语句的开头的左大括号放在与语句相同的行上，他们也会像我们例子里的`main`函数的左大括号一样，把函数开始的那个左大括号放在单独一行上。
大多数公司都会选择其中一种方案，之后就会要求他们的程序员遵循这个代码风格，从而保证一致性和易读性。
下面这个例子和上面的例子是一样的，只不过它的左大括号都在单独的一行上：

```C++
// if3.cpp
#include <iostream>
using namespace std;

int main()
{
  int x = 5, y = 3;
  if (x < y)
  {
    cout << "x is less ";
    cout << "than y\n";
  }
  cout << "the end";
  return 0;
}
```

我们提到过C++里缩进并不重要，但C++程序员通常还是会遵循与Python程序员相同的缩进规则，从而实现更好的可读性。
虽然，Python允许任意数量的缩进来表示新的代码块，但大多数Python程序员都会使用四个空格来作为每一级缩进。
然而在C++程序里，并没有一个标准，程序员们会使用两个、三个、四个或者八个空格来作为缩进的级别，当然八个空格通常会用输入制表符键来表示。
这本书里的示例都会使用两个空格作为缩进的级别，这是因为，我们认为大括号已经提供了额外的视觉提示来表示代码块。
而且，更少的空格也意味着嵌套的代码块即使有更长的代码也不会超过80列（大多数程序员将代码行的长度限制在80列）。

如果在C++里没有遵循与Python相同的缩进规则的话，那么对于嵌套的`if/else`语句的语义来说，缩进可能反而会产生一些误导。
在Python里，缩进清晰地表明了`elif`或`else`语句与`if`语句之间的匹配关系。
在C++里，匹配`if`和`else`语句的规则基本上和Python是相同的。
你只需要记住大括号标记了代码块，而且即使没有大括号，`if`或`else`语句之后的单个语句也可以是它自身的代码块。
我们可以这样来描述这个规则：`else`语句将会和它上方最接近的那个处于同一级的大括号的`if`语句相互配对​​。
下面这个例子只是一个代码片段，因为它不包含`main`函数和一个完整程序的所有必须的语句，所以它并不是一个完整的程序，因此它也不会通过编译。
但是，它在没有使用额外代码的情况下展示了一个编程理念。
下面代码里的`else`语句与哪一个`if`语句相匹配？

```C++
if (x < y)
  if (y < z)
    cout << "a";
else
  cout << "b";

if (x < y) {
  if (y < z)
    cout << "a";
}
else
  cout << "b";
```

第一个`else`语句与它上面两行的`if (y < z)`语句相匹配。
可以看到，这条语句是这个`else`语句的同一级大括号的上方最接近的`if`语句。
基于同样的理由，第二个`else`语句与它上面四行的`if (x < y)`语句相匹配。
这个`else`语句和它上面两行的`if (y < z)`语句处于不同的括号级别。
这个例子展示了为什么要始终使用大括号的另一个原因：它能够让我们更容易去匹配`else`和`if`语句。

以下这个例子展示了嵌套的`if`语句以及`else if`语句。
基于你对Python的了解以及前面提供的相关知识，这段代码的语义应该是很清晰的（并且，这个程序的执行与它输出是匹配的）。
唯一要注意的是，在C++里，必须用`else if`，而不是像Python那样写`elif`：

```C++
// grades.cpp
#include <iostream>
using namespace std;

int main()
{
  double grade;

  cout << "Enter your grade average (i.e., 93.2): ";
  cin >> grade;

  if (grade >= 90.0) {
    if (grade > 92.0) {
      cout << "Your grade is an A\n";
    }
    else {
      cout << "Your grade is an A-\n";
    }
  }
  else if (grade >= 80.0) {
    if (grade > 87.0) {
      cout << "Your grade is a B+\n";
    }
    else if (grade > 82.0) {
      cout << "Your grade is a B\n";
    }
    else {
      cout << "Your grade is a B-";
    }
  }
  return 0;
}
```

上面的这个例子使用了嵌套的`if`语句，它也可以被一个`if`语句后跟4个不嵌套的`else if`语句来编写。
我们在这里选择使用嵌套的这个版本来展示`else if`语句以及嵌套语句。

Python使用关键字`and`、`or`以及`not`布尔运算符。
而在C++里，它使用符号`&&`、`||`和`!`分别代表为`and`、`or`和`not`。
C++里，等价于Python语句`if (x < 3) and not (y > 4)`的代码是：`if ((x < 3) && !(y > 4))`。
最新的C++编译器也开始在号`&&`、`||`和`!`之外开始支持`and`、`or`以及`not`了。

与Python不同的是，C++允许在`if`语句和循环语句里的判断表达式里使用赋值语句。
这就意味着，即使你并不想要在那个地方进行赋值，C++编译器也不会将`if (x = 0)`作为错误来处理。
这个`if`语句有一个副作用会把`x`赋值为零，然后这个结果会被当作这个布尔表达式。
赋值语句的结果就是所赋的值，因此，这个语句就等同于：`x = 0; if (0)`。
这也就是为什么赋值语句可以链接起来使用（就像`x = y = 0`这样）。
因此，语句`if (x = 0)`的判断将会导致`x`被赋值为零，并且这个布尔表达式永远都会被评估为`false`。
和Python一样，C++会把任何非零的值视为`true`，而将零视为`false`。
例如，语句`if (x = 10)`会把`10`分配给`x`，并且这个判断将会评估为`true`。
这种错误会非常地难以调试。
当使用常量作为判断的时候，一些程序员会写成`if (0 == x)`。
用这种方式书写条件判断，如果忘了一个等号的话就会导致错误。
但是，在你打算写`if (x == y)`，而写成了`if (x = y)`这样的语句的时候，这个错误会没法避免地也会产生。

同样的，C++也支持`switch`条件判断语句，但在这一节里，我们不打算去介绍它。
因为任何可以用`switch`语句编写的逻辑也可以被写成`if`/`else if`语句。
我们将会在选读的8.17.1小节里详细讨论`switch`语句。

## 数据类型转换

在Python里，许多数据类型的转换都是隐式的。
下面的Python代码例子里，在执行`b + c`的时候，从`b`这里拿到的数字`3`将会被隐式地转换为浮点值`3.0`，这是因为操作数`c`是一个浮点值。
但是，名称`b`的值还是会继续保留为整数`3`，只是在计算的时候会被替换。
在语句`d = float(b)`里，存储在`b`里的`3`将会被显式地转换为`3.0`并作为浮点数存储在`d`中。
同样的，`b`里的值仍然是整数`3`。
在语句`e = int(c)`里，`c`的值（`5.5`）将被显式地转换为`5`，并且作为整数存储在`e`里。
当一个浮点数被转换为整数的时候，它小数部分会被截断而不是被四舍五入：

```Python
b = 3
c = 2.5
c = b + c
d = float(b)
e = int(c)
```

C++也支持在表达式里进行显式地转换，以及各种隐式类型的转换。
下面这个C++的例子对应着上面的Python示例。
如果在`d`的赋值语句里不用显式转换，而是直接写为`d = b;`的话，大多数编译器都不会产生错误，但会产生一个警告，这个警告会指出这一行里包含了隐式的类型转换。
当一个值从浮点类型转换为整数类型的时候，C++使用了和Python相同的规则——小数部分会被截断：

```C++
int b, e;
double c, d;
b = 3;
c = 2.5;
c = b + c; // c holds 5.5
d = double(b); // d holds 3.0
e = int(c); // e holds 5; this could also be written as e = (int) c;
```

对变量或者表达式用括号来指定数据类型，虽然说Python和C++里都支持这个语法来进行类型转换，但新的编译器所支持的新版本的C++代码有另一种不同的语法。
下面这个例子里展示了使用了关键字`static_cast`来进行数据类型转换的语法：

```C++
int b, e;
double c, d;
b = 3;
c = 2.5;
c = b + c; // c holds 5.5
d = static_cast <double> (b); // d holds 3.0
e = static_cast <int> (c); // e holds 5
```

## 循环语句

C++支持三种循环语句：`for`、`while`以及`do while`。
`while`循环和Python里的`while`语句基本上是相同的。
因为`while`循环的布尔表达式是在循环体执行之前先检查条件，因此被归类为*前测循环*（*pretest loop*）。
它在Python和C++之间的语法差异与`if`语句的差异是类似的。
在C++里，`while`语句里的布尔表达式必须要放在括号里，而且，C++使用的布尔运算符是`&&`、`||`和`!`（前面提过，新的编译器也支持`and`、`or`以及`not`）。
还有，大括号`{}`而不是缩进也被用来表示代码块。
和C++的`if`语句一样，如果循环体只有一行代码的话，那么大括号就可以被忽略掉，但多数程序员仍然会使用大括号来把这一行代码包括在里面。
下面这个例子是一个包含C++的`while`语句的代码片段。
这一节里的所有循环示例都会输出从`0`到`9`的10个数字。

```C++
int i = 0;
while (i < 10) {
  cout << i << endl;
  i += 1;
}
```

C++还支持一个在Python里没有的`do while`语句。
与`while`循环不同，`do while`语句里的代码总是被执行至少一次。
和前测循环的语法不同，循环的条件检测会在循环体执行之后才会进行，因此`do while`循环被分类为*后测循环*（*posttest loop*）。
它的语法是：

```C++
do {
  // loop body
} while (<Boolean-expression>);
```

如果循环体里只有一行代码的话，`do while`语句也是不需要用大括号来标记循环体的开头和结尾的。
但是，如果循环体里有多行代码的话，就必须要加上大括号了。
这个语句的语义是先执行循环体，然后检测布尔表达式。
如果条件为真，那么会再去执行一次循环体，之后再去检测布尔表达式，以此往复。
对于上面的那个例子，如果用`do while`语句做同样的功能的话，可以被写成：

```C++
int i = 0;
do {
  cout << i << endl;
  i += 1;
} while (i < 10);
```

C++里的`for`循环语句和Python里的`for`语句有很大的不同。
Python里的`for`语句是对一系列元素进行迭代，但是在C++里，`for`语句是一个更通用的循环语句。
实际上，你可以把它理解为是一个类似于`while`的循环。
通过观察下面这个同样输出从`0`到`9`的10个数字的`for`语言的例子，你就可以更好地理解C++的`for`语句了。
图8.7显示了这个代码的流程图：

```C++
int i;
for (i = 0; i < 10; ++i) {
  cout << i << endl;
}
```

>                  |
>                  |
>                i = 0;
>                  |
>                  |
>     |--------> i < 10; ------假------> 循环结束
>     |            |
>     |            真
>     |            |
>     |     cout << i << endl;
>     |            |
>     |            |
>     |           i++;
>     |            |
>     |------------|

图8.7：C++的`for`语句的流程图示例

在`for`语句的括号里有被两个分号分隔开的三个语句。
第一个语句`i = 0;`在`for`语句的这个地方，通常都被用来当作初始化语句，而且它也只会被`for`语句执行一次。
在执行完初始化语句之后，将会开始执行第二个语句，这个语句会被当作布尔表达式。
如果它的结果为真的话，就去执行循环体，在之后就会去执行第三个语句，第三个语句通常也称为*增量操作*（*increment action*）或者是*更新操作*（*update action*）。
在我们的例子里，这个增量语句可以使用后缀版本`i++`，也可以使用前缀版本`++i`。
在这本书里，我们将会像C++的标准模板库的里一样使用前缀版本。
在执行了增量操作之后，第二个语句将会被再次执行。
如果结果还是真，那么就会再一次执行循环体里的代码，接着再执行一次增量语句，然后检查布尔表达式，如此往复。

就像刚才我们提到过的那样，任何`for`循环都可以被重写为`while`循环。
如果你还没有看出`for`循环里的各个语句位置与`while`循环里的语句之间的对应关系的话，你可以再看看那个流程图，以及比较`while`循环和`for`循环的两个代码片段。
C++的`for`语句可以更复杂一些，比如说，可以包含用逗号来分隔的多个初始化语句，以及多个增量语句。
在这本书里，我们将不会去展示这些用法。
一些程序员认为，如果面对的是很复杂的情况的话，应该使用`while`语句来处理。

C++的`for`循环还支持在语句里直接声明循环的迭代变量。
如果这样做了，那么这个变量就只能在循环体内部被访问。
在循环之外，这个变量将不再存在。
下面这个例子展示了这一点：

```C++
for (int i = 0; i < 10; ++i) {
  cout << i << endl;
}
// you cannot access the variable i here
```

类似的，如果你在`for`循环里定义的循环迭代变量和之前已经声明的变量同名的话，那么先前声明的那个变量在循环体内是不可以被访问的，在在循环之后才能被访问，而且会保留在循环开始执行之前的那个值。
正是因为可能导致的混淆，我们不建议你使用在`for`语句里声明变量的这种语法。
这个问题是被称为*作用域*（*scope*）和*生命周期*（*lifetime*）的话题的一部分，我们将会在第8.15节里介绍关于C++的变量的作用域和生命周期的详细信息。

和C++里的`if`、`while`和`do while`语句一样，如果循环体只包含一行代码的话，`for`循环也不需要大括号，但很多程序员仍然会一直使用大括号来包括循环体。
和Python一样，C++也支持终止循环的语句——`break`。
就像在Python里我们建议的那样，只有在增加`break`语句会让循环的可读性提高的时候，才应该使用`break`语句。

## 数组

Python里包含允许对一组数据进行索引访问的列表以及元组。
Python列表还支持排序、查找元素和许多其他有用的算法等等方法。
相对而言，C++的数组虽然也支持索引操作，但是它更底层一些，并且也不像Python列表那样具有很好的灵活性。
比如说，C++的数组里必须包含相同类型的元素，而且它也不支持切片以及使用负数索引来访问数组的末尾的元素。

### 一维数组

C++的数组用方括号进行声明，并且使用方括号来进行访问。
和Python一样，数组的第一个元素的索引是`0`，最后一个元素的索引会比数组的尺寸小一个数字。
在下面的这个代码片段里声明了一个数组，并且为数组里的每个元素都赋了一个值。
这个数组在声明的时候就设置成了固定的等于`10`的大小，里面的元素将会通过索引`0`到`9`进行访问，而且这个数组只能存储整数。

```C++
int i, a[10];

for (i = 0; i < 10; ++i) {
  a[i] = i;
}
````

最新的C和C++编译器支持用一个变量来指定数组的大小，这种数组被称为*可变长自动数组*（*variable length automatic arrays*，这是20世纪90年代后期，称为C99的C语言的更新的一部分）。
在程序运行之后才去指定数组大小的另一种实现方案是：
使用指针和动态内存。
这部分内容将在第10.3节里被介绍。
下面这个代码片段展示了可变长自动数组：

```C++
int i, n;

cout << "Enter size: ";
cin >> n;

int a[n];
for (i = 0; i < n; ++i) {
  a[i] = i;
}
````

与Python不同的是，C++的数组不会对任何索引进行范围检查。
也就是说，如果程序试图在超出数组边界的地方进行访问的话，可能会得到无法确定的结果，从而导致程序崩溃，当然也可能会让程序看起来还在正常工作。
我们将在第10章里详细地讨论这些关于内存方面的错误。
在许多操作系统里，当C++程序崩溃的时候，它是不会像Python那样显示出堆栈跟踪（程序崩溃时所处在的代码行，以及程序执行到那个地方所执行的调用函数的序列）的。
大多数的Unix系统将会创建一个`core`文件，这个文件里会包含有关执行和崩溃位置的相关信息。
在Unix系统上，gdb调试程序可以通过后面这个命令，显示出存储在`core`文件里的堆栈跟踪信息。
这个命令就是`gdb <executable-filename> core`，然后输入bt（“回溯（backtrace）”的缩写）再按回车键。
大多数的集成开发环境（IDE）也都提供可以在程序崩溃时提供堆栈跟踪的编译器和调试环境。

C++也支持像这样的语法：`int a[5] = {0, 0, 0, 0, 0};`，在声明语句里直接初始化数组。
C++里并不支持直接对数组变量进行赋值。
要实现数组变量的赋值的话，就只能去对数组的每一个元素进行赋值，就像下面这个代码片段里做的一样：

```C++
int i, a[5], b[5];

a[0] = 0; a[1] = 1; a[2] = 2; a[3] = 3; a[4] = 4;
// b = a; cannot be used
for (i = 0; i < 5; ++i) {
  b[i] = a[i];
}
```

### 多维数组

C++还支持多维数组，只要系统支持相应的内存空间，这个多维数组的维数并没有任何限制。
声明多维数组的语法和声明一维数组的语法是类似的，只不过每一个维度将会使用一对额外的方括号。
下面的这个代码片段里声明了一个总共包含120个元素的三维数组，并且每个元素都被初始化为了零。

```C++
double a[4][10][3];
int i, j, k;

for (i=0; i<4; ++i) {
  for (j=0; j<10; ++j) {
    for (k=0; k<3; ++k) {
      a[i][j][k] = 0.0;
    }
  }
}
```

### 字符数组

在C++里也可以像C语言那样，用字符（`char`数据类型）数组来表示字符串。
但是，在用C++编程的时候，通常都会使用我们将会在9.2节里介绍的内置的C++`string`（字符串）类。
使用原始的字符数组来表示字符串的时候，字符串的尾部字节将会用零来表示字符串的结尾，因此，这个数组的大小必须要大于你将要存储的最大字符数。
这个零字节由一个字符`'\0'`来表示。
在这里要注意的是，单引号被用来表示单个字符（属于`char`数据类型），而双引号则被用来表示字符串。
由于一些C++代码库的函数使用的不是C++的字符串类，而是C语言风格的字符串（字符数组），因此我们将简单介绍一下C语言风格字符串的基础知识。
下面这个例子展示了一个使用C语言风格的字符串，它允许你输入你的姓名，然后向你说“`"Hello"`”。
但是，这个例子非常的糟糕，这是因为，在这个例子里，有一个可以被利用的缓冲区溢出漏洞。

```C++
// buffer.cpp
#include <iostream>
using namespace std;

int main()
{
  char c[20];

  cout << "enter your first name: ";
  // this code is a security risk
  // a buffer overflow occurs if the user enters
  // more than 19 characters
  cin >> c;
  cout << "Hello " << c << endl;
}
```

如果输入的是`Dave`的话，程序会把字符`D`、`a`、`v`、`e`以及`\0`分别存储在数组的零到四位。
当代码输出变量`c`的时候，它会从这个数组的开头开始，并且依次输出字符，直到它到达了代表着字符串结尾的`\0`。
如果用户键入的字符超过19个的话，那么输入的数据将会超过数组的末尾，也就是说，它会允许用户将数据写入程序里没有分配给这个数据的内存之中。
于是一些聪明的计算机破解程序在某些情况下，会利用这种情况去输入一段可执行代码，从而能够让它们窃取你可能会在程序里输入像密码或者是财务相关的信息这样的私人数据。
这也就是我们推荐使用C++的`string`（字符串）类的另一个原因。
正是基于这样的建议，因此这本书将不会再去介绍关于C语言风格的字符串的其它的细节和操作函数。

## 函数的细节

函数在Python里被用来把代码拆分成较小的子问题，从而避免不断地重复编写相同的代码。
在C++里使用函数具有类似的目的，但是在C++里需要考虑的有关函数的问题会比在Python里要多一些。
就像我们已经看到的那样，所有的C++的可执行语句都必须在函数内被执行，并且每个C++可执行程序都必须要包含一个名为`main`的函数。
我们将会使用一些你不会在Python里使用到的术语来讨论C++里的函数。

### 声明、定义以及原型

与Python不同，除了非局部变量、类的定义以及变量或函数的声明之外，所有的C++代码都只能在函数的内部。
为了能够理解这是为什么，我们就需要先去理解*声明*（*declaration*）和*定义*（*definition*）之间的区别。
区分这两者的一种简单方法是：定义会让内存分配存储空间，而声明只会告诉编译器某个名称的存在及其含义（某种类型的变量、类或是具有参数的函数）。
变量、类和函数可以被多次*声明*，但只能被*定义*一次。
因此，通常称之为的*变量声明*（*variable declaration*），其实严格上来说是*变量定义*（*variable definition*）。
即使在函数的开头列出各个变量以及它的类型，也应该被称为变量定义，虽然很多程序员都会把它叫做变量声明。
定义也可以被当作声明，这是因为它也告诉了编译器一个名称的存在，但是声明并不是定义。

那么，既然我们已经说明了声明和定义之间的区别，现在让我们来看一个包含函数声明和函数定义的简单例子。

```C++
#include <iostream>
using namespace std;

// this is a function declaration
int main();

// this is a function definition
int main()
{
  // this is a variable definition which is also a declaration
  int x;

  x = 42;
  cout << "x = " << x << endl;
  return 0;
}
```

所有的C++函数都必须有一个返回类型（对于`main`函数，会返回一个`int`类型）。
函数声明里就表示了返回类型、名称以及名称之后的括号里的参数。
函数声明以分号结尾，并不包含函数体。
因此，函数声明也称为*函数原型*（*function prototypes*）。
函数声明/原型将会告诉编译器关于这个函数的足够多的信息，因此编译器会知道它的存在，并且可以确定在调用这个函数的时候，有没有正确地使用它。
函数的定义包含了与声明里相同的信息，但是它没有结尾处的分号，而是使用大括号来包含函数的主体。
在我们之前的例子里，我们没有像在刚刚这个的例子里那样包含一个`main`函数的单独声明。
在那些例子里，`main`函数的定义也被当作它的声明。
一般来说，除非有其他代码调用这个函数，通常我们都不会去编写函数的单独声明。

除了在第8.4节里列出的数据类型，以及将要在9.1节里介绍的用户自定义的数据类型之外，C++还支持`void`返回类型。
`void`返回类型在函数不会有返回值的时候被使用。
以`void`作为返回类型的函数里，`return`语句不是必须的，但是也可以包含它。
如果一个非`void`的函数没有返回一个值的话，大多数C++编译器都会产生一个警告，而不会像Python那样，如果函数没有显式的返回一个值，就返回`None`。
和Python类似的，C++的函数也可以有多个`return`语句，而且只要执行了任何一个`return`语句，这个函数就不会继续去执行其他代码，并且控制权会传回给在调用点之后的那个语句。
和Python不同的是，C++的函数只能返回一个值。
这并不是C++的一个重大缺陷，因为，我们可以通过将多个值封装在一个类里，并返回这个类的实例来完成；
或者，也可以使用引用传递（在8.12.3小节里介绍）来解决需要多个返回值的问题。

通常来说，为了能够让你的代码正常编译，都应该编写函数原型。
特别是，如果要在函数声明之前调用这个函数的话，大多数编译器都需要这个函数的函数原型。
当调用一个没有被声明的函数的时候需要原型的原因是因为，编译器必须要去确定有没有使用正确数量的参数调用这个函数，并且这些参数的类型也是正确的。
回想一下你之前学到的Python的相关知识，函数声明或者定义里的参数被称为*形参*（*formal parameters*），而调用这个函数时所使用的表达式或变量被称为*实参*（*actual parameters*）。
下面这个例子展示了，在函数声明或者定义之前调用这个函数会导致的问题：

```C++
// this example will not compile
int main()
{
  double a=2.5, b=3.0, c;
  // the compiler has not yet seen the f function
  // so it cannot determine if f is called correctly
  c = f(a, b);
}

double f(double x, double y)
{
  return x * x + 2 * x * y;
}
```

对于这段代码，大多数编译器在`c = f(a，b)`这一行代码上标错，并提示`f`未被声明。
在这个例子里，有两种方法可以解决这个问题。
最简单的方法是在主函数的上面编写`f`函数，这样一来，函数`f`的定义也会被当作它的声明。
另一种方法则是在主函数之上编写`f`函数的原型，就像下面这个例子里做的一样：

```C++
double f(double x, double y);

// you do not need to list the formal parameter names in the prototype
// this example also shows you that you can declare a function multiple
// times even though you generally do not do this
double f(double, double);

int main()
{
  double a=2.5, b=3.0, c;
  // the prototype allows the compiler to determine
  // that f is called correctly
  c = f(a, b);
}

double f(double x, double y)
{
  return x * x + 2 * x * y;
}
```

函数`f`的原型指出了它的返回类型是一个`double`（双精度浮点）值，并且它需要两个参数，每个参数都是一个`double`值。
就像例子里的注释代码写的那样，你并不需要给形参提供名称，但如果你愿意加上名称也是可以的。
大多数程序员都会指定形参的名称，这是因为参数的名称通常表示着参数所代表的内容。
有一个非常重要的需要注意的点是：原型后需要加上分号，但是在定义函数的时候，右括号后面不需要加上分号。
另外一点需要注意的是，数据类型的名称必须要放在每个形参的前面，在函数的原型或者实现里写成`double f(double x, y)`是不正确的。

刚开始写C++的程序员的一个常见错误是：
把形参声明成了局部变量；像下面这段代码片段展示的一样。
这是不正确的，因为局部变量将会阻止对形参的访问。
你的C++编译器可能会生成一个警告，提示这个变量会影响参数。
有些编译器可能会忽略这个警告，继续编译这个程序，而其他一些编译器则会认为这是一个错误，并且拒绝编译程序：

```C++
#include <iostream>
using namespace std;

void f(int a, int b)
{
  int a, b; // incorrect - compiler error/warning: variables shadow parameter
  cout << a << " " << b << endl;
}

int main()
{
  int x = 2, y = 3;
  f(x, y);
  return 0;
}
```

你可能已经发现了，你引用的头文件里包含的正是你的代码会用到的元素的声明。
比如说，`iostream`头文件里包含了`cout`和`cin`的声明。
但是这些元素的定义并没有包含在这个头文件里。
对于`cout`以及`cin`来说，它们的定义是在机器代码库里，链接器在创建可执行代码时会自动链接这些定义。
我们将在8.13节里介绍如何编写自己的头文件。

### 值传递

C++里参数传递的默认机制是*值传递*（*pass by value*）。
值传递将为每个参数生成一个单独的数据副本。
由于使用了完全独立的副本，因此对函数的形参进行的任何更改都不会被反映在实参里。
这就允许你把形参视为一个附加的局部变量了，因为对它们所做的修改不会影响到程序的其他部分。
和Python一样的，形参和实参的名称是否一致并不重要。
下面这个例子就说明了这一概念：

```C++
// value.cpp
#include <iostream>
using namespace std;

void f(int a, int b) // a and b are the formal parameters
{
  cout << a << " " << b << endl;
  a += 3;
  b += 5;
  cout << a << " " << b << endl;
}

int main()
{
  int x = 1, y = 2;
  f(x, y); // x and y are the actual parameters
  cout << x << " " << y << endl;
}
```

这个程序的输出是:

```
1 2
4 7
1 2
```

### 引用传递

C++还支持另一个参数传递的机制，被称为*引用传递*（*pass by reference*）。
和值传递不同的是，它不会去复制一份数据副本，而是直接传递数据的引用（内存中的地址）。
因此，对形参所做的任何改变都会反映在实参上。
在Python里，如果把可变数据类型（列表，字典或是类的实例）传递给函数，然后再在函数内部进行修改的话，那么这些更改将会反映在实参里。
但是，如果把一个新的实例分配给形参的话，这个改变将不会反映到实参上。
对于C++里的引用传递来说，对形参的任何更改（包括分配一个新值）都会直接反映到实参里。
要表示参数通过引用传递，只需要在形参（不是实参）前放置`&`符号就行了。
而在实参前面放一个`&`符号将会有不同的效果（参见第10.2节）。
下面的例子和前面的例子类似，但是其中的一个参数是通过引用传递的，从而导致了不同的输出结果。

```C++
// reference.cpp
#include <iostream>
using namespace std;

void f(int a, int &b) // a and b are the formal parameters
{
  cout << a << " " << b << endl;
  a += 3;
  b += 5;
  cout << a << " " << b << endl;
}

int main()
{
  int x = 1, y = 2;
  f(x, y); // x and y are the actual parameters
  cout << x << " " << y << endl;
}
```

这个程序的输出是:

```
1 2
4 7
1 7
```

使用引用传递的任何形参的对应实参都必须是一个变量，而不能是一个表达式。
在这个例子里，我们不能用`f(2,4);`。
因为生成数字`2`的副本，并且把它存储在形参`a`的位置是可以的，但问题在于，如果我们更改形参`b`的话，我们并没有相应的实参来进行修改（因为它只是一个常数）。

### 将数组作为参数传递

出于对效率的考虑，C++会自动通过引用传递数组，因此你不需要使用`&`来指定数组是通过引用传递了。
这样，传递的时候就不会去复制整个数组，而是传递一个数组的起始内存地址的副本。
因此，函数对数组所做的任何改变都将会反映在传递给函数的数组里。
这其实和把Python里的可变类型（比如，Python列表）传递给函数是一样的。
你只能改变整个数组的内容，但是不能去更改数组使用的内存位置。
我们通过后面第10章的学习，并且探讨过了关于指针和动态内存相关的内容之后，这部分的细节以及结果将会更加清晰。

你并不需要在数组的形参里指定整个数组的大小，但是，整个函数仍然需要注意在使用的过程中不要超出数组尺寸。
一种常见的解决办法是再传递一个指定数组尺寸的附加参数。
下面的代码通过选择排序的实现来展示了这一方法。
形参（`int a[]`）后面的方括号表示一个不定大小的一维数组将会被传递给它。
你也可以根据需要在这个地方指定一个大小尺寸，但整个值在这里会被忽略掉。
第二个参数表示了整个数组的大小。
由于数组不是值传递的，因此在`selection_sort`函数里对数组进行的修改也会影响到传递的实参上。
整个程序的输出（未示出）将会是按照顺序进行排列的数组：

```C++
// selection.cpp
#include <iostream>
using namespace std;

void selection_sort(int a[], int size)
{
  int i, j, min_pos, temp;

  for (i = 0; i < size - 1; ++i) {
    min_pos = i;
    for (j = i + 1; j < size; ++j) {
      if (a[j] < a[min_pos]) {
        min_pos = j;
      }
    }
    temp = a[i];
    a[i] = a[min_pos];
    a[min_pos] = temp;
  }
}
```

```C++
int main()
{
  int i;
  int a[5] = {7, 6, 4, 2, 3};
  int b[10] = {3, 0, 5, 7, 4, 6, 8, 1, 9, 2};

  selection_sort(a, 5);
  selection_sort(b, 10);
  for (i = 0; i < 5; ++i) {
    cout << a[i] << " ";
  }
  cout << endl;
  for (i = 0; i < 10; ++i) {
    cout << b[i] << " ";
  }
  cout << endl;
  return 0;
}
```

多维数组也可以被传递给函数。
但是，除了第一个维度之外的所有维度都必须要指定相应的大小。
在C++里，多维数组按照*行主序*（*row-major order*）的顺序进行存储。
比如说，对于声明为`int b[2][3]`的数组，它的值在内存中的存储顺序为：`b[0][0]`，`b[0][1]`，`b[0][2]`，`b[1][0]`，`b[1][1]`，`b[1][2]`。
为了能够计算出数组中指定位置的内存地址，我们必须要能够知道除了第一个维度之外的所有维度。
在上面这个例子里，`b[i][j]`的位置是从数组的开始偏移`i * 3 * 4 + j * 4`个字节。
要知道，我们曾经假设过了整数会占用四个字节。
所以，要移动到第i行，我们就必须要移过`i * 3 * 4`个字节，然后还需要移到这一行里相应的点`j`，因此，我们必须再移过`j * 4`个字节。
后面这个函数原型将会接受一个后两个维度的大小分别为`10`和`20`的三维数组：`void f(int b[][10][20]，int size);`。
正是因为不需要第一维的维度来计算元素在数组中的位置的内存地址，因此在形参的数组声明中不需要指定它，同时`size`参数将会被用来指示第一个维度的尺寸。
因此，这个函数里的代码是能够知道作为实参传递的数组的大小的。

### `const`（常量）参数

C++里支持把参数标记为`const`，这意味着函数不能更改这个参数。
这个功能对于让编译器去检查你的代码里是否有意外地去尝试修改这个参数的时候非常有用。
如果你的代码真的修改了标记为`const`的参数，那么这个代码将无法通过编译，并且会生成错误来告诉你相应的原因。
以下示例演示了语法：

```C++
void f(const int a, int b)
{
  a = 2; // this will generate a compiler error
  b = 2; // this is fine
}
```

`const`标记也可以和通过引用进行传递的参数一起使用。
乍一看，这可能非常矛盾，因为当我们想要修改这个参数的时候，才会使用引用传递。
回想一下，按值传递会传递一个数据的副本。
制作一个像`int`或`double`这样的类型的不需要太多的内存的副本不是什么问题，但是，如果需要复制一个包含成百上千字节的变量，需要花费大量的时间，并且还需要大量额外的内存。
通过引用传递的话，会把变量的起始地址作为对现有数据的引用进行传递，而不会去复制整个数据。
并且，无论整个数据的实际大小是多少，在32位的系统上，都只需要四个字节就行了。
因此，如果要传递一个大型的数据结构，但不希望函数去改变它的话，就可以使用`const`标记来通过引用传递整个数据结构。
下面这个例子里，假设我们已经定义了一个名为`LargeType`的类：

```C++
void f(const LargeType &big)
{
  // any changes to parameter big will generate a compiler error
}
```

这也是Python把所有的数据都视为引用的一个原因。
赋值，传递以及返回任何对象的时候，都只需要引用（可能还会有引用计数）就行了。
而不去用去复制像列表或者字典对象里的潜在的大量数据。

### 默认参数

和Python类似的，C++也在函数里支持默认参数。
默认参数允许使用比形参更少的实参来调用整个函数或方法。
在函数/方法的声明里定义的默认值将会被用来代替缺少的实参。
下面这个例子里展示了默认参数的使用方法。

```C++
void f(int a, int b, int c = 2, int d = 3)
{
  // do something with the parameters
}

int main()
{
  f(0, 1); // equivalent to f(0, 1, 2, 3);
  f(4, 5, 6); // equivalent to f(4, 5, 6, 3);
  f(4, 5, 6, 7); // no default values used
}
```

这个例子里有两个必须要始终指定的参数以及两个默认参数。
因此，这个函数允许使用两个、三个或者四个参数来调用。
就像在注释代码里描述的那样，当需要的时候，参数的默认值将会被使用。
与Python一样，默认参数必须是最后的几个参数，只有这样编译器才可以根据顺序来匹配实参和形参。
默认值只会在函数的声明里，而不是在函数的定义里被指定。
除非，函数的定义也同时是它的声明，那么在这种情况下你就需要和前面我们说的那样去设置它们。
下面这个例子展示了当函数的声明和定义都同时存在时，应该如何使用默认参数。
我们将在8.13节里展示另一个和头文件相关的默认参数的例子。

```C++
double f(double x=0, double y=0);

double f(double x, double y)
{
  return x * x + 2 * x * y;
}

int main()
{
  double x=2.5, y=3.0, z;
  z = f(x, y);
}
```

在Python里，你可以使用`* args`传递任意数量的参数，但在C++里，这个情况非常复杂，因此超出了这本书的范围。

## 头文件和内联函数

头文件的用处是声明各个函数、类（类相关的内容将在第9.1节里介绍）以及非局部变量，从而能够让它们在其他的C++源文件里被使用。
在我们之前的例子里包含了`iostream`头文件，现在让我们来看看应该如何编写自己的头文件。
我们将用我们的排序算法作为例子来展示它。
我们将首先在头文件里声明两个不同的排序函数。

```C++
// sort.h
#ifndef __SORT__H
#define __SORT__H

void selection_sort(int a[], int size);
void merge_sort(int a[], int size);

#endif
```

这段代码首先需要注意的是，我们添加了一些新的预处理器命令。
之前我们曾经提到过，预处理器命令是以井号（`#`）开头的。
在这个代码里的`ifndef`行将会去检查是否已经定义了符号`__SORT__H`。
如果没有的话，那么在下一行就会定义符号`__SORT__H`，接下来就是我们的函数声明。
如果已经定义了这个符号，那么在包含这个文件的时候，将不会复制代码行`#ifndef`到`#endif`之间的代码。
这样使用这些预处理器命令是为了防止头文件被包含两次的标准方法。
多次包含一个只含有声明的头文件并不会产生错误，但会降低编译速度，因为编译器需要处理更多行代码。
并且，如果包含了多次含有定义的头文件（比如说类的头文件）的话，也就会导致出现问题，因为我们一个名称只能有一个定义。

虽然在一个文件里不可能并不会直接包含某个文件两次，但是头文件通常也可能包含着其他的头文件。
因此，如果你的头文件包含了文件`<cmath>`，然后在实现文件里同时包含这个头文件以及`<cmath>`的话，那么`<cmath>`文件就被合理地包含了两次。
用来定义的符号的名称并不要求完全遵循`__SORTS__H`这样的模式。
一般来说，会使用下划线以及文件名的组合，来让每个头文件都具有与它相关的唯一符号。

`sort.cpp`文件通常会包含`sort.h`文件，尽管在这个例子里因为这两个函数都不会调用另一个，所以并不需要这么做。
因此，`sort.cpp`文件看起来就应该是：

```C++
// sort.cpp

#include "sort.h"

void selection_sort(int a[], int size)
{
  // code for selection_sort function
}

void merge(int a[], int low, int mid, int high)
{
  // code for merge function
}

void merge_sort(int a[], int size)
{
  // code for merge_sort function
}
```

如果一个文件想要调用我们的这两个排序函数的话，就需要包含头文件`sort.h`并且与编译器生成的`sort.o`文件进行链接。
要注意的是，我们并没有将`merge`函数放在头文件里，这是因为它只会被`merge_sort`函数调用。
下面，让我们用一个简单的例子来使用上面的排序算法。
你可以使用8.6节里列出的`g++`命令在Unix系统上编译以及链接这三个文件。

```C++
// test_sort.cpp
#include <iostream>
using namespace std;
#include "sort.h"

int main()
{
  int i;
  int a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
  int b[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

  selection_sort(a, 10);
  merge_sort(b, 10);
  for (i=0; i<10; ++i) {
    cout << a[i] << " " << b[i] << endl;
  }
  return 0;
}
```

让我们来看看另一个头文件的示例，它能够让我们了解到在使用默认参数值的时候，会经常犯的一个错误。
让我们来编写几个函数来进行温度转换，并且把它们放在一个单独的文件里，这样许多其他程序就都可以轻松地使用它们了。
我们的头文件和实现文件将会像下面这样：

```C++
// conversions.h
#ifndef __CONVERSIONS_H
#define __CONVERSIONS_H

double f_to_c(double f=0.0);
double c_to_f(double c=0.0);

#endif
```

```C++
// conversions.cpp
#include "conversions.h"

// the next line is commented out since it is incorrect
// double f_to_c(double f=0.0)
double f_to_c(double f)
{
  return (f - 32.0) * (5.0 / 9.0);
}
double c_to_f(double c)
{
  return (9.0 / 5.0) * c + 32.0;
}
```

那个常见的错误是：把函数声明直接从头文件里复制并粘贴到实现文件里去。
这样做会导致在实现文件里也指定了默认参数的值。
在例子里，通过注释掉了不正确的代码行，并且添加了没有默认值的正确行，来显示了这一点。
如果在从头文件复制粘贴函数原型的时候忘记了在实现文件里删除默认值的话，C++编译器将给出一个出错消息。

由于这些函数的代码都很短，因此，如果进行函数调用的话，调用函数的开销可能会比执行实际函数代码要花费更多的执行时间。
C++提供了一种被称为*内联函数*（*inline functions*）的机制，从而实现更高效的函数执行。
内联函数通常会直接写在头文件里，并且它的写法与函数在实现文件中的编写是完全相同的。
唯一的不同是，会在函数定义之前放一个关键字`inline`（内联）。
这样一来，它既是一个定义同时也是一个声明。
对于我们的温度转换这个例子来说，使用内联函数的头文件会像下面这样：

```C++
// conversions2.h

#ifndef __CONVERSIONS_H
#define __CONVERSIONS_H

inline double f_to_c(double f=0.0)
{
  return (f - 32.0) * (5.0 / 9.0);
}

inline double c_to_f(double c=0.0)
{
  return (9.0 / 5.0) * c + 32.0;
}

#endif
```

当在头文件里编写了所有的内联函数之后，因为所有信息都包含在头文件之中，于是你就不再需要那个实现（`conversion.cpp`）文件了。
当有多个文件都包含了`conversion.h`头文件的时候，`inline`关键字可以避免函数被创建多个定义。

而且，如果你的内联函数相对较短的话，编译器将生成这段函数体的机器代码，并且把这部分机器代码直接放在代码里，而不会去创建调用这个函数的相关代码。
但是，如果你的函数比较长的话，编译器将会忽略掉你的内联指令，不仅如此，它会创建一个普通的函数调用来调用这个函数。
因为，如果有很多不同的地方都调用这个函数的话，复制这个比较长的函数的机器代码到各个地方，将会使得整个程序更大。
一般来说，小于五行的函数都可以声明为内联函数。

最初的时候，C语言并不支持内联函数，因此，为了实现让短函数不去创建函数调用的相同结果，会使用预处理器宏来定义这些函数。
C++里也支持*宏*（*macro*）命令，因为它也属于C语言，但是，我们还是建议你使用内联函数，因为它们会强制执行类型检查，因此更加安全。
下面这段代码为`c_to_f`定义了宏，并且使用了宏。

```C++
// macro.cpp
#include <iostream>
using namespace std;

#define c_to_f(c) (9.0 / 5.0) * c + 32.0

int main()
{
  int x = 10;
  cout << c_to_f(x) << " ";
  cout << c_to_f(x + 10) << endl;
}
```

`#define`预处理器命令被用来定义宏。
预处理器将会执行搜索，然后替换括号里的元素。
那么，基于这样的逻辑，你认为这段代码的输出应该是什么？

那两行使用宏的代码将会被预处理器扩展为：

```C++
cout << (9.0 / 5.0) * x + 32.0 << " ";
cout << (9.0 / 5.0) * x + 10 + 32.0 << endl;
```

基于这样的扩展，你应该可以知道为什么这个程序的输出是`50 60`了。
而我们期望的输出，`20`摄氏度的正确转换应该是`68`华氏度。
你可以通过在宏里添加更多的括号来解决这个问题，但是，宏仍有其他的潜在问题。
因此，在编写C++代码时，你应该使用`inline`关键字而不是用宏来避免函数调用的相关开销。

在命名空间和头文件之间，还有一个重要问题。
对于头文件来说，你不应该使用`using namespace ...`这样的代码来使用任何一个命名空间。
如果你这样做的话，那么任何包含这个头文件的文件都会被`using namespace`语句所影响。
因此，当源文件定义了一个在这个指定的命名空间里也定义过的名称，就会导致问题发生。
所以，如果你需要在头文件里的使用一个被定义在名称空间里的名称的话，请不要在头文件里包含`using`语句，而是始终使用`namespace::name`这样的语法来引用它。
我们将在9.4节里看到一个关于这点的例子。

就像Python包含了许多很有用的功能的模块那样，C++也提供了一个标准的函数库。
我们已经看到过的在C++语言里用来包含输入和输出代码库的`iostream`头文件。
C++里提供的许多函数都是最初的C语言标准库的一部分，当然这些头文件也专门为C++进行了更新。
C语言代码库的一些头文件被叫做：`stdio.h`、`stdlib.h`以及`math.h`。
要在C++程序里使用这些头文件的话，就需要删除扩展名`.h`，并且在开头添加字母`"c"`。
因此，相应的名称就是：`cstdio`、`cstdlib`以及`cmath`。
例如，要使用C语言的`math`头文件里定义的`sqrt`函数的话，就需要在C++文件的顶部添加这样一行语句：`#include <cmath>`。
当然，还有一些其他的标准C++头文件，其中一些将在后面被介绍到，但这些在`iostream`里被提供的功能是C++程序员屡见不鲜的。

一个标准约定是，对于C++代码库的头文件，以及常见的并且位于标准目录里的代码库，使用小于号和大于号把它们的头文件的名称包括起来。
你的C++编译器还提供了一种可以指定要去检索的其他目录的方法。
一般来说，在大多数系统里，编译器会首先检索你指定的其他目录，然后检索包含头文件的一组标准目录。
在这个检索过程种，第一个与名称匹配的头文件将会被使用。
当头文件与正在编译的C++源文件位于同一目录的时候，必须在头文件的名字两边使用双引号。
对于使用双引号指定的头文件，编译器将会首先检索当前目录。
如果编译器在当前目录中找不到头文件，那么编译器将检索用户指定的其他的包含目录以及标准目录。
对于当前目录里的头文件，你不能使用小于号和大于号来表示它，因为这样的语法在默认情况下是不会去检索当前目录的。
但是，你可以在包含的标准头文件两侧使用双引号，因为这样写会去检索当前目录以及标准目录。
虽然可以在任何情况下都使用双引号，但是通常来说，C++程序员都会遵循对于标准头文件使用小于号和大于号这样的约定。

## 断言与测试

与内置了单元测试框架的Python不同的是，标准C++语言并不包括任何单元测试框架。
好在你可以下载安装许多第三方的C++单元测试框架。
大多数（甚至可能是全部的）这些框架都与Python的单元测试框架是类似的，这是因为，C++和Python的单元测试框架是都基于Java的单元测试框架的。
在这里，我们将会讨论C++的`assert`（断言）语句，而不去覆盖更多的C++单元测试框架，因为断言语句也能允许你轻松编写单元测试。

Python的单元测试框架提供了许多方法来验证某些条件是否为真，并将“assert（断言）”作为其名称的一部分（例如，`assertEquals`和`assertRaises`）。
这些方法其实都是基于C++的`assert`（断言）语句（严格来说，是一个被预处理器扩展了的宏），而这个C++的`assert`（断言）语句采用的是布尔表达式。
如果这个布尔表达式为真，那么程序会继续执行下去；
但如果为假的话，那么程序就会立即退出，并标记出`assert`语句失败的代码行。
C++的assert（断言）语句与Python的单元测试框架不同的是：
Python单元测试框架在其中一个测试失败之后，还会继续运行其他测试，但是使用C++的`assert`语句则会导致程序在断言不成立的时候会立即退出。
也就是说，不会去执行失败的断言语句之后的任何测试。

在这里，我们将会修改8.13节里的`test_sort.cpp`文件来使用`assert`宏命令。
`assert`宏将会接受一个表达式，并且对这个表达式的值进行判断。
如果这个表达式的计算结果为真的话，那么就会继续执行；
如果这个表达式的计算结果为假，程序就会立即退出，并且输出一条错误消息，来指出包含失败的那个断言的代码行。

```C++
// test_sort2.cpp
#include <iostream>
using namespace std;
#include <cassert>
#include "sort.h"
int main()
{
  int i;
  int a[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
  int b[10] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

  cout << "test selection sort" << endl;
  selection_sort(a, 10);
  for (i=0; i<9; ++i) {
    assert(a[i] <= a[i+1]);
  }
  cout << "selection sort passed" << endl;
  cout << "test merge sort" << endl;
  merge_sort(b, 10);
  for (i=0; i<9; ++i) {
    assert(b[i] <= b[i+1]);
  }
  cout << "merge sort passed" << endl;
  return 0;
}
```

要使用C++的`assert`宏的话，就必须要包含`cassert`头文件。
Python的单元测试框架会指示出测试通过与否，但是C++里是不一样的，如果所有测试都通过的话，使用这个简单的方法来做的测试将不会产生任何输出。
如果你需要输出，那么可以就像我们在上面这个例子里做的那样，在每个`assert`语句之后或者在一组`assert`语句之后放一条输出语句，来表示相应的测试已经通过了。
在输出的时候需要记住的是，输出会被操作系统先放在缓冲区，如果程序在操作系统将缓冲区的输出内容发送到屏幕之前就崩溃了，那么你可能就不会看见任何的输出。
所以，需要使用`endl`来输出一个新行，并且强制刷新缓冲区。
因此，在测试代码的时候，始终需要在输出语句的末尾使用`endl`。

如果你要测试许多的函数或者类方法的话，你可能应该创建单独的测试函数来测试每一个方法，然后在`main`函数里调用这些测试函数。
这就像在使用Python单元测试框架那样，会调用所有以`test`这四个字符开头的方法。

## 变量的作用域以及生命周期

变量的*作用域*（*scope*）是指：可以访问它的那部分源代码；
变量的*生存周期*（*lifetime*）是指：从分配变量的内存开始，到释放这部分内存而结束所经过的执行时间段。
C++里变量的作用域和生命周期与Python是类似的。
C++里变量的作用域是声明它的那个代码块。
如果内部代码块声明了的变量与外部代码块里声明的变量同名的话，那么在这个内部代码块里是无法访问外部代码块里声明的变量的。
下面这个例子（输出`2 1`）展示了这一思想，但基于对可读性的考虑，我们建议不要在同一函数的不同代码块里声明两个具有相同名称的变量。

```C++
// scope.cpp
#include <iostream>
using namespace std;
int main()
{
  int x = 1;

  {
    int x = 2;
    cout << x << " ";
  }
  cout << x << endl;
  return 0;
}
```

很多程序员都喜欢在函数的顶部声明变量，那么这些变量的作用域就是整个函数体。
就像8.10节里描述的那样，你可以在`for`语句里声明循环变量，那么这个变量将只能在循环体内被访问。

当声明变量的函数开始执行的时候，C++的自动变量的生命周期就开始了；
同样的，C++的自动变量的生命周期会在函数完成的时候结束。
每次调用函数的时候，它的自动变量会使用的内存都会在一个堆栈上被分配，当函数结束之后，这部分内存将会从堆栈里被释放。
这就意味着在每次调用函数的时候，函数的局部自动变量一般来说都会被绑定到不同的内存位置。
因此，这些变量不会记得在上次调用这个函数的时候的值。
如果你需要函数的局部变量能够有“历史记录”，从而能够记住它在上一次调用里的值的话，就需要使用前缀`static`来声明它。
下面这个例子使用了本地的静态变量`count`来跟踪这个函数被调用的次数。
静态变量的生命周期是这个程序的生命周期。
因此，当程序启动时，将会为变量`count`分配内存，并且会根据函数里的代码把它初始化为零，在程序结束之前，先分配的相同的内存位置将会被一直用于变量`count`。
初始化为零只会在首次为变量分配内存的时候被执行一次，而不会在每次调用这个函数的时候再次执行初始化。
这个变量`count`的作用域仍然在函数`f`里，而它的生命周期是从程序执行开始直到程序结束。

```C++
void f()
{
  static int count = 0;
  count++;
}
```

## Python程序员编写C++时的常见错误

下面是Python程序员在学习C++时常犯的一些错误：

* 在每个语句之后忘记分号

* 在`for`语句的末尾或在`if`或者`while`语句的布尔表达式之后加一个分号

* 在`for`语句的末尾或在`if`或者`while`语句的布尔表达式之后加一个冒号

* 忘记用大括号来标记代码块，或是在标记代码块的大括号后面添加分号

* 忘记`if`，`while`以及`do while`语句里布尔表达式两边的圆括号

* 忘记在函数/方法里将数据类型放在每个形参的前面。
比如说，写成`void f(int a，b)`而不是正确的`void f(int a，int b)`

* 在编写代码时，在函数参数的后面的右括号后面加上了一个分号，或者是在定义的函数原型的时候，忘记了在右括号后面需要分号

* 试图直接把一个数组变量分配给另一个变量。
在需要复制数组的时候，你必须要单独对每个元素进行复制。
在多维数组的情况下，通常会使用循环或嵌套循环来实现

## 其他的C++的相关话题（选读）

本部分章节将会涉及的主题将会为感兴趣的读者提供更详细的C++介绍，但是仍然不会是完整的介绍。
要理解这一节里涉及的主题并不需要对这本书里其他章节的知识做预先了解。

### C++的Switch语句

C++还支持一个Python里没有的决策语句。
C++的`switch`语句不如`if`语句通用。
用`switch`语句编写的任何语句都可以用`if`和`else if`语句来编写，但并不是所有用`if`语句编写的逻辑都可以写为`switch`语句。
下面的这段代码展示了C++的`switch`语句：

```C++
// switch.cpp
#include <iostream>
using namespace std;

int main()
{
  int choice;
  cout << "enter your choice of 1, 2, 3, 4: ";
  cin >> choice;

  switch(choice) {
  case 1:
    cout << "you chose 1\n";
    break;
  case 2:
    cout << "you chose 2\n";
    break;
  case 3:
    cout << "you chose 3\n";
    break;
  case 4:
    cout << "you chose 4\n";
    break;
  default:
    cout << "you made an invalid choice";
  }
  return 0;
}
```

就像在例子里展示的那样，整个语句由关键字`switch`开头，它的后面跟着括号，以及括号内的表达式。
整个表达式必须是一个*定序变量*（*ordinal value*），对于我们编写代码来说，它的类型就必须是`int`、`char`或`bool`，而不能是浮点值或者是字符串。
关键字`case`被用来列出那个表达式的可能的值的其中一个。
如果表达式的值（在我们的示例里就是`choice`的值）与`case`语句的值相匹配的话，那么就会执行这个`case`语句下面的代码。
整个执行将会持续向下，直到遇到了`break`语句或者是到达了`switch`语句的结尾。
当达到`break`语句的时候，程序会继续去执行`switch`语句的右大括号之后的语句（在我们的例子里就是`return 0`）。
关键字`default`被用来表示当表达式的值与任何case语句的值都不匹配的时候，所需要执行的代码。

由于在case语句匹配时，需要使用break语句来表示代码执行的结束，因此可以利用这个情况来编写下面这样的代码：

```C++
// switch2.cpp
#include <iostream>
using namespace std;

int main()
{
  int choice;
  cout << "enter your choice of 1, 2, 3, 4: ";
  cin >> choice;

  switch(choice) {
  case 1:
  case 2:
    cout << "you chose 1 or 2\n";
    break;
  case 3:
  case 4:
    cout << "you chose 3 or 4\n";
    break;
  default:
    cout << "you made an invalid choice";
  }
  return 0;
}
```

由于只有当需要改变代码执行的流程的时候才需要break语句，因此，即使忘记了`break`语句也不会产生语法错误。
但是，这可能会是一个语义错误，就像下面这个例子里这样：

```C++
// switch3.cpp
#include <iostream>
using namespace std;

int main()
{
  int choice;
  cout << "enter your choice of 1, 2, 3, 4: ";
  cin >> choice;

  switch(choice) {
  case 1:
    cout << "you chose 1\n";
    break;
  case 2:
    cout << "you chose 2\n";
  case 3:
    cout << "you chose 3\n";
    break;
  case 4:
    cout << "you chose 4\n";
    break;
  default:
    cout << "you made an invalid choice";
  }
  return 0;
}
```

如果在运行这个程序的时候输入的是2，那么会输出`you chose 2`以及`you chose 3`两条语句。
你可以把所有的`switch`语句都转换为具有相同逻辑的`if`语句。
就像我们在前面提到的，`case`语句后面必须是一个特定的值。
因此，你不能写`case (choice > 0 && choice < 3):`这样的代码。
由于这些限制，虽然`switch`语句可以被用来像在我们的例子里那样——像菜单一样进行选择，但是它并不常用。
另一个需要注意的地方是，在这里，大括号并不会用来标记`case`语句下面的代码块。
这和C++语言在其他地方标记代码块的方式是不一致的。

### 创建C++的命名空间

你可以使用`namespace`关键字来创建自己的命名空间。
下面这个例子就展示了一个命名空间。

```C++
namespace searches
{
  // function/class definitions
  void binary_search()
  {
    // code here
  }
}
```

在命名空间块之外，你有三个方法来访问函数`binary_search`。
第一种是，在每次要访问它的时候，你都可以使用全名`search::binary_search`来使用它。
另一种选择是，在文件的开头放这样一条语句：`using namespace searches`。
这样做会允许你直接使用在`search`命名空间里定义的所有函数以及类等等，而不用在它们前面加上`search::`前缀来使用。
与这个语句对应的Python语句是：`from searches import *`。
第三个办法是，在文件的开头放`using searches::binary_search`语句。
这类似于Python里的`from searches import binary_search`语句。
在C++里这样使用`using`语句的话，将会允许你在没有`search::`前缀的时候访问`binary_search`函数。
但是对于其他定义在`search`命名空间里的名称，你仍然需要使用`searching::`前缀来访问它们。

### 全局变量

虽然使用全局变量通常来说都是一种糟糕的设计，但是C++也支持全局变量。
对于不是那么坏的设计一个例外是：常量通常都会被定义为全局变量。
任何全局变量的生命周期都是程序的整个执行时间。
要创建一个全局变量，就需要在文件顶部，在任何函数代码之外的地方去定义它。
在相同文件里的任何函数都可以访问这个全局变量，如果其他文件使用了`extern`（外部）前缀来声明这个变量的话，那么在其他文件里也可以访问这个全局变量。
如果你希望只在当前文件里访问这个全局变量的话，可以在定义的时候加上`static`前缀。
通常来说，使用`static`前缀定义的全局变量的作用域是它被声明的那个文件。
全局变量和静态变量的内存都是在程序的执行开始之前分配的；
并且在程序的整个执行过程里，相同的内存地址都会被用于这个全局变量以及静态变量的整个生命周期。
你可能已经注意到了，关键字`static`会根据它的上下文会具有不同的含义。

程序里，只会有一个文件可以定义一个具有特定名称的全局变量（就像每个程序只能定义一个具有特定名称的函数一样），但是任意数量的文件都可以通过`extern`来声明这个变量，从而访问这个全局变量。
这是因为，你可能有多个声明，但是只能有一个定义。
下面这个有三个文件的例子展示了全局变量和静态变量的使用。
它还展示了如何使用`extern`来表示被定义在另一个文件里的函数`f`和`g`的原型。
我们并不建议你这样引用函数，你应该使用在第8.12.1小节里讨论的头文件来达到相同的目的。
因此，如果在编译出的对象文件里找不到某个函数，或者是在多个文件里都定义了非外部（`extern`）的函数，那么在任何一种情况之下，你编译可执行代码的链接阶段将会遇到错误：

```C++
// file1.cpp
int x; // this global variable is potentially accessible
       // in any file linked with file1.o
const double PI = 3.141592654; // global constant
static int y; // this variable is only accessible in file1.cpp

extern void f();
extern void g();

int main()
{
  x = 2;
  y = 3;
  f(); // calls f defined in another file
  g(); // calls g defined in another file
  return 0;
}
```

```C++
// file2.cpp
extern int x; // this allows access to the global variable x defined
              // in another file

void f()
{
  x = 3; // sets x declared in another file (file1.cpp in this case)
}
```

```C++
// file3.cpp
extern int x;

void g()
{
  x = 4; // sets x declared in another file
}
```

## 章节总结

这一章里，在你已经了解Python的情况下，我们介绍了许多C++语言的基本语法和语义。
下面是对这些重要概念的总结。

* C++代码需要编译，而Python使用的是混合模式。
Python会先编译成字节码，然后通过解释字节码来执行。

* C++要求你对所有变量进行声明，并且要对它指定类型。
内置的类型有`int`、`char`、`float`、`double`以及`bool`。

* C++使用大括号`{}`来标记代码块。

* C++要求在`if`、`while`和`do while`语句的布尔表达式两边使用括号。

* C++使用`else if`两个单词，而不是像Python那样使用`elif`关键字。

* C++支持基本的数组类型，它可以被用来存储相同类型的数据。
C++的数组类似于Python的列表，但C++的数组并不是一个类。
因此，它只支持使用括号来访问单个元素；
你不能对这个数组进行切片、连接以及使用一个语句来为整个数组进行赋值。

* 声明只是表示了一个标识符名称的类型，而定义则会去（为变量、函数或方法里的代码）分配内存。

* C++支持两种参数传递方法：
会复制参数的值传递，以及会让形参引用实参相同的内存位置的引用传递。

* C++数组作为参数会自动使用引用传递。

* 头文件可以被用来声明函数和全局变量；
我们将在下一章里学习如何在头文件里使用类。

* 变量的作用域是指可以访问这个变量的代码部分；
变量的生命周期是指特定内存位置与变量相关联（绑定）的程序执行时间。

## 练习

**判断题**

1. 所有的C++程序都必须有一个名为`main`的函数。

2. 必须先用类型声明C++程序里会使用的任何变量，然后才能使用它们。

3. C++的函数必须要返回一个值。

4. 一个编译了的C++程序将会输出你所期望的结果。

5. 可以执行一个没有编译的C++程序。

6. 如果C++编译器输出了一个警告，那么它将永远不会编译这个程序。

7. C++编译器的警告应该被忽略。

8. 如果在Intel芯片上的Linux操作系统上编译了C++程序，那么在同一Intel芯片上运行的Windows操作系统的计算机，是可以执行这个生成的程序的。

9. 对于简单的基于文本的程序来说，通常可以在不改变代码的情况下，在不同的计算机结构以及操作系统上直接重新编译C++程序。

10. 通常来说，在同一台计算机上，编译了的C++程序将比类似Python程序执行得更快。

11. 在同一台计算机上，解决特定问题（比如对数字进行排序）的C++程序的执行速度总是比解决同一问题的Python程序更快。

12. 通过引用传递`int`类型比通过值传递`int`类型会更快更有效。

**选择题**

1. 在编写下列程序时，你认为哪些程序用C++语言比使用Python编写快得多？

    a) 将英里转换为公里的程序

    b) 一个循环运行一百万次的程序

    c) 一个循环运行10次的程序

    d) 以上所有程序

2. 如果C++的函数使用了尚未声明的变量，会发生什么？

    a) 代码不会编译。

    b) 执行该函数时，将抛出类似于Python的`NameError`消息的错误消息。

    c) 程序崩溃。

    d) 以上都不是

3. 编译不包含`main`函数的C++文件，会输出

    a) 可执行程序。

    b) 包含这个C++文件的机器代码的目标文件。

    c) 另一个C++文件。

    d) 以上都不是

4. 链接器

    a) 会把头文件复制到C++文件中。

    b) 会把C++文件编译成机器代码。

    c) 组合来自多个文件的机器代码从而产生可执行程序。

    d) 将程序加载到内存中并执行它。

5. C++函数可以返回

    a) 最多一个变量或表达式。

    b) 多个变量或表达式。

    c) 数组。

    d) C++函数不返回值。

6. 以下哪些语句在Python和C++中最相似？

    a) `for`语句

    b) 函数的定义

    c) `if`/`else`语句

    d) `while`声明

7. 对于C++的引用传递机制，以下哪一项不正确？

    a) 对函数的形参的所有更改都会影响到实参。

    b) 会制作一个实参的副本。

    c) 它允许有效地返回由函数计算的多个值。

    d) 它比值引用要慢。

8. 关于C++的数组，以下哪一项是正确的？

    a) 数组可以按值传递。

    b) 数组包括一个对数组里的值进行排序的方法。

    c) 数组里的值必须是相同的类型。

    d) 数组可以通过函数返回。

9. 头文件的主要用途是什么？

    a) 在源文件里注释代码

    b) 声明元素，从而能够让它们可以在C++源文件里被使用

    c) 定义元素，从而能够让它们可以在C++源文件里被使用

    d) 以上都不是

10. 变量的*作用域*是指

    a) 它可以容纳的不同值。

    b) 可以访问变量的位置。

    c) 变量被分配了一个内存的时间。

    d) 变量的名称。

**简答题**

1. 如果用户输入`3.5 4`的话，程序`input1.cpp`会输出（标记出有空格的位置）什么？

2. 下面这个C++程序的输出是什么？

    ```C++
    #include <iostream>
    using namespace std;
    void f(int a, int &b)
    {
      cout << a << " " << b << endl;
      a = a + 2;
      b = b + 3;
      cout << a << " " << b << endl;
    }
    int main()
    {
      int x = 4, y = 5;
      cout << x << " " << y << endl;
      f(x, y);
      cout << x << " " << y << endl;
      return 0;
    }
    ```

3. 五种C++内置的基本数据类型是什么？

4. Python的条件语句和相对应的C++的条件语句之间有什么区别？

5. 在Python和C++里`while`语句有什么区别？

6. Python的`list`类型和C++的数组有什么区别？

7. C++头文件的作用是什么？

8. 术语*作用域*和*生命周期*对于变量的意义是什么？

**编程练习**

1. 编写一个C++程序，打印数字0到9的所有可能的乘法表。

2. 编写一个C++程序，有多少分钱（`0`到`99`之间的整数），然后输出`25`分、`10`分、`5`分以及`1`分硬币的数量，需要让硬币的数量最小化。

3. 编写一个允许用户输入非负数的C++程序（输入每个数字指后按回车键）。
用户输入的负数将会代表这个数字列表的结束。
程序将会输出用户输入的数字（不包括负数）的总数以及平均值。

4. 编写一个C++程序，要求用户为二次方程$a * x^2 + b * x + c = 0$输入它的系数$a$，$b$和$c$，并且输出方程的解。这个程序应该在没有解的情况下有特定的输出。

5. 编写一个C++函数，这个函数会判断输入的`int`参数是否为素数。
用这个函数来编写一个程序，输出小于或者等于用户输入的数字的所有素数。

6. 编写一个C++程序，输入年度投资金额，每年会赚取的利率以及年数。
假设在每年年初投入相同金额并且每年都按照复利计算的话，输出这样投资的最终价值。

7. 修改本章里的`selection_sort`代码，从而让它使用内联函数`swap`来交换两个值，这个函数接受通过引用传递的两个参数。

8. 编写一个名为`linear_search`的C++函数，这个函数会接受一个需要被检索的整数，一个整数数组以及数组的个数。
通过线性搜索算法，函数将会返回数组里第一个参数的值的位置。
如果第一个参数不在数组里，那么函数返回`-1`。

9. 编写一个C++的`binary_search`函数，其参数与上一个练习里描述的`linear_search`函数相同。
它会使用二分搜索算法搜索这个列表，并且返回第一个参数在数组里的位置（如果未找到值，则返回`-1`）。
你必须要对传递给二分搜索算法的数组进行排序。

10. 将`linear_search`和`binary_search`函数放在一个名叫`searches.cpp`的文件里，并使用一个名叫`searching.h`的相对应的头文件。
再创建一个名为`test_searches.cpp`的文件，这个文件将会按照顺序初始化有一百万个整数的数组，然后使用导致每个算法的最佳和最差运行时间的参数来测试这两个搜索算法。

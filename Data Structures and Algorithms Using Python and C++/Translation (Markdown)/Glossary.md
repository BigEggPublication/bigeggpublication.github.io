# 词汇表

* **抽象数据类型**（**Abstract Data Types**）
与任何特定实现无关的数据类型的描述。

* **抽象**（**Abstraction**）
有目的地隐藏或忽略一些细节，以便专注于那些相关的细节。

* **实参**（**Actual Parameters**）
出现在函数调用里的参数。

* **无环图**（**Acyclic Graph**）
不包含任何环的图。

* **邻接表**（**Adjacency List**）
一种实现图的技术。
它是一个能够通过边连接到给定顶点的顶点的列表。

* **邻接矩阵**（**Adjacency Matrix**）
一种实现图的技术。
它是一个矩阵，其中的每个条目`(r, c)`都代表着从顶点`r`到顶点`c`的边的信息（或者没有边）。

* **算法分析**（**Algorithm Analysis**）
使用数学技术来确定算法所需的计算资源（例如，时间和空间）。

* **别名**（**Aliasing**）
用来描述存在对同一个数据有多个有效的引用的情况。
通过其中一个引用，对数据进行的修改也将会影响到其他的引用。

* **API**
应用程序接口。

* **应用程序接口**（**Application Programming Interfaces**）
代码库或者框架提供的数据值、操作以及对象的集合。

* **数组**（**Array**）
通过连续的内存块来实现的，包含相同“单元”序列的集合。

* **ASCII**
美国标准信息交换码（American Standard Code for Information Interchange）。
用于编码文本的标准，其中每个字符由数字`0`到`127`表示。

* **汇编代码**（**Assembly Code**）
一种底层编程语言，它的结构和特定的计算机体系结构的底层机器语言直接对应。

* **关联数组**（**Associative Arrays**）
一种容器类型，实现从键到值的映射。

* **渐近符号**（**Asymptotic Notation**）
大$O$表示法。
一种用来描述算法对于给定大小的输入所需要的资源上限的方法。

* **属性**（**Attributes**）
对象的一个组件。
有时候，它会被用来表示对象里的数据，有些时候被用来表示它的操作。

* **AVL树**（**AVL Tree**）
一种用来保持二叉搜索树（几乎）平衡技术，从而可以让二叉搜索树进行高效的查询操作。

* **平衡树**（**Balanced Tree**）
一颗树，其中每一层的所有节点都具有（几乎）相同数量的后代。

* **基本情况**（**Base Case**）
在递归函数或者解决问题的时候，基本情况是指一个不需要再次进行递归分解的小版本的问题。

* **大$O$表示法**（**Big-O Notation**）
一种用来描述算法对于给定大小的输入所需要的资源上限的方法。

* **二叉堆**（**Binary Heap**）
用二叉树来实现的堆数据结构。

* **二分搜索**（**Binary Search**）
一种非常高效的、可以在已经排序了的集合里查找元素的搜索算法。
对于集合的大小是$n$的情况，需要和$\log_2 n$成正比的时间。

* **二叉搜索树**（**Binary Search Tree**）
具有二叉搜索属性的二叉树。
对于每个节点来说，它的左子树里的数据会小于它自身的数据，在右子树里的数据会大于它自身的数据。

* **二叉树**（**Binary Tree**）
每个节点最多有两个子节点的树。
这两个孩子通常上被称为“左”子节点和“右”子节点。

* **绑定**（**Binding**）
绑定是两件事物之间的关联。
变量是标识符（名称）与内存位置的绑定。

* **位**（**Bit**）
二进制数字，信息的基本单位。
它通常由`0`和`1`表示。

* **广度优先遍历**（**Breadth First Traversal**）
一种探索树或图的算法，这种方式会保证每个节点（顶点）的直接相连的子节点（顶点）在其他后代之前先被检查。

* **字节**（**Byte**）
八位的组合。
它是大多数现代计算机上最小的可寻址内存单元。

* **字节码**（**Byte Code**）
高级语言的源代码和机器语言之间的中间形式。
字节码可以在虚拟机解释器上执行，也可以被进一步编译为机器代码。

* **链式**（**Chaining**）
一种用来在容器结构的单个“槽”里维护多个元素的技术。
通常会用链表来维护这些元素。

* **类**（**Class**）
类描述了一组相关的对象。
在面向对象语言里，`class`机制相当于是被用来生成对象的“工厂”。

* **类变量**（**Class Variables**）
一个“生活”在某一个类里的变量，它的值会被这个类的所有实例共享。

* **客户端**（**Clients**）
在编程的语境里，使用另一个组件的模块被称为组件的客户端。

* **碰撞**（**Collision**）
当两个或多个不同的元素被散列到散列表里的相同位置时就会发生碰撞。

* **编译器**（**Compiler**）
把高级语言编写的程序转换为可以被特定的计算机执行的机器语言的程序。

* **完全图**（**Complete Graph**）
每个顶点都能够通过边连接到其他顶点的图。

* **完全树**（**Complete Tree**）
一棵树，除了最深一层之外的每一层都有最大可能的子节点数。

* **连接图**（**connected graph**）
一个图，其中存在从每个顶点到其他任何一个顶点的路径。

* **const方法**（**Const Method**）
在C++里，使用`const`指定声明的方法不能修改任何实例变量。

* **构造函数**（**Constructor**）
创建类的新的实例的方法。

* **容器类**（**Container Class**）
一种对象的类，这种对象的主要功能是能够存储一组对象。

* **复制构造函数**（**Copy Constructor**）
一个C++的构造函数，它会基于传递给它的相同类型的对象来创建它的一个新副本。

* **环**（**Cycle**）
图里在同一个顶点上开始和结束的路径。

* **数据压缩**（**Data Compression**）
一种通过更紧凑地（使用更少的比特）方式来表示信息，从而更方便存储以及传输的技术。

* **数据结构**（**Data Structures**）
一种存储数据的方法，从而可以方便这些数据可以被某些应用程序高效地使用。

* **数据类型**（**Data Type**）
表示数据的特定方式。
元素的数据类型可以确定它能够拥有的值，以及它所支持的操作。

* **调试**（**Debugging**）
查找和消除程序里的错误的过程。

* **决策语句**（**Decision Statement**）
一种控制结构，允许程序的不同部分根据具体的情况来执行。
通常决策由布尔表达式来判定。

* **声明**（**Declaration**）
声明语句是用来，向底层编译器或者解释器声明变量和函数（例如其类型）的属性的语句。

* **深拷贝**（**Deep Copy**）
数据的完整副本，可以让两个副本之间不共享任何可变结构。

* **定义**（**Definition**）
提供变量，或者实现函数的语句。

* **度**（**Degree**）
在无向图里，它是指连接到特定顶点的边的数量。

* **深度优先遍历**（**Depth First Traversal**）
在回溯或者考虑另一条路径之前，通过追踪单条后代的路径到达最大深度来探索树或图的算法。

* **出队**（**Dequeue**）
从先进先出的队列里移除元素的操作。

* **解引用**（**Dereference**）
获得由指针（地址）所引用的元素的过程。

* **析构函数**（**Destructor**）
被调用来“清理”不再需要的对象的方法。
比如说，在C++里，析构函数被用来释放动态内存。

* **字典**（**Dictionary**）
从键到值的映射，也被称为关联数组。

* **Dijkstra算法**（**Dijkstra’s Algorithm**）
一种高效的、用来查找图里的最短路径算法。

* **有向无环图**（**Directed acyclic Graph**）
一个有向图，它具有有向（单向）边，并且当以按照边的方向进行的路径上都没有环。

* **有向图**（**Directed Graph**）
有明确方向的边组成的图。
每条边都有一个起始顶点和一个到达顶点。

* **不交集结构**（**Disjoint Set Structure**）
用来追踪把集合划到不交集的数据结构。

* **不交集**（**Disjoint Set**）
没有共同元素的集合。

* **分治算法**（**Divide-and-Conquer Algorithm**）
一种算法设计技术，它的思想是把问题分解为原始问题的较小版本。

* **鸭子类型**（**Duck Typing**）
指动态编程语言里会用到的类型等价的方法。
不论任何类型的对象，只要实现了函数或方法里会需要的所有操作，就可以把它传递给这个函数或方法。
这个名字来自谚语：“如果一个东西像鸭子一样走路，像鸭子一样呱呱叫，那么它就是一只鸭子。”

* **虚节点**（**Dummy Node**）
链表前面或后面的特殊节点，通常被用来做标记，而不会包含任何数据。

* **动态内存**（**Dynamic Memory**）
在程序运行的时候分配和释放的内存。

* **动态规划**（**Dynamic Programming**）
一种开发高效算法的技术，这个技术可以用来处理可以被分解为一系列重复子问题的问题。

* **动态类型**（**Dynamic Typing**）
一种编程语言机制，在这种机制下，数据类型被附加到值上而不是通过变量进行配置，并且存储在特定变量里的实际数据类型可能会随时间而变化。

* **封装**（**Encapsulation**）
指隐藏某些东西的细节。
封装通常被用来描述对象或者函数的实现和使用之间的区别。
具体的实现细节被封装在定义之中。

* **事件驱动模拟**（**Event-Driven Simulation**）
一种编程来进行模拟的技术，它基于事件的概率生成，并在下一次事件发生的时候调整全局“时钟”。
时间驱动模拟和它是相对应的另一方面。

* **显式堆动态**（**Explicit Heap Dynamic**）
指代在C++里可以在程序员的控制下直接在运行时对内存进行分配和释放的情况。

* **指数算法**（**Exponential Algorithm**）
资源需求的增长为输入大小的指数函数的算法。

* **形参**（**Formal Parameter**）
出现在函数定义里的参数（和函数调用时不同）。

* **前向声明**（**Forward Declaration**）
某些程序元素的部分描述，用来通知编译器这部分内容会在稍后的程序里被完整的定义。
在静态类型的语言里，通常在定义递归数据结构的时候需要前向声明。

* **满树**（**Full Tree**）
一棵树，其中每个非叶节点都具有最大可能的子节点数。

* **全局变量**（**Global Variable**）
程序的所有部分都可以访问的变量。

* **图**（**Graph**）
一种抽象数据类型，包含一组顶点和一组与顶点对相关的边。

* **贪心算法**（**Greedy Algorithm**）
一种算法设计技术，它的思想是在多步骤策略的每个步骤都选择当前对前往最终目标帮助最大的方向。

* **散列函数**（**Hash Function**）
用来把某些数据转换为相对较小的整数的操作，通常被用来把数据定位到数组里。

* **散列表**（**Hash Table**）
一种容器数据结构，它实现了映射并且使用散列（把键映射到数字）来支持高效的插入操作和检索操作。

* **头部**（**Head**）
对链表里的第一个节点的通用叫法。

* **标头节点**（**Header Node**）
链表前面的虚节点。

* **堆（数据结构）**（**Heap**）
一种有序的容器数据结构，支持高效地插入元素以及高效地删除最小（或最大）的元素。

* **堆（内存分配）**（**Heap**）
可以在运行时动态分配对象的内存区域。

* **堆排序**（**Heap Sort**）
一种基于堆数据结构的$n \log n$复杂度的排序算法。

* **霍夫曼编码**（**Huffman Coding**）
一种基于树数据结构的数据压缩算法。

* **实现独立性**（**Implementation Independence**）
在不影响服务的客户端的情况下对服务的实现进行修改的能力。

* **隐式堆动态**（**Implicit Heap Dynamic**）
编程语言的运行时系统会自动管理在运行时为对象分配的内存。
拥有垃圾回收的语言（比如Python）会提供隐式堆动态存储。

* **入度**（**In-degree**）
对于有向图的顶点来说，入度是进入这个顶点的边的总数。

* **继承**（**Inheritance**）
将新类定义成另一个类的特例。

* **内联函数/方法**（**Inline Function/Method**）
一种告诉编译器应该在程序里的调用函数/方法的每个点都直接插入函数体/方法体的机制，从而避免函数/方法调用的运行时开销。

* **实例变量**（**Instance Variables**）
存储在对象内的一部分数据。

* **实例化**（**Instantiation**）
在C++里，创建模板函数或类的特定实例的过程。

* **接口**（**Interface**）
两个组件之间的连接。
对于函数或方法来说，接口由函数或方法的名称、它的参数以及它的返回值组成；
对于对象来说，接口是一组用来操作对象的方法（以及这些方法的接口）。
而术语“用户界面”是用来描述人与计算机应用程序之间是如何交互的。

* **解释器**（**Interpreter**）
一种计算机程序，用来模拟计算机理解高级语言的行为。
它会逐行执行源代码并执行相应的操作。

* **不变量**（**Invariant**）
函数、方法、循环或类的先验条件和后置条件。
对于类来说，不变量是指每个方法的先验条件和后置条件。
对于循环，不变量在每次迭代之前都为`true`，并且在循环完成的时候仍然为`true`。

* **迭代器**（**Iterator**）
一个对象，它封装了遍历集合的位置。
迭代器被用来通过实现独立性的方式循环访问集合里的于元素。

* **Kruskal算法**（**Kruskal's Algorithm**）
一种查找加权图的最小生成树的算法。

* **左值**（**l-value**）
它“是指”出现在赋值语句的左侧的标识符。

* **库**（**Library**）
可以在程序里导入和使用的有用的函数或类的集合。

* **（变量的）生命周期**（**Lifetime**）
在程序执行期间，变量绑定到存储位置的时间。

* **线性算法**（**Linear Algorithm**）
运行时间与输入大小成正比的算法。

* **链接器**（**Linker**）
把已经编译过了的程序单元组装成整体可执行的程序。

* **列表**（**List**）
用来表示顺序集合的常规Python数据类型。
列表是允许包含不同数据类型的，也可以根据需要增大和缩小。
可以通过下标来访问元素。

* **文字**（**Literal**）
一个在编程语言里编写特定值的方法。
比如说，`3`是一个`int`类型的文字，`"Hello"`是一个`string`类型的文字。

* **局部变量**（**Local Variable**）
函数或方法里的变量，它的作用域仅限于这个函数或方法。

* **无损压缩**（**Lossless Compression**）
任何能够保留所有信息的压缩技术，从而可以保证原始数据能够被准确重建。

* **有损压缩**（**Lossy Compression**）
任何可能会丢失某些信息的压缩技术，从而可能会导致原始数据不能够被完美重建。

* **机器代码**（**Machine Code**）
用特定计算机的机器语言编写的程序。

* **宏**（**Macro**）
在C++里，它类似于函数的定义，但在“调用”的时候，它会在编译程序之前由C++的预处理器进行文本扩展。

* **记忆化**（**Memoization**）
一种算法技术，用来自动“缓存”之前的计算结果，从而能够在以后再次需要的时候，可以直接返回计算结果，而不再需要进行额外的计算。

* **内存泄漏**（**Memory Leak**）
分配了内存但在不再使用的时候没有去释放这部分内存的程序错误。

* **方法**（**Methods**）
在对象内部的函数。
通过调用方法来对对象进行操作。

* **最小生成树**（**Minimum Spanning Tree**）
是一个树状子图，是连接图的所有顶点并且具有最小权重的树，由所包含的边的权重之和来进行衡量。

* **非贫血**（**Mutable**）
可变的。
可以改变状态的对象被认为是可变的。
比如说：Python的`int`和`string`是贫血的，但是列表是非贫血的。

* **变异方法**（**Mutator Method**）
一种改变对象状态的方法（比如说：会修改一个或多个实例变量）。

* **命名空间**（**Namespace**）
在给定范围内定义的标识符集。
Python使用可检查的字典来表示命名空间。

* **非局部变量**（**non-Local Variable**）
在某个给定范围内没有定义，但是可以访问的变量。
全局变量就是一个非局部变量。

* **NP问题**（**NP**）
非确定性多项式时间算法可以解决的问题类别。
从直觉上来看，这些问题的解决方案都可以在多项式时间内进行正确性验证，但实际上的解决方案是需要在指数时间内完成的。

* **NP完全问题**（**NP-Complete**）
已知的NP问题里最难的问题类别。
所有的NP问题都能够被归约到它。

* **对象**（**Object**）
一个程序实体，它具有一些数据和一组操作来对这些数据进行操作。

* **基于对象**（**Object-Based**）
用来描述：使用对象作为抽象的主要形式的设计和编程。

* **面向对象**（**Object-Oriented**）
用来描述：基于对象的、包括多态和继承特征的设计和编程。

* **开放定址法**（**Open Addressing**）
在散列表里查找备用位置，从而避免冲突的过程。
可以和链式进行比较。

* **运算符重载**（**Operator Overloading**）
将多个方法或函数附加到特定的语法运算符。

* **出度**（**Out-degree**）
在有向图里，离开顶点的边数的总数。

* **溢出**（**Overflow**）
当存储的值所需的比特数超过为其分配的比特数的时候会发生溢出。

* **P问题**（**P**）
可以在多项式时间内确定性地解决的问题类别。

* **参数**（**Parameter**）
函数里的一个特殊变量，在调用的时候使用从调用者传递的信息进行初始化。

* **引用传递**（**Pass by Reference**）
在某些计算机语言里使用的参数传递技术，它能够让被调用的函数对作为实参的变量的值进行修改。

* **值传递**（**Pass by Value**）
一种参数传递的技术，通过值传递的形参会被实参的值赋值。
这个函数不能修改实参变量所引用的对象。

* **路径**（**Path**）
在图里，路径是一系列可以被边连接起来的顶点的序列。

* **指针**（**Pointer**）
一个只想某些数据的内存地址的变量。

* **多态**（**Polymorphism**）
字面上是“多种形式”的意思。
在面向对象的编程里，指特定部分的代码功能可以根据不同对象的数据类型来有不同的实现方法。

* **前置码**（**Prefix Code**）
一种编码方案，其中没有编码可以是另一个编码的前置部分。

* **无首码的代码**（**Prefix-Free Code**）
前置码。

* **Prim算法**（**Prim’s Algorithm**）
一种查找图的最小生成树的算法。

* **优先队列**（**Priority Queue**）
容器抽象数据类型，包含插入元素以及删除最大（或最小）元素的操作。

* **伪代码**（**Pseudocode**）
使用精确的自然语言而不是计算机语言来编写的算法。

* **二次方算法**（**Quadratic Algorithm**）
资源的需求随输入大小的平方而变化的算法。

* **队列**（**Queue**）
具有先进先出访问权限的容器抽象数据类型。

* **快速排序**（**Quicksort**）
一种在平均情况下$n \log n$复杂度的排序算法。

* **右值**（**r-value**）
出现在赋值语句的右侧的标识符。

* **递推关系式**（**Recurrence Relation**）
递推地定义一个序列的方程：序列里的每一项都是在之前被定义的项的函数。

* **递归**（**Recursion**）
一种根据自身来定义某种东西的技术。

* **引用计数**（**Reference Count**）
与对象相关的字段，用来计算引用这个对象的变量的数量。
Python会自动对引用进行计数，并且在引用计数变为`0`的时候执行垃圾回收。

* **引用语义**（**Reference Semantics**）
当一个编程语言的变量存储的总是在堆上分配的数据对象的引用，而不去存储数据对象本身的情况。

* **回归测试**（**Regression Testing**）
当程序被改变的时候，再次运行一组先前通过的测试的情况。

* **保留字**（**Reserved Word**）
表示是语言内置语法的一部分的标识符。

* **行主序**（**Row-Major Order**）
在把多维数组存到内存里的时候，按照行的顺序来一行一行地进行。

* **作用域**（**Scope**）
程序的文本区域，在这个区域内可以引用特定的变量。

* **语义**（**Semantics**）
构造的意思。

* **浅拷贝**（**Shallow Copy**）
数据结构的副本，其中只有较高层级的引用会被复制，而且这个副本和原始对象会共享较低层级的结构。

* **短路求值**（**Short-Circuit Evaluation**）
一个评估过程，一旦结果已经知道了就立刻返回答案，而不必对所有的子表达式都进行评估。
比如：对于表达式`(True or isover())`来说，`isover()`函数不会被调用。

* **签名**（**Signature**）
函数接口的另一个说法。
签名包含函数的名称、参数以及返回值。

* **模拟**（**Simulation**）
一个被设计得通过抽象来模仿某些现实世界过程的程序。

* **规范**（**Specification**）
对某些组件的功能，而不是它的工作原理进行的准确描述。

* **堆栈动态**（**Stack Dynamic**）
用来描述在运行时堆栈上分配的变量的术语。
当函数或方法开始的时候，堆栈动态变量在运行时堆栈上被分配内存。
当函数或方法结束的时候，运行时堆栈会缩小，从而有效地释放这些用于堆栈动态变量的内存。

* **静态类型**（**Static Typing**）
一种编程语言技术，在这种机制下，数据类型被附加到变量上，之后这个变量就只能被具有相同类型的值赋值了。

* **静态变量**（**Static Variable**）
在C++里，静态变量是一个特殊的局部变量，它能够把值维护在函数的不同调用里。

* **对称矩阵**（**Symmetric Matrix**）
与自身的转置相同的矩阵。

* **句法**（**Syntax**）
语言的组成形式。

* **模板**（**Templates**）
一种C++机制，能够用来编写由数据类型参数化，并且编译器会自动特殊处理（实例化）的泛型函数或类。

* **测试驱动开发**（**Test-Driven Development**）
一种增量程序开发方法，在这种方法里，会为每个新功能的组件先编写测试，再去编写能够通过测试的产品代码。

* **$Θ$表示法**（**Theta Notation**）
一种算法分析，它能够根据输入的大小提供所需资源的紧束缚。

* **拓扑排序**（**Topological Sort**）
有向无环图里的顶点的总线性排序，这个排序的结果会让所有顶点都出现在它的后代之前。

* **遍历**（**Traversal**）
顺序访问数据结构里的每一个元素的过程。

* **树**（**Tree**）
由根节点及其后代组成的分层数据结构。

* **元组**（**Tuple**）
一种Python的序列类型，它类似于不可变的列表。

* **无向图**（**Undirected Graph**）
所有边都是顶点对的互相配对的图。

* **单元测试**（**Unit Testing**）
对程序里独立于其他部分的组件进行尝试的过程。

* **值语义**（**Value Semantics**）
在赋值语句里，表达式的值实际上是被复制到变量里去情况。
与之对应的是引用语义，引用语义会在变量里存储对同一个对象的另一个引用。

* **变量**（**Variables**）
在编程语言里，指定的存储位置的抽象。

* **有权图**（**Weighted Graph**）
边有相关的数值的图。
